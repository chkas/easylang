<!doctype html>
<meta charset=utf-8><title>Easylang - Rosetta Code</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="icon" href="../icon.png" type="image/x-png">

<div id=tut><b>Loading ...</b></div>
<script src=easy_code2.js></script>
<script src=easy_tut2.js></script>

<script>

txt_split = "\n*\n"

txt_tutor=`* Rosetta Code with Easylang
*
* 10001th prime
*
@ https://www.rosettacode.org/wiki/10001th_prime@Task
*
fastfunc isprim num .
   if num mod 2 = 0 and num > 2
      return 0
   .
   i = 3
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
i = 2
repeat
   if isprim i = 1
      nprim += 1
   .
   until nprim = 10001
   i += 1
.
print i
*
* ABC problem
*
@ https://www.rosettacode.org/wiki/ABC_problem@Task
*
b$[][] = [ [ "B" "O" ] [ "X" "K" ] [ "D" "Q" ] [ "C" "P" ] [ "N" "A" ] [ "G" "T" ] [ "R" "E" ] [ "T" "G" ] [ "Q" "D" ] [ "F" "S" ] [ "J" "W" ] [ "H" "U" ] [ "V" "I" ] [ "A" "N" ] [ "O" "B" ] [ "E" "R" ] [ "F" "S" ] [ "L" "Y" ] [ "P" "C" ] [ "Z" "M" ] ]
len b[] len b$[][]
global w$[] cnt .
#
proc backtr wi . .
   if wi > len w$[]
      cnt += 1
      return
   .
   for i = 1 to len b$[][]
      if b[i] = 0 and (b$[i][1] = w$[wi] or b$[i][2] = w$[wi])
         b[i] = 1
         backtr wi + 1
         b[i] = 0
      .
   .
.
for s$ in [ "A" "BARK" "BOOK" "TREAT" "COMMON" "SQUAD" "CONFUSE" ]
   w$[] = strchars s$
   cnt = 0
   backtr 1
   print s$ & " can be spelled in " & cnt & " ways"
.
*
* Ackermann function
*
@ https://www.rosettacode.org/wiki/Ackermann_function@Task
*
func ackerm m n .
   if m = 0
      return n + 1
   elif n = 0
      return ackerm (m - 1) 1
   else
      return ackerm (m - 1) ackerm m (n - 1)
   .
.
print ackerm 3 6
*
* Animate a pendulum
*
@ https://www.rosettacode.org/wiki/Animate_a_pendulum@Task
*
ang = 45
on animate
  clear
  move 50 50
  circle 1
  x = 50 + 40 * sin ang
  y = 50 + 40 * cos ang
  line x y
  circle 6
  vel += sin ang / 5
  ang += vel
.
*
* Archimedean spiral
*
@ https://www.rosettacode.org/wiki/Archimedean_spiral@Task
*
linewidth 0.4
x = 50
y = 50
while r < 50
   line r * cos t + x r * sin t + y
   r += 0.05
   t += 3
.
*
* Arithmetic evaluation
*
@ https://www.rosettacode.org/wiki/Arithmetic_evaluation@Task
*
subr nch
   if inp_ind > len inp$[]
      ch$ = strchar 0
   else
      ch$ = inp$[inp_ind]
      inp_ind += 1
   .
   ch = strcode ch$
.
# 
subr ntok
   while ch$ = " "
      nch
   .
   if ch >= 48 and ch <= 58
      tok$ = "n"
      s$ = ""
      while ch >= 48 and ch <= 58 or ch$ = "."
         s$ &= ch$
         nch
      .
      tokv = number s$
   elif ch = 0
      tok$ = "end of text"
   else
      tok$ = ch$
      nch
   .
.
subr init0
   astop$[] = [ ]
   astleft[] = [ ]
   astright[] = [ ]
   err = 0
.
proc init s$ . .
   inp$[] = strchars s$
   inp_ind = 1
   nch
   ntok
   init0
.
proc ast_print nd . .
   write "AST:"
   for i to len astop$[]
      write " ( "
      write astop$[i] & " "
      write astleft[i] & " "
      write astright[i]
      write " )"
   .
   print " Start: " & nd
.
func node .
   astop$[] &= ""
   astleft[] &= 0
   astright[] &= 0
   return len astop$[]
.
# 
funcdecl parse_expr .
# 
func parse_factor .
   if tok$ = "n"
      nd = node
      astop$[nd] = "n"
      astleft[nd] = tokv
      ntok
   elif tok$ = "("
      ntok
      nd = parse_expr
      if tok$ <> ")"
         err = 1
         print "error: ) expected, got " & tok$
      .
      ntok
   else
      err = 1
      print "error: factor expected, got " & tok$
   .
   return nd
.
func parse_term .
   ndx = parse_factor
   while tok$ = "*" or tok$ = "/"
      nd = node
      astleft[nd] = ndx
      astop$[nd] = tok$
      ntok
      astright[nd] = parse_factor
      ndx = nd
   .
   return ndx
.
func parse_expr .
   ndx = parse_term
   while tok$ = "+" or tok$ = "-"
      nd = node
      astleft[nd] = ndx
      astop$[nd] = tok$
      ntok
      astright[nd] = parse_term
      ndx = nd
   .
   return ndx
.
func parse s$ .
   init s$
   return parse_expr
.
func eval nd .
   if astop$[nd] = "n"
      return astleft[nd]
   .
   le = eval astleft[nd]
   ri = eval astright[nd]
   a$ = astop$[nd]
   if a$ = "+"
      return le + ri
   elif a$ = "-"
      return le - ri
   elif a$ = "*"
      return le * ri
   elif a$ = "/"
      return le / ri
   .
.
repeat
   inp$ = input
   until inp$ = ""
   print "Inp: " & inp$
   nd = parse inp$
   ast_print nd
   if err = 0
      print "Eval: " & eval nd
   .
   print ""
.
input_data
4 * 
4.2 * ((5.3+8)*3 + 4)
2.5 * 2 + 2 * 3.14
*
* Ascending primes
*
@ https://www.rosettacode.org/wiki/Ascending_primes@Task
*
func isprim num .
   if num < 2
      return 0
   .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
proc nextasc n . .
   if isprim n = 1
      write n & " "
   .
   if n > 123456789
      return
   .
   for d = n mod 10 + 1 to 9
      nextasc n * 10 + d
   .
.
nextasc 0
*
* Barnsley fern
*
@ https://www.rosettacode.org/wiki/Barnsley_fern@Task
*
color 060
for i = 1 to 200000
  r = randomf
  if r < 0.01
    nx = 0
    ny = 0.16 * y
  elif r < 0.08
    nx = 0.2 * x - 0.26 * y
    ny = 0.23 * x + 0.22 * y + 1.6
  elif r < 0.15
    nx = -0.15 * x + 0.28 * y
    ny = 0.26 * x + 0.24 * y + 0.44
  else
    nx = 0.85 * x + 0.04 * y
    ny = -0.04 * x + 0.85 * y + 1.6
  .
  x = nx
  y = ny
  move 50 + x * 15 y * 10
  rect 0.3 0.3
.
*
* Brownian tree
*
@ https://www.rosettacode.org/wiki/Brownian_tree@Task
*
color3 0 1 1
len f[] 200 * 200
move 50 50
rect 0.5 0.5
f[100 * 200 + 100] = 1
n = 9000
while i < n
  repeat
    x = random 200 - 1
    y = random 200 - 1
    until f[y * 200 + x + 1] <> 1
  .
  while 1 = 1
    xo = x
    yo = y
    x += random 3 - 2
    y += random 3 - 2
    if x < 0 or y < 0 or x >= 200 or y >= 200
      break 1
    .
    if f[y * 200 + x + 1] = 1
      move xo / 2 yo / 2
      rect 0.5 0.5
      f[yo * 200 + xo + 1] = 1
      i += 1
      if i mod 16 = 0
        color3 0.2 + i / n 1 1
        sleep 0
      .
      break 1
    .
  .
.
*
* Calculating the value of e
*
@ https://www.rosettacode.org/wiki/Calculating_the_value_of_e@Task
*
numfmt 5 0
fact = 1
n = 2
e = 2
while abs (e - e0) > 0.0001
  e0 = e
  fact = fact * n
  n += 1
  e += 1 / fact
.
print e
*
* Chaos game
*
@ https://www.rosettacode.org/wiki/Chaos_game@Task
*
color 900
x[] = [ 0 100 50 ]
y[] = [ 7 7 93 ]
x = randomf * 100
y = randomf * 100
for i = 1 to 100000
  move x y
  rect 0.3 0.3
  h = random 3
  x = (x + x[h]) / 2
  y = (y + y[h]) / 2
.
*
* Colour bars/Display
*
@ https://www.rosettacode.org/wiki/Colour_bars/Display@Task
*
col[] = [ 000 900 090 009 909 099 990 999 ]
w = 100 / len col[]
for i = 1 to len col[]
   color col[i]
   move w * (i - 1) 0
   rect w 100
.
*
* Conway's Game of Life
*
@ https://www.rosettacode.org/wiki/Conway's_Game_of_Life@Task
*
n = 70
time = 0.1
# 
nx = n + 1
subr init
   for r = 1 to n
      for c = 1 to n
         i = r * nx + c
         if randomf < 0.3
            f[i] = 1
         .
      .
   .
.
f = 100 / n
subr show
   clear
   for r = 1 to n
      for c = 1 to n
         if f[r * nx + c] = 1
            move c * f - f r * f - f
            rect f * 0.9 f * 0.9
         .
      .
   .
.
subr update
   swap f[] p[]
   for r = 1 to n
      sm = 0
      i = r * nx + 1
      sr = p[i - nx] + p[i] + p[i + nx]
      for c = 1 to n
         sl = sm
         sm = sr
         in = i + 1
         sr = p[in - nx] + p[in] + p[in + nx]
         s = sl + sm + sr
         if s = 3 or s = 4 and p[i] = 1
            f[i] = 1
         else
            f[i] = 0
         .
         i = in
      .
   .
.
on timer
   update
   show
   timer time
.
on mouse_down
   c = mouse_x div f + 1
   r = mouse_y div f + 1
   i = r * nx + c
   f[i] = 1 - f[i]
   show
   timer 3
.
len f[] nx * nx + nx
len p[] nx * nx + nx
init
timer 0
*
* Count the coins
*
@ https://www.rosettacode.org/wiki/Count_the_coins@Task
*
len cache[] 100000 * 7 + 6
val[] = [ 1 5 10 25 50 100 ]
func count sum kind .
   if sum = 0
      return 1
   .
   if sum < 0 or kind = 0
      return 0
   .
   chind = sum * 7 + kind
   if cache[chind] > 0
      return cache[chind]
   .
   r2 = count (sum - val[kind]) kind
   r1 = count sum (kind - 1)
   r = r1 + r2
   cache[chind] = r
   return r
.
print count 100 4
print count 10000 6
print count 100000 6
# this is not exact, since numbers
# are doubles and r > 2^53
*
* Dragon curve
*
@ https://www.rosettacode.org/wiki/Dragon_curve@Task
*
color 050
linewidth 0.5
x = 25
y = 60
move x y
angle = 0
# 
proc dragon size lev d . .
   if lev = 0
      x -= cos angle * size
      y += sin angle * size
      line x y
   else
      dragon size / sqrt 2 lev - 1 1
      angle -= d * 90
      dragon size / sqrt 2 lev - 1 -1
   .
.
dragon 60 12 1
*
* Draw a clock
*
@ https://www.rosettacode.org/wiki/Draw_a_clock@Task
*
proc draw hour min sec . .
   # dial
   color 333
   move 50 50
   circle 45
   color 797
   circle 44
   color 333
   for i range0 60
      a = i * 6
      move 50 + sin a * 40 50 + cos a * 40
      circle 0.25
   .
   for i range0 12
      a = i * 30
      move 50 + sin a * 40 50 + cos a * 40
      circle 1
   .
   # hour
   linewidth 2
   color 000
   a = (hour * 60 + min) / 2
   move 50 50
   line 50 + sin a * 32 50 + cos a * 32
   # min
   linewidth 1.5
   a = (sec + min * 60) / 10
   move 50 50
   line 50 + sin a * 40 50 + cos a * 40
   # sec  
   linewidth 1
   color 700
   a = sec * 6
   move 50 50
   line 50 + sin a * 40 50 + cos a * 40
.
on timer
   if t <> floor systime
      t = floor systime
      h$ = timestr t
      sec = number substr h$ 18 2
      min = number substr h$ 15 2
      hour = number substr h$ 12 2
      if hour > 12
         hour -= 12
      .
      draw hour min sec
   .
   timer 0.1
.
timer 0
*
* Draw a rotating cube
*
@ https://www.rosettacode.org/wiki/Draw_a_rotating_cube@Task
*
node[][] = [ [ -1 -1 -1 ] [ -1 -1 1 ] [ -1 1 -1 ] [ -1 1 1 ] [ 1 -1 -1 ] [ 1 -1 1 ] [ 1 1 -1 ] [ 1 1 1 ] ]
edge[][] = [ [ 1 2 ] [ 2 4 ] [ 4 3 ] [ 3 1 ] [ 5 6 ] [ 6 8 ] [ 8 7 ] [ 7 5 ] [ 1 5 ] [ 2 6 ] [ 3 7 ] [ 4 8 ] ]
# 
proc scale f . .
   for i = 1 to len node[][]
      for d = 1 to 3
         node[i][d] *= f
      .
   .
.
proc rotate angx angy . .
   sinx = sin angx
   cosx = cos angx
   siny = sin angy
   cosy = cos angy
   for i = 1 to len node[][]
      x = node[i][1]
      z = node[i][3]
      node[i][1] = x * cosx - z * sinx
      y = node[i][2]
      z = z * cosx + x * sinx
      node[i][2] = y * cosy - z * siny
      node[i][3] = z * cosy + y * siny
   .
.
len nd[] 3
proc draw . .
   clear
   m = 999
   mi = -1
   for i = 1 to len node[][]
      if node[i][3] < m
         m = node[i][3]
         mi = i
      .
   .
   ix = 1
   for i = 1 to len edge[][]
      if edge[i][1] = mi
         nd[ix] = edge[i][2]
         ix += 1
      elif edge[i][2] = mi
         nd[ix] = edge[i][1]
         ix += 1
      .
   .
   for ni = 1 to len nd[]
      for i = 1 to len edge[][]
         if edge[i][1] = nd[ni] or edge[i][2] = nd[ni]
            x1 = node[edge[i][1]][1]
            y1 = node[edge[i][1]][2]
            x2 = node[edge[i][2]][1]
            y2 = node[edge[i][2]][2]
            move x1 + 50 y1 + 50
            line x2 + 50 y2 + 50
         .
      .
   .
.
scale 25
rotate 45 atan sqrt 2
draw
on animate
   rotate 1 0
   draw
.
*
* Forest fire
*
@ https://www.rosettacode.org/wiki/Forest_fire@Task
*
p_fire = 0.00002
p_tree = 0.002
# 
len f[] 102 * 102
len p[] len f[]
background 100
clear
for r = 0 to 99
   for c = 0 to 99
      i = r * 102 + c + 104
      if randomf < 0.5
         f[i] = 1
      .
   .
.
timer 0
# 
subr show
   for r = 0 to 99
      for c = 0 to 99
         i = r * 102 + c + 104
         h = f[i]
         if h <> p[i]
            move c + 0.5 r + 0.5
            if h = 0
               color 100
               circle 0.6
            elif h = 1
               color 151
               circle 0.5
            else
               color 9 * 100 + (18 - 2 * h) * 10
               circle 0.5
            .
         .
      .
   .
.
subr update
   swap f[] p[]
   for r = 0 to 99
      for c = 0 to 99
         i = r * 102 + c + 104
         if p[i] = 0
            f[i] = 0
            if randomf < p_tree
               f[i] = 1
            .
         elif p[i] = 1
            f[i] = 1
            s = p[i - 103] + p[i - 102] + p[i - 101]
            s += p[i - 1] + p[i + 1]
            s += p[i + 101] + p[i + 102] + p[i + 103]
            if s >= 9 or randomf < p_fire
               f[i] = 9
            .
         elif p[i] = 4
            f[i] = 0
         else
            f[i] = p[i] - 1
         .
      .
   .
.
on timer
   show
   update
   timer 0.2
.
*
* Fractal tree
*
@ https://www.rosettacode.org/wiki/Fractal_tree@Task
*
# Fractal tree
# 
color 555
proc tree x y deg n . .
   if n > 0
      linewidth n * 0.4
      move x y
      x += cos deg * n * 1.3 * (randomf + 0.5)
      y += sin deg * n * 1.3 * (randomf + 0.5)
      line x y
      tree x y deg - 20 n - 1
      tree x y deg + 20 n - 1
   .
.
timer 0
on timer
   clear
   tree 50 10 90 10
   timer 2
.
*
* Greatest common divisor
*
@ https://www.rosettacode.org/wiki/Greatest_common_divisor@Task
*
func gcd a b .
   while b <> 0
      h = b
      b = a mod b
      a = h
   .
   return a
.
print gcd 120 35
*
* Greatest element of a list
*
@ https://www.rosettacode.org/wiki/Greatest_element_of_a_list@Task
*
a[] = [ 2 9 4 3 8 5 ]
for e in a[]
  max = higher e max
.
print max
*
* Greyscale bars/Display
*
@ https://www.rosettacode.org/wiki/Greyscale_bars/Display@Task
*
n = 8
for row = 0 to 3
   sz = 100 / n
   for i = 0 to n - 1
      c = i / (n - 1)
      if row mod 2 = 1
         c = 1 - c
      .
      color3 c c c
      move sz * i 75 - row * 25
      rect sz + 1 25
      sleep 0.02
   .
   n *= 2
.
*
* Guess the number/With feedback
*
@ https://www.rosettacode.org/wiki/Guess_the_number/With_feedback@Task
*
print "Guess a number between 1 and 100!"
n = random 100
repeat
   g = number input
   write g
   if error = 1
      print "You must enter a number!"
   elif g > n
      print " is too high"
   elif g < n
      print " is too low"
   .
   until g = n
.
print " is correct"
*
* Hello world/Graphical
*
@ https://www.rosettacode.org/wiki/Hello_world/Graphical@Task
*
move 10 20
text "Goodbye, World!"
*
* Hilbert curve
*
@ https://www.rosettacode.org/wiki/Hilbert_curve@Task
*
order = 64
linewidth 32 / order
scale = 100 / order - 100 / (order * order)
proc hilbert x y lg i1 i2 . .
   if lg = 1
      line (order - x) * scale (order - y) * scale
      return
   .
   lg = lg div 2
   hilbert x + i1 * lg y + i1 * lg lg i1 1 - i2
   hilbert x + i2 * lg y + (1 - i2) * lg lg i1 i2
   hilbert x + (1 - i1) * lg y + (1 - i1) * lg lg i1 i2
   hilbert x + (1 - i2) * lg y + i2 * lg lg 1 - i1 i2
.
hilbert 0 0 order 0 0
*
* Julia set
*
@ https://www.rosettacode.org/wiki/Julia_set@Task
*
cx = -0.7
cy = 0.27015
for y = 0 to 299
  for x = 0 to 299
    zx = (x - 150) / 100
    zy = (y - 150) / 150
    color3 0 0 0
    for iter = 0 to 127
      if zx * zx + zy * zy > 4
        color3 iter / 16 0 0
        break 1
      .
      h = zx * zx - zy * zy + cx
      zy = 2 * zx * zy + cy
      zx = h
    .
    move x / 3 y / 3
    rect 0.4 0.4
  .
.
*
* Knapsack problem/0-1
*
@ https://www.rosettacode.org/wiki/Knapsack_problem/0-1@Task
*
name$[] = [ "map" "compass" "water" "sandwich" "glucose" "tin" "banana" "apple" "cheese" "beer" "suntan cream" "camera" "t-shirt" "trousers" "umbrella" "waterproof trousers" "waterproof overclothes" "note-case" "sunglasses" "towel" "socks" "book" ]
weight[] = [ 9 13 153 50 15 68 27 39 23 52 11 32 24 48 73 42 43 22 7 18 4 30 ]
value[] = [ 150 35 200 160 60 45 60 40 30 10 70 30 15 10 40 70 75 80 20 12 50 10 ]
max_w = 400
# 
proc solve i maxw . items[] wres vres .
   if i <= 0
      wres = 0
      vres = 0
      items[] = [ ]
   elif weight[i] > maxw
      solve i - 1 maxw items[] wres vres
   else
      solve i - 1 maxw items[] wres vres
      solve i - 1 maxw - weight[i] items1[] w1 v1
      v1 += value[i]
      if v1 > vres
         swap items[] items1[]
         items[] &= i
         wres = w1 + weight[i]
         vres = v1
      .
   .
.
solve len weight[] max_w items[] w v
print "weight: " & w
print "value: " & v
print "items:"
for item in items[]
   print "  " & name$[item]
.
*
* Knuth shuffle
*
@ https://www.rosettacode.org/wiki/Knuth_shuffle@Task
*
proc shuffle . a[] .
   for i = len a[] downto 2
      r = random i
      swap a[r] a[i]
   .
.
arr[] = [ 1 2 3 ]
shuffle arr[]
print arr[]
*
* Koch curve
*
@ https://www.rosettacode.org/wiki/Koch_curve@Task
*
proc koch x1 y1 x2 y2 iter . .
   x3 = (x1 * 2 + x2) / 3
   y3 = (y1 * 2 + y2) / 3
   x4 = (x1 + x2 * 2) / 3
   y4 = (y1 + y2 * 2) / 3
   x5 = x3 + (x4 - x3) * cos 60 + (y4 - y3) * sin 60
   y5 = y3 - (x4 - x3) * sin 60 + (y4 - y3) * cos 60
   if iter > 0
      iter -= 1
      koch x1 y1 x3 y3 iter
      koch x3 y3 x5 y5 iter
      koch x5 y5 x4 y4 iter
      koch x4 y4 x2 y2 iter
   else
      line x1 y1
      line x3 y3
      line x5 y5
      line x4 y4
      line x2 y2
   .
.
linewidth 0.3
x1 = 15
y1 = 30
move x1 y1
for ang = 0 step 120 to 240
   x2 = x1 + 70 * cos ang
   y2 = y1 + 70 * sin ang
   koch x1 y1 x2 y2 4
   x1 = x2
   y1 = y2
.
*
* Langton's ant
*
@ https://www.rosettacode.org/wiki/Langton's_ant@Task
*
len f[] 100 * 100
proc show . .
   for y = 0 to 99
      for x = 0 to 99
         if f[y * 100 + x + 1] = 1
            move x y
            rect 1 1
         .
      .
   .
.
proc run x y dir . .
   dx[] = [ 0 1 0 -1 ]
   dy[] = [ -1 0 1 0 ]
   while x >= 0 and x < 100 and y >= 0 and y < 100
      v = f[y * 100 + x + 1]
      f[y * 100 + x + 1] = 1 - v
      dir = (dir + 2 * v) mod 4 + 1
      x += dx[dir]
      y += dy[dir]
   .
.
run 70 40 0
show
*
* Largest number divisible by its digits
*
@ https://www.rosettacode.org/wiki/Largest_number_divisible_by_its_digits@Task
*
global found dig[] .
proc test . .
   for i to len dig[]
      n = n * 10 + dig[i]
   .
   for i to len dig[]
      if n mod dig[i] <> 0
         return
      .
   .
   found = 1
   print n
.
len use[] 9
proc perm pos . .
   if found = 1
      return
   .
   for i = 9 downto 1
      dig[pos] = i
      if use[i] = 0
         use[i] = 1
         if pos = len dig[]
            test
         else
            perm pos + 1
         .
         use[i] = 0
      .
   .
.
for ndig = 9 downto 1
   len dig[] ndig
   perm 1
.
*
* Long multiplication
*
@ https://www.rosettacode.org/wiki/Long_multiplication@Task
*
func$ mult a$ b$ .
   a[] = number strchars a$
   b[] = number strchars b$
   len r[] len a[] + len b[]
   for ib = len b[] downto 1
      h = 0
      for ia = len a[] downto 1
         h += r[ia + ib] + b[ib] * a[ia]
         r[ia + ib] = h mod 10
         h = h div 10
      .
      r[ib] += h
   .
   r$ = ""
   for i = 1 to len r[]
      if r$ <> "" or r[i] <> 0 or i = len r[]
         r$ &= r[i]
      .
   .
   return r$
.
print mult "18446744073709551616" "18446744073709551616"
*
* Mandelbrot set
*
@ https://www.rosettacode.org/wiki/Mandelbrot_set@Task
*
# Mandelbrot
#  
res = 4
maxiter = 200
# 
# better but slower:
# res = 8
# maxiter = 300
# 
#  
mid = res * 50
center_x = 3 * mid / 2
center_y = mid
scale = mid
# 
background 000
textsize 2
# 
fastfunc iter cx cy maxiter .
   while xx + yy < 4 and it < maxiter
      y = 2 * x * y + cy
      x = xx - yy + cx
      xx = x * x
      yy = y * y
      it += 1
   .
   return it
.
proc draw . .
   clear
   for scr_y = 0 to 2 * mid - 1
      cy = (scr_y - center_y) / scale
      for scr_x = 0 to 2 * mid - 1
         cx = (scr_x - center_x) / scale
         it = iter cx cy maxiter
         if it < maxiter
            color3 it / 20 it / 100 it / 150
            move scr_x / res scr_y / res
            rect 1 / res 1 / res
         .
      .
   .
   color 990
   move 1 1
   text "Short press to zoom in, long to zoom out"
.
on mouse_down
   time0 = systime
.
on mouse_up
   center_x += mid - mouse_x * res
   center_y += mid - mouse_y * res
   if systime - time0 < 0.3
      center_x -= mid - center_x
      center_y -= mid - center_y
      scale *= 2
   else
      center_x += (mid - center_x) * 3 / 4
      center_y += (mid - center_y) * 3 / 4
      scale /= 4
   .
   draw
.
draw
*
* Maze solving
*
@ https://www.rosettacode.org/wiki/Maze_solving@Task
*
size = 15
n = 2 * size + 1
f = 100 / (n - 0.5)
len m[] n * n
# 
background 000
proc show_maze . .
   clear
   for i = 1 to len m[]
      if m[i] = 0
         x = (i - 1) mod n
         y = (i - 1) div n
         color 999
         move x * f - f / 2 y * f - f / 2
         rect f * 1.5 f * 1.5
      .
   .
   sleep 0.01
.
offs[] = [ 1 n -1 (-n) ]
proc m_maze pos . .
   m[pos] = 0
   show_maze
   d[] = [ 1 2 3 4 ]
   for i = 4 downto 1
      d = random i
      dir = offs[d[d]]
      d[d] = d[i]
      if m[pos + dir] = 1 and m[pos + 2 * dir] = 1
         m[pos + dir] = 0
         m_maze pos + 2 * dir
      .
   .
.
endpos = n * n - 1
proc make_maze . .
   for i = 1 to len m[]
      m[i] = 1
   .
   for i = 1 to n
      m[i] = 2
      m[n * i] = 2
      m[n * i - n + 1] = 2
      m[n * n - n + i] = 2
   .
   h = 2 * random 15 - n + n * 2 * random 15
   m_maze h
   m[endpos] = 0
.
make_maze
show_maze
# 
proc mark pos col . .
   x = (pos - 1) mod n
   y = (pos - 1) div n
   color col
   move x * f + f / 4 y * f + f / 4
   circle f / 3.5
.
global found .
proc solve dir0 pos . .
   if found = 1
      return
   .
   mark pos 900
   sleep 0.05
   if pos = endpos
      found = 1
      return
   .
   of = random 4 - 1
   for h = 1 to 4
      dir = (h + of) mod1 4
      posn = pos + offs[dir]
      if dir <> dir0 and m[posn] = 0
         solve (dir + 1) mod 4 + 1 posn
         if found = 0
            mark posn 888
            sleep 0.08
         .
      .
   .
.
sleep 1
solve 0 n + 2
*
* MD5/Implementation
*
@ https://www.rosettacode.org/wiki/MD5/Implementation@Task
*
len md5k[] 64
proc md5init . .
   for i = 1 to 64
      md5k[i] = floor (0x100000000 * abs sin (i * 180 / pi))
   .
.
md5init
# 
proc md5 inp$ . s$ .
   subr addinp
      if inp4 = 1
         inp[] &= 0
      .
      inp[len inp[]] += b * inp4
      inp4 *= 0x100
      if inp4 = 0x100000000
         inp4 = 1
      .
   .
   s[] = [ 7 12 17 22 7 12 17 22 7 12 17 22 7 12 17 22 5 9 14 20 5 9 14 20 5 9 14 20 5 9 14 20 4 11 16 23 4 11 16 23 4 11 16 23 4 11 16 23 6 10 15 21 6 10 15 21 6 10 15 21 6 10 15 21 ]
   inp[] = [ ]
   inp4 = 1
   for i = 1 to len inp$
      b = strcode substr inp$ i 1
      addinp
   .
   b = 0x80
   addinp
   while len inp[] mod 16 <> 14 or inp4 <> 1
      b = 0
      addinp
   .
   h = len inp$ * 8
   for i = 1 to 4
      b = h mod 0x100
      addinp
      h = h div 0x100
   .
   inp[] &= 0
   # 
   a0 = 0x67452301
   b0 = 0xefcdab89
   c0 = 0x98badcfe
   d0 = 0x10325476
   for chunk = 1 step 16 to len inp[] - 15
      a = a0 ; b = b0 ; c = c0 ; d = d0
      for i = 1 to 64
         if i <= 16
            h1 = bitand b c
            h2 = bitand bitnot b d
            f = bitor h1 h2
            g = i - 1
         elif i <= 32
            h1 = bitand d b
            h2 = bitand bitnot d c
            f = bitor h1 h2
            g = (5 * i - 4) mod 16
         elif i <= 48
            h1 = bitxor b c
            f = bitxor h1 d
            g = (3 * i + 2) mod 16
         else
            h1 = bitor b bitnot d
            f = bitxor c h1
            g = (7 * i - 7) mod 16
         .
         f = (f + a + md5k[i] + inp[chunk + g])
         a = d
         d = c
         c = b
         h1 = bitshift f s[i]
         h2 = bitshift f (s[i] - 32)
         b = (b + h1 + h2)
      .
      a0 += a ; b0 += b ; c0 += c ; d0 += d
   .
   s$ = ""
   for a in [ a0 b0 c0 d0 ]
      for i = 1 to 4
         b = a mod 256
         a = a div 256
         for h in [ b div 16 b mod 16 ]
            h += 48
            if h > 57
               h += 39
            .
            s$ &= strchar h
         .
      .
   .
.
repeat
   s$ = input
   until error = 1
   md5 s$ h$
   print h$
.
input_data
a
abc
message digest
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
12345678901234567890123456789012345678901234567890123456789012345678901234567890
*
* Monte Carlo methods
*
@ https://www.rosettacode.org/wiki/Monte_Carlo_methods@Task
*
func mc n .
   for i = 1 to n
      x = randomf
      y = randomf
      if x * x + y * y < 1
         hit += 1
      .
   .
   return 4.0 * hit / n
.
numfmt 4 0
print mc 10000
print mc 100000
print mc 1000000
print mc 10000000
*
* Mouse position
*
@ https://www.rosettacode.org/wiki/Mouse_position@Task
*
on mouse_move
  clear
  text mouse_x & " " & mouse_y
.
*
* Munching squares
*
@ https://www.rosettacode.org/wiki/Munching_squares@Task
*
sc = 100 / 64
for x range0 64
   for y range0 64
      h = bitand bitxor x y 63
      c = h / 63
      color3 c c c
      move x * sc y * sc
      rect sc + 0.1 sc + 0.1
   .
.
*
* Musical scale
*
@ https://www.rosettacode.org/wiki/Musical_scale@Task
*
n[] = [ 262 294 330 349 392 440 494 523 ]
for t in n[]
  sound [ t 0.5 ]
  sleep 0.6
.
*
* N-queens problem
*
@ https://www.rosettacode.org/wiki/N-queens_problem@Task
*
subr show_sol
   print "Solution " & n_sol
   print ""
   for i = 1 to n
      write "  "
      for j = 1 to n
         if j = x[i]
            write "Q "
         else
            write ". "
         .
      .
      print ""
   .
   print ""
.
subr test
   ok = 1
   for i = 1 to y - 1
      if x[y] = x[i] or abs (x[i] - x[y]) = abs (y - i)
         ok = 0
      .
   .
.
n = 8
len x[] n
y = 1
x[1] = 1
while y >= 1
   test
   if ok = 1 and y + 1 <= n
      y += 1
      x[y] = 1
   else
      if ok = 1
         n_sol += 1
         if n_sol <= 1
            show_sol
         .
      .
      while y >= 1 and x[y] = n
         y -= 1
      .
      if y >= 1
         x[y] += 1
      .
   .
.
print n_sol & " solutions"
*
* Pentagram
*
@ https://www.rosettacode.org/wiki/Pentagram@Task
*
xp = 10
yp = 60
linewidth 2
move xp yp
while angle < 720
   x = xp + cos angle * 80
   y = yp + sin -angle * 80
   line x y
   f[] &= x
   f[] &= y
   xp = x
   yp = y
   angle += 144
.
color 900
polygon f[]
*
* Permutations
*
@ https://www.rosettacode.org/wiki/Permutations@Task
*
proc permlist k . list[] .
   if k = len list[]
      print list[]
      return
   .
   for i = k to len list[]
      swap list[i] list[k]
      permlist k + 1 list[]
      swap list[k] list[i]
   .
.
l[] = [ 1 2 3 ]
permlist 1 l[]
*
* Plot coordinate pairs
*
@ https://www.rosettacode.org/wiki/Plot_coordinate_pairs@Task
*
x[] = [ 0 1 2 3 4 5 6 7 8 9 ]
y[] = [ 2.7 2.8 31.4 38.1 58.0 76.2 100.5 130.0 149.3 180.0 ]
# 
clear
linewidth 0.5
move 10 97
line 10 5
line 95 5
textsize 3
n = len x[]
m = 0
for i = 1 to n
   if y[i] > m
      m = y[i]
   .
.
linewidth 0.1
sty = m div 9
for i range0 10
   move 2 4 + i * 10
   text i * sty
   move 10 5 + i * 10
   line 95 5 + i * 10
.
stx = x[n] div 9
for i range0 10
   move i * 9 + 10 1
   text i * stx
   move i * 9 + 10 5
   line i * 9 + 10 97
.
color 900
linewidth 0.5
for i = 1 to n
   x = x[i] * 9 / stx + 10
   y = y[i] / sty * 10 + 5
   line x y
.
*
* Polyspiral
*
@ https://www.rosettacode.org/wiki/Polyspiral@Task
*
color 944
linewidth 0.3
on animate
   clear
   incr = (incr + 0.05) mod 360
   x1 = 50
   y1 = 50
   length = 1
   angle = incr
   move x1 y1
   for i = 1 to 150
      x2 = x1 + cos angle * length
      y2 = y1 + sin angle * length
      line x2 y2
      x1 = x2
      y1 = y2
      length += 1
      angle = (angle + incr) mod 360
   .
.
*
* Prime decomposition
*
@ https://www.rosettacode.org/wiki/Prime_decomposition@Task
*
proc decompose num . primes[] .
   primes[] = [ ]
   t = 2
   while t * t <= num
      if num mod t = 0
         primes[] &= t
         num = num / t
      else
         t += 1
      .
   .
   primes[] &= num
.
decompose 9007199254740991 r[]
print r[]
*
* Pythagoras tree
*
@ https://www.rosettacode.org/wiki/Pythagoras_tree@Task
*
proc tree x1 y1 x2 y2 depth . .
   if depth < 8
      dx = x2 - x1
      dy = y1 - y2
      x3 = x2 + dy
      y3 = y2 + dx
      x4 = x1 + dy
      y4 = y1 + dx
      x5 = x4 + 0.5 * (dx + dy)
      y5 = y4 + 0.5 * (dx - dy)
      color3 0.3 0.2 + depth / 18 0.1
      polygon [ x1 y1 x2 y2 x3 y3 x4 y4 ]
      polygon [ x3 y3 x4 y4 x5 y5 ]
      tree x4 y4 x5 y5 depth + 1
      tree x5 y5 x3 y3 depth + 1
   .
.
tree 41 10 59 10 0
*
* Real constants and functions
*
@ https://www.rosettacode.org/wiki/Real_constants_and_functions@Task
*
x = 1.5
# calculate e
e = pow 3 (1 / logn 3)
numfmt 4 0
# e
print e
# square root
print sqrt x
# natural logarithm
print logn x
# exponential
print pow e x
# absolute value
print abs x
# floor
print floor x
# ceiling
if x > floor x
   print floor x + 1
else
   print x
end
# power
print pow 2 x
*
* Return multiple values
*
@ https://www.rosettacode.org/wiki/Return_multiple_values@Task
*
proc addSubtract a b . sum diff .
   sum = a + b
   diff = a - b
.
addSubtract 7 5 sum diff
print "Sum: " & sum
print "Difference: " & diff
*
* Reverse a string
*
@ https://www.rosettacode.org/wiki/Reverse_a_string@Task
*
func$ reverse s$ .
   a$[] = strchars s$
   for i = 1 to len a$[] div 2
      swap a$[i] a$[len a$[] - i + 1]
   .
   return strjoin a$[]
.
print reverse "hello"
*
* Roman numerals/Decode
*
@ https://www.rosettacode.org/wiki/Roman_numerals/Decode@Task
*
func rom2dec rom$ .
   symbols$[] = [ "M" "D" "C" "L" "X" "V" "I" ]
   values[] = [ 1000 500 100 50 10 5 1 ]
   val = 0
   for dig$ in strchars rom$
      for i = 1 to len symbols$[]
         if symbols$[i] = dig$
            v = values[i]
         .
      .
      val += v
      if oldv < v
         val -= 2 * oldv
      .
      oldv = v
   .
   return val
.
print rom2dec "MCMXC"
print rom2dec "MMVIII"
print rom2dec "MDCLXVI"
*
* Roman numerals/Encode
*
@ https://www.rosettacode.org/wiki/Roman_numerals/Encode@Task
*
func$ dec2rom dec .
   values[] = [ 1000 900 500 400 100 90 50 40 10 9 5 4 1 ]
   symbol$[] = [ "M" "CM" "D" "CD" "C" "XC" "L" "XL" "X" "IX" "V" "IV" "I" ]
   for i = 1 to len values[]
      while dec >= values[i]
         rom$ &= symbol$[i]
         dec -= values[i]
      .
   .
   return rom$
.
print dec2rom 1990
print dec2rom 2008
print dec2rom 1666
*
* Seven-sided dice from five-sided dice
*
@ https://www.rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice@Task
*
func dice5 .
   return random 5
.
func dice25 .
   return (dice5 - 1) * 5 + dice5
.
func dice7a .
   return dice25 mod1 7
.
func dice7b .
   repeat
      h = dice25
      until h <= 21
   .
   return h mod1 7
.
numfmt 3 0
n = 1000000
len dist[] 7
# 
proc checkdist . .
   for i to len dist[]
      h = dist[i] / n * 7
      if abs (h - 1) > 0.01
         bad = 1
      .
      dist[i] = 0
      print h
   .
   if bad = 1
      print "-> not uniform"
   else
      print "-> uniform"
   .
.
# 
for i to n
   dist[dice7a] += 1
.
checkdist
# 
print ""
for i to n
   dist[dice7b] += 1
.
checkdist
*
* Show ASCII table
*
@ https://www.rosettacode.org/wiki/Show_ASCII_table@Task
*
numfmt 0 3
for i range0 16
   for j = 32 + i step 16 to 127
      if j = 32
         x$ = "Spc"
      elif j = 127
         x$ = "Del"
      else
         x$ = strchar j & "  "
      .
      write j & ": " & x$
   .
   print ""
.
*
* Sierpinski arrowhead curve
*
@ https://www.rosettacode.org/wiki/Sierpinski_arrowhead_curve@Task
*
x = 5
y = 10
ang = 60
linewidth 0.5
# 
proc curv o l a . .
   if o = 0
      x += cos ang * l
      y += sin ang * l
      line x y
   else
      o -= 1
      l /= 2
      curv o l (-a)
      ang += a
      curv o l a
      ang += a
      curv o l (-a)
   .
.
move x y
curv 7 90 -60
*
* Sierpinski carpet
*
@ https://www.rosettacode.org/wiki/Sierpinski_carpet@Task
*
proc carp x y sz . .
   move x - sz / 2 y - sz / 2
   rect sz sz
   if sz > 0.5
      h = sz / 3
      carp x - sz y - sz h
      carp x - sz y h
      carp x - sz y + sz h
      carp x + sz y - sz h
      carp x + sz y h
      carp x + sz y + sz h
      carp x y - sz h
      carp x y + sz h
   .
.
background 000
clear
color 633
carp 50 50 100 / 3
*
* Sierpinski pentagon
*
@ https://www.rosettacode.org/wiki/Sierpinski_pentagon@Task
*
order = 5
# 
clear
linewidth 0.2
scale = 1 / (2 + cos 72 * 2)
# 
proc pentagon x y side depth . .
   if depth = 0
      move x y
      for angle = 0 step 72 to 288
         x += cos angle * side
         y += sin angle * side
         line x y
      .
   else
      side *= scale
      dist = side + side * cos 72 * 2
      for angle = 0 step 72 to 288
         x += cos angle * dist
         y += sin angle * dist
         pentagon x y side depth - 1
      .
   .
.
pentagon 25 15 50 order - 1
*
* Sierpinski triangle/Graphical
*
@ https://www.rosettacode.org/wiki/Sierpinski_triangle/Graphical@Task
*
proc triang lev x y size . .
   if lev = 0
      move x y
      circle 0.15
   else
      lev -= 1
      size /= 2
      triang lev x + size y size
      triang lev x + size / 2 y + size size
      triang lev x y size
   .
.
triang 8 5 5 90
*
* Sieve of Eratosthenes
*
@ https://www.rosettacode.org/wiki/Sieve_of_Eratosthenes@Task
*
len is_divisible[] 100
max = sqrt len is_divisible[]
for d = 2 to max
   if is_divisible[d] = 0
      for i = d * d step d to len is_divisible[]
         is_divisible[i] = 1
      .
   .
.
for i = 2 to len is_divisible[]
   if is_divisible[i] = 0
      print i
   .
.
*
* Simple turtle graphics
*
@ https://www.rosettacode.org/wiki/Simple_turtle_graphics@Task
*
subr home
   deg = 0
   x = 50
   y = 50
   down = 0
   move x y
.
home
# 
proc forward n . .
   x += cos deg * n
   y += sin deg * n
   if down = 1
      line x y
   else
      move x y
   .
   sleep 0.1
.
proc turn a . .
   deg -= a
.
# 
proc house . .
   turn 180
   forward 45
   turn 180
   down = 1
   # 
   forward 30
   turn 90
   forward 30
   turn 90
   forward 30
   turn 90
   forward 30
   # 
   turn 30
   forward 30
   turn 120
   forward 30
   home
.
house
# 
proc bar a[] . .
   turn 90
   forward 30
   turn -90
   down = 1
   for i to len a[]
      max = higher max a[i]
   .
   for i to len a[]
      h = a[i] / max * 50
      w = 45 / len a[]
      turn -90
      forward h
      turn 90
      forward w
      turn 90
      forward h
      turn -90
   .
   turn 180
   forward 45
   home
.
bar [ 50 33 200 130 50 ]
*
* Snake
*
@ https://www.rosettacode.org/wiki/Snake@Task
*
subr fruit
   rx = (random 20 - 1) * 5 + 2.5
   ry = (random 20 - 1) * 5 + 2.5
.
subr start
   fruit
   game = 1
   sx[] = [ 52.5 0 0 0 0 ]
   sy[] = [ 52.5 0 0 0 0 ]
   dir = random 4
   timer 0
.
background 242
move 30 70
clear
color 997
text "SNAKE"
textsize 5
move 6 40
text "Keys or mouse for controlling"
move 6 30
text "Space or click to to start"
# 
on key
   if game = 0 and keybkey = " "
      start
      return
   .
   if dir mod 2 = 1
      if keybkey = "ArrowRight"
         dir = 2
      elif keybkey = "ArrowLeft"
         dir = 4
      .
   else
      if keybkey = "ArrowUp"
         dir = 1
      elif keybkey = "ArrowDown"
         dir = 3
      .
   .
.
on mouse_down
   if game = 0
      start
      return
   .
   if dir mod 2 = 1
      if mouse_x < sx
         dir = 4
      else
         dir = 2
      .
   else
      if mouse_y < sy
         dir = 3
      else
         dir = 1
      .
   .
.
on timer
   clear
   color 997
   move 2 95
   text "Score: " & 10 * len sx[] - 50
   color 966
   move rx ry
   circle 1.5
   # 
   sx = sx[1] ; sy = sy[1]
   if dir = 1
      sy += 5
   elif dir = 2
      sx += 5
   elif dir = 3
      sy -= 5
   elif dir = 4
      sx -= 5
   .
   if sx < 0 or sx > 100 or sy < 0 or sy > 100
      game = 0
   .
   color 494
   for i = len sx[] downto 2
      if sx = sx[i] and sy = sy[i]
         game = 0
      .
      sx[i] = sx[i - 1]
      sy[i] = sy[i - 1]
      if sx[i] > 0
         move sx[i] sy[i]
         circle 2.5
      .
   .
   move sx sy
   circle 2.5
   color 000
   if dir = 2 or dir = 4
      move sx sy + 1
      circle 0.5
      move sx sy - 1
      circle 0.5
   else
      move sx + 1 sy
      circle 0.5
      move sx - 1 sy
      circle 0.5
   .
   if sx = rx and sy = ry
      len sx[] len sx[] + 3
      len sy[] len sy[] + 3
      fruit
   .
   sx[1] = sx ; sy[1] = sy
   if game = 1
      timer 0.15
   else
      color 997
      move 10 10
      text "Space or click new game"
   .
.
*
* Solve triangle solitare puzzle
*
@ https://www.rosettacode.org/wiki/Solve_triangle_solitare_puzzle@Task
*
brd$[] = strchars "
┏━━━━━━━━━┓
┃    ·    ┃
┃   ● ●   ┃
┃  ● ● ●  ┃
┃ ● ● ● ● ┃
┃● ● ● ● ●┃
┗━━━━━━━━━┛"
proc solve . solution$ .
   solution$ = ""
   for pos = 1 to len brd$[]
      if brd$[pos] = "●"
         npegs += 1
         for dir in [ -13 -11 2 13 11 -2 ]
            if brd$[pos + dir] = "●" and brd$[pos + 2 * dir] = "·"
               brd$[pos] = "·"
               brd$[pos + dir] = "·"
               brd$[pos + 2 * dir] = "●"
               solve solution$
               brd$[pos] = "●"
               brd$[pos + dir] = "●"
               brd$[pos + 2 * dir] = "·"
               if solution$ <> ""
                  solution$ = strjoin brd$[] & solution$
                  return
               .
            .
         .
      .
   .
   if npegs = 1
      solution$ = strjoin brd$[]
   .
.
solve solution$
print solution$
*
* Sorting algorithms/Heapsort
*
@ https://www.rosettacode.org/wiki/Sorting_algorithms/Heapsort@Task
*
proc sort . d[] .
   n = len d[]
   # make heap
   for i = 2 to n
      if d[i] > d[(i + 1) div 2]
         j = i
         repeat
            h = (j + 1) div 2
            until d[j] <= d[h]
            swap d[j] d[h]
            j = h
         .
      .
   .
   for i = n downto 2
      swap d[1] d[i]
      j = 1
      ind = 2
      while ind < i
         if ind + 1 < i and d[ind + 1] > d[ind]
            ind += 1
         .
         if d[j] < d[ind]
            swap d[j] d[ind]
         .
         j = ind
         ind = 2 * j
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Quicksort
*
@ https://www.rosettacode.org/wiki/Sorting_algorithms/Quicksort@Task
*
proc qsort left right . d[] .
   while left < right
      # partition 
      piv = d[left]
      mid = left
      for i = left + 1 to right
         if d[i] < piv
            mid += 1
            swap d[i] d[mid]
         .
      .
      swap d[left] d[mid]
      # 
      if mid < (right + left) / 2
         qsort left mid - 1 d[]
         left = mid + 1
      else
         qsort mid + 1 right d[]
         right = mid - 1
      .
   .
.
proc sort . d[] .
   qsort 1 len d[] d[]
.
d[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort d[]
print d[]
*
* Sorting algorithms/Radix sort
*
@ https://www.rosettacode.org/wiki/Sorting_algorithms/Radix_sort@Task
*
proc sort . d[] .
   # radix = 10
   radix = 256
   max = 0
   for di = 1 to len d[]
      if d[di] > max
         max = d[di]
      .
   .
   len buck[][] radix
   pos = 1
   while pos <= max
      for i = 1 to radix
         len buck[i][] 0
      .
      for di = 1 to len d[]
         h = d[di] div pos mod radix + 1
         buck[h][] &= d[di]
      .
      di = 1
      for i = 1 to radix
         for j = 1 to len buck[i][]
            d[di] = buck[i][j]
            di += 1
         .
      .
      pos *= radix
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Selection sort
*
@ https://www.rosettacode.org/wiki/Sorting_algorithms/Selection_sort@Task
*
proc sort . d[] .
   for i = 1 to len d[] - 1
      for j = i + 1 to len d[]
         if d[j] < d[i]
            swap d[j] d[i]
         .
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Square form factorization
*
@ https://www.rosettacode.org/wiki/Square_form_factorization@Task
*
multiplier[] = [ 1 3 5 7 11 3 * 5 3 * 7 3 * 11 5 * 7 5 * 11 7 * 11 3 * 5 * 7 3 * 5 * 11 3 * 7 * 11 5 * 7 * 11 3 * 5 * 7 * 11 ]
func gcd a b .
   while b <> 0
      a = a mod b
      swap a b
   .
   return a
.
func squfof N .
   s = floor (sqrt N + 0.5)
   if s * s = N
      return s
   .
   for multiplier in multiplier[]
      if N > 9007199254740992 / multiplier
         print "Number " & N & " is too big"
         break 1
      .
      D = multiplier * N
      P = floor sqrt D
      Po = P
      Pprev = P
      Qprev = 1
      Q = D - Po * Po
      L = 2 * floor sqrt (2 * s)
      B = 3 * L
      for i = 2 to B - 1
         b = (Po + P) div Q
         P = b * Q - P
         q = Q
         Q = Qprev + b * (Pprev - P)
         r = floor (sqrt Q + 0.5)
         if i mod 2 = 0 and r * r = Q
            break 1
         .
         Qprev = q
         Pprev = P
      .
      if i < B
         b = (Po - P) div r
         P = b * r + P
         Pprev = P
         Qprev = r
         Q = (D - Pprev * Pprev) / Qprev
         i = 0
         repeat
            b = (Po + P) div Q
            Pprev = P
            P = b * Q - P
            q = Q
            Q = Qprev + b * (Pprev - P)
            Qprev = q
            i += 1
            until P = Pprev
         .
         r = gcd N Qprev
         if r <> 1 and r <> N
            return r
         .
      .
   .
   return 0
.
data[] = [ 2501 12851 13289 75301 120787 967009 997417 7091569 13290059 42854447 223553581 2027651281 11111111111 100895598169 1002742628021 60012462237239 287129523414791 9007199254740931 ]
for example in data[]
   factor = squfof example
   if factor = 0
      print example & " was not factored."
   else
      quotient = example / factor
      print example & " has factors " & factor & " " & quotient
   .
.
*
* String comparison
*
@ https://www.rosettacode.org/wiki/String_comparison@Task
*
a$ = "hello"
if a$ = "hello"
   print "equal"
.
if a$ <> "hello2"
   print "not equal"
.
if strcmp a$ "hello" = 0
   print "equal"
.
if strcmp a$ "world" < 0
   print "lexically before"
.
if number "10" > number "2"
   print "numerically after"
.
*
* Sudoku
*
@ https://www.rosettacode.org/wiki/Sudoku@Task
*
len row[] 90
len col[] 90
len box[] 90
len grid[] 82
# 
proc init . .
   for pos = 1 to 81
      if pos mod 9 = 1
         s$ = input
         if s$ = ""
            s$ = input
         .
         len inp[] 0
         for i = 1 to len s$
            if substr s$ i 1 <> " "
               inp[] &= number substr s$ i 1
            .
         .
      .
      dig = number inp[(pos - 1) mod 9 + 1]
      if dig > 0
         grid[pos] = dig
         r = (pos - 1) div 9
         c = (pos - 1) mod 9
         b = r div 3 * 3 + c div 3
         row[r * 10 + dig] = 1
         col[c * 10 + dig] = 1
         box[b * 10 + dig] = 1
      .
   .
.
init
# 
proc display . .
   for i = 1 to 81
      write grid[i] & " "
      if i mod 3 = 0
         write " "
      .
      if i mod 9 = 0
         print ""
      .
      if i mod 27 = 0
         print ""
      .
   .
.
# 
proc solve pos . .
   while grid[pos] <> 0
      pos += 1
   .
   if pos > 81
      # solved
      display
      return
   .
   r = (pos - 1) div 9
   c = (pos - 1) mod 9
   b = r div 3 * 3 + c div 3
   r *= 10
   c *= 10
   b *= 10
   for d = 1 to 9
      if row[r + d] = 0 and col[c + d] = 0 and box[b + d] = 0
         grid[pos] = d
         row[r + d] = 1
         col[c + d] = 1
         box[b + d] = 1
         solve pos + 1
         row[r + d] = 0
         col[c + d] = 0
         box[b + d] = 0
      .
   .
   grid[pos] = 0
.
solve 1
# 
input_data
5 3 0  0 2 4  7 0 0
0 0 2  0 0 0  8 0 0
1 0 0  7 0 3  9 0 2

0 0 8  0 7 2  0 4 9
0 2 0  9 8 0  0 7 0
7 9 0  0 0 0  0 8 0

0 0 0  0 3 0  5 0 6
9 6 0  0 1 0  3 0 0
0 5 0  6 9 0  0 1 0
*
* Tic-tac-toe
*
@ https://www.rosettacode.org/wiki/Tic-tac-toe@Task
*
len f[] 9
state = 0
textsize 14
# 
proc init . .
   linewidth 2
   clear
   color 666
   move 34 96
   line 34 20
   move 62 96
   line 62 20
   move 10 72
   line 86 72
   move 10 44
   line 86 44
   linewidth 2.5
   for i = 1 to 9
      f[i] = 0
   .
   if state = 1
      timer 0.2
   .
.
proc draw ind . .
   c = (ind - 1) mod 3
   r = (ind - 1) div 3
   x = c * 28 + 20
   y = r * 28 + 30
   if f[ind] = 4
      color 900
      move x - 7 y - 7
      line x + 7 y + 7
      move x + 7 y - 7
      line x - 7 y + 7
   elif f[ind] = 1
      color 009
      move x y
      circle 10
      color -2
      circle 7.5
   .
.
proc sum3 a d . st .
   for i = 1 to 3
      s += f[a]
      a += d
   .
   if s = 3
      st = -1
   elif s = 12
      st = 1
   .
.
proc rate . res done .
   res = 0
   for i = 1 step 3 to 7
      sum3 i 1 res
   .
   for i = 1 to 3
      sum3 i 3 res
   .
   sum3 1 4 res
   sum3 3 2 res
   cnt = 1
   for i = 1 to 9
      if f[i] = 0
         cnt += 1
      .
   .
   res *= cnt
   done = 1
   if res = 0 and cnt > 1
      done = 0
   .
.
proc minmax player alpha beta . rval rmov .
   rate rval done
   if done = 1
      if player = 1
         rval = -rval
      .
   else
      rval = alpha
      start = random 9
      mov = start
      repeat
         if f[mov] = 0
            f[mov] = player
            minmax (5 - player) (-beta) (-rval) val h
            val = -val
            f[mov] = 0
            if val > rval
               rval = val
               rmov = mov
            .
         .
         mov = mov mod 9 + 1
         until mov = start or rval >= beta
      .
   .
.
proc show_result val . .
   color 555
   move 16 4
   if val < 0
      # this never happens
      text "You won"
   elif val > 0
      text "You lost"
   else
      text "Tie"
   .
   state += 2
.
proc computer . .
   minmax 4 -11 11 val mov
   f[mov] = 4
   draw mov
   rate val done
   state = 0
   if done = 1
      show_result val
   .
.
proc human . .
   mov = floor ((mouse_x - 6) / 28) + 3 * floor ((mouse_y - 16) / 28) + 1
   if f[mov] = 0
      f[mov] = 1
      draw mov
      state = 1
      timer 0.5
   .
.
on timer
   rate val done
   if done = 1
      show_result val
   else
      computer
   .
.
on mouse_down
   if state = 0
      if mouse_x > 6 and mouse_x < 90 and mouse_y > 16
         human
      .
   elif state >= 2
      state -= 2
      init
   .
.
init
*
* Time a function
*
@ https://www.rosettacode.org/wiki/Time_a_function@Task
*
func fua lim .
   # this is interpreted
   i = 1
   while i <= lim
      sum += i
      i += 1
   .
   return sum
.
start = systime
print fua 1e8
print systime - start
# 
fastfunc fub lim .
   # this is compiled to wasm
   i = 1
   while i <= lim
      sum += i
      i += 1
   .
   return sum
.
start = systime
print fub 1e8
print systime - start
*
* Towers of Hanoi
*
@ https://www.rosettacode.org/wiki/Towers_of_Hanoi@Task
*
proc hanoi n src dst aux . .
   if n >= 1
      hanoi n - 1 src aux dst
      print "Move " & src & " to " & dst
      hanoi n - 1 aux dst src
   .
.
hanoi 5 1 2 3
*
* Variables
*
@ https://www.rosettacode.org/wiki/Variables@Task
*
# it is statically typed
# 
# global number variable
n = 99
print n
# global array of numbers
a[] = [ 2.1 3.14 3 ]
# 
proc foo . .
   # i is local, because it is first used in the function  
   for i = 1 to len a[]
      print a[i]
   .
.
foo
# 
# string
domain$ = "easylang.dev"
print domain$
# 
# array of strings
fruits$[] = [ "apple" "banana" "orange" ]
print fruits$[]
*
* Vibrating rectangles
*
@ https://www.rosettacode.org/wiki/Vibrating_rectangles@Task
*
on timer
  sz -= 2
  if sz < 0
    sz = 49
    color random 1000 - 1
  .
  move 50 - sz 50 - sz
  line 50 + sz 50 - sz
  line 50 + sz 50 + sz
  line 50 - sz 50 + sz
  line 50 - sz 50 - sz
  timer 0.2
.
timer 0.2
*
* Vigenère cipher
*
@ https://www.rosettacode.org/wiki/Vigenère_cipher@Task
*
func$ encr txt$ pw$ d .
   txt$[] = strchars txt$
   for c$ in strchars pw$
      pw[] &= strcode c$ - 65
   .
   for c$ in txt$[]
      c = strcode c$
      if c >= 97
         c -= 32
      .
      if c >= 65 and c <= 97
         pwi = (pwi + 1) mod1 len pw[]
         c = (c - 65 + d * pw[pwi]) mod 26 + 65
         r$ &= strchar c
      .
   .
   return r$
.
s$ = "Beware the Jabberwock, my son! The jaws that bite, the claws that catch!"
pw$ = "VIGENERECIPHER"
r$ = encr s$ pw$ 1
print r$
print encr r$ pw$ -1
`
function hook() {
	var dom = window.location.host
	tut.insertAdjacentHTML("beforeend", `
<p><hr><p>
The examples were created with <a href=..>${dom}<a>
<p><small>christof.kaser@gmail.com</small>
`)
}
</script>
