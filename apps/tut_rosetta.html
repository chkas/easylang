<!doctype html>
<meta charset=utf-8><title>Easylang - Rosetta Code</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="icon" href="../icon.png" type="image/x-png">

<div id=tut><b>Loading ...</b></div>
<script src=easy_code2.js></script>
<script src=easy_tut2.js></script>

<script>

txt_split = "\n*\n"

txt_tutor=`* Rosetta Code with Easylang
*
* 100 doors
*
@ https://rosettacode.org/wiki/100_doors@Task
*
len d[] 100
for p = 1 to 100
   i = p
   while i <= 100
      d[i] = 1 - d[i]
      i += p
   .
.
for i = 1 to 100
   if d[i] = 1
      print i
   .
.
*
* 100 prisoners
*
@ https://rosettacode.org/wiki/100_prisoners@Task
*
for i = 1 to 100
   drawer[] &= i
   sampler[] &= i
.
subr shuffle_drawer
   for i = len drawer[] downto 2
      r = random i
      swap drawer[r] drawer[i]
   .
.
subr play_random
   call shuffle_drawer
   for prisoner = 1 to 100
      found = 0
      for i = 1 to 50
         r = random (100 - i)
         card = drawer[sampler[r]]
         swap sampler[r] sampler[100 - i - 1]
         if card = prisoner
            found = 1
            break 1
         .
      .
      if found = 0
         break 1
      .
   .
.
subr play_optimal
   shuffle_drawer
   for prisoner = 1 to 100
      reveal = prisoner
      found = 0
      for i = 1 to 50
         card = drawer[reveal]
         if card = prisoner
            found = 1
            break 1
         .
         reveal = card
      .
      if found = 0
         break 1
      .
   .
.
n = 10000
win = 0
for _ = 1 to n
   play_random
   win += found
.
print "random: " & 100.0 * win / n & "%"
# 
win = 0
for _ = 1 to n
   play_optimal
   win += found
.
print "optimal: " & 100.0 * win / n & "%"
*
* 10001th prime
*
@ https://rosettacode.org/wiki/10001th_prime@Task
*
fastfunc isPrime num .
   if num mod 2 = 0 and num > 2
      return 0
   .
   i = 3
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
curPrime = 1
for i = 1 to 10001
   repeat
      curPrime += 1
      until isPrime curPrime = 1
   .
.
print curPrime
*
* 15 puzzle game
*
@ https://rosettacode.org/wiki/15_puzzle_game@Task
*
# 15 Puzzle
# 
sys topleft
background 432
textsize 13
len f[] 16
proc draw . .
   clear
   for i = 1 to 16
      h = f[i]
      if h < 16
         x = (i - 1) mod 4 * 24 + 3
         y = (i - 1) div 4 * 24 + 3
         color 210
         move x y
         rect 22 22
         move x + 4 y + 6
         if h < 10
            move x + 6 y + 6
         .
         color 885
         text h
      .
   .
.
global done .
proc init . .
   done = 0
   for i = 1 to 16
      f[i] = i
   .
   # shuffle
   for i = 15 downto 2
      r = random i
      swap f[r] f[i]
   .
   # make it solvable
   inv = 0
   for i = 1 to 15
      for j = 1 to i - 1
         if f[j] > f[i]
            inv += 1
         .
      .
   .
   if inv mod 2 <> 0
      swap f[1] f[2]
   .
   textsize 12
   draw
.
proc move_tile . .
   c = mouse_x div 25
   r = mouse_y div 25
   i = r * 4 + c + 1
   if c > 0 and f[i - 1] = 16
      swap f[i] f[i - 1]
   elif r > 0 and f[i - 4] = 16
      swap f[i] f[i - 4]
   elif r < 3 and f[i + 4] = 16
      swap f[i] f[i + 4]
   elif c < 3 and f[i + 1] = 16
      swap f[i] f[i + 1]
   .
   draw
   done = 1
   for i = 1 to 15
      if f[i] > f[i + 1]
         done = 0
      .
   .
   if done = 1
      clear
      move 10 30
      text "Well done!"
   .
.
on mouse_down
   if done = 1
      init
   else
      move_tile
   .
.
init
*
* 21 game
*
@ https://rosettacode.org/wiki/21_game@Task
*
print "Who reaches 21, wins"
print "Do you want to begin (y/n)"
who = 1
if input = "n"
  who = 2
.
who$[] = [ "Human" "Computer" ]
repeat
  if who = 1
    repeat
      print ""
      print "Choose 1,2 or 3 (q for quit)"
      a$ = input
      n = number a$
      until a$ = "q" or (n >= 1 and n <= 3)
    .
  else
    sleep 1
    if sum mod 4 = 1
      n = random 3
    else
      n = 4 - (sum + 3) mod 4
    .
  .
  sum += n
  print who$[who] & ": " & n & " --> " & sum
  until sum >= 21 or a$ = "q"
  who = who mod 2 + 1
.
if a$ <> "q"
  print ""
  if who = 0
    print "Congratulation, you won"
  else
    print "Sorry, you lost"
  .
.
*
* 99 bottles of beer
*
@ https://rosettacode.org/wiki/99_bottles_of_beer@Task
*
func$ bottle num .
   if num = 1
      return "bottle"
   .
   return "bottles"
.
# 
i = 99
repeat
   print i & " " & bottle i & " of beer on the wall"
   print i & " " & bottle i & " of beer"
   print "Take one down, pass it around"
   i -= 1
   until i = 0
   print i & " " & bottle i & " of beer on the wall"
   print ""
.
print "No more bottles of beer on the wall"
*
* A+B
*
@ https://rosettacode.org/wiki/A+B@Task
*
a$ = input
i = 1
while i < len a$ and substr a$ i 1 <> " "
  i += 1
.
a = number substr a$ 1 i
b = number substr a$ i -1
print a + b
*
* Ackermann function
*
@ https://rosettacode.org/wiki/Ackermann_function@Task
*
func ackerm m n .
   if m = 0
      return n + 1
   elif n = 0
      return ackerm (m - 1) 1
   else
      return ackerm (m - 1) ackerm m (n - 1)
   .
.
print ackerm 3 6
*
* Additive primes
*
@ https://rosettacode.org/wiki/Additive_primes@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func digsum n .
   while n > 0
      sum += n mod 10
      n = n div 10
   .
   return sum
.
for i = 2 to 500
   if prime i = 1
      s = digsum i
      if prime s = 1
         write i & " "
      .
   .
.
print ""
*
* Amicable pairs
*
@ https://rosettacode.org/wiki/Amicable_pairs@Task
*
func sumdivs n .
   sum = 1
   for d = 2 to sqrt n
      if n mod d = 0
         sum += d + n div d
      .
   .
   return sum
.
for n = 1 to 20000
   m = sumdivs n
   if m > n
      if sumdivs m = n
         print n & " " & m
      .
   .
.
*
* Animate a pendulum
*
@ https://rosettacode.org/wiki/Animate_a_pendulum@Task
*
ang = 45
on animate
  clear
  move 50 50
  circle 1
  x = 50 + 40 * sin ang
  y = 50 + 40 * cos ang
  line x y
  circle 6
  vel += sin ang / 5
  ang += vel
.
*
* Archimedean spiral
*
@ https://rosettacode.org/wiki/Archimedean_spiral@Task
*
linewidth 0.2
x = 50
y = 50
move x y
while r < 50
   line r * cos t + x r * sin t + y
   r += 0.1
   t += 6
.
*
* Arithmetic evaluation
*
@ https://rosettacode.org/wiki/Arithmetic_evaluation@Task
*
subr nch
   if inp_ind > len inp$[]
      ch$ = strchar 0
   else
      ch$ = inp$[inp_ind]
      inp_ind += 1
   .
   ch = strcode ch$
.
# 
subr ntok
   while ch$ = " "
      nch
   .
   if ch >= 48 and ch <= 58
      tok$ = "n"
      s$ = ""
      while ch >= 48 and ch <= 58 or ch$ = "."
         s$ &= ch$
         nch
      .
      tokv = number s$
   elif ch = 0
      tok$ = "end of text"
   else
      tok$ = ch$
      nch
   .
.
subr init0
   astop$[] = [ ]
   astleft[] = [ ]
   astright[] = [ ]
   err = 0
.
proc init s$ . .
   inp$[] = strchars s$
   inp_ind = 1
   nch
   ntok
   init0
.
proc ast_print nd . .
   write "AST:"
   for i to len astop$[]
      write " ( "
      write astop$[i] & " "
      write astleft[i] & " "
      write astright[i]
      write " )"
   .
   print " Start: " & nd
.
func node .
   astop$[] &= ""
   astleft[] &= 0
   astright[] &= 0
   return len astop$[]
.
# 
funcdecl parse_expr .
# 
func parse_factor .
   if tok$ = "n"
      nd = node
      astop$[nd] = "n"
      astleft[nd] = tokv
      ntok
   elif tok$ = "("
      ntok
      nd = parse_expr
      if tok$ <> ")"
         err = 1
         print "error: ) expected, got " & tok$
      .
      ntok
   else
      err = 1
      print "error: factor expected, got " & tok$
   .
   return nd
.
func parse_term .
   ndx = parse_factor
   while tok$ = "*" or tok$ = "/"
      nd = node
      astleft[nd] = ndx
      astop$[nd] = tok$
      ntok
      astright[nd] = parse_factor
      ndx = nd
   .
   return ndx
.
func parse_expr .
   ndx = parse_term
   while tok$ = "+" or tok$ = "-"
      nd = node
      astleft[nd] = ndx
      astop$[nd] = tok$
      ntok
      astright[nd] = parse_term
      ndx = nd
   .
   return ndx
.
func parse s$ .
   init s$
   return parse_expr
.
func eval nd .
   if astop$[nd] = "n"
      return astleft[nd]
   .
   le = eval astleft[nd]
   ri = eval astright[nd]
   a$ = astop$[nd]
   if a$ = "+"
      return le + ri
   elif a$ = "-"
      return le - ri
   elif a$ = "*"
      return le * ri
   elif a$ = "/"
      return le / ri
   .
.
repeat
   inp$ = input
   until inp$ = ""
   print "Inp: " & inp$
   nd = parse inp$
   ast_print nd
   if err = 0
      print "Eval: " & eval nd
   .
   print ""
.
input_data
4 * 
4.2 * ((5.3+8)*3 + 4)
2.5 * 2 + 2 * 3.14
*
* Arithmetic numbers
*
@ https://rosettacode.org/wiki/Arithmetic_numbers@Task
*
print "The first 100 arithmetic numbers are:"
numfmt 0 3
n = 1
while aricnt <= 1e5
   divi = 1 ; divcnt = 0 ; sum = 0
   repeat
      quot = n div divi
      until quot < divi
      if quot = divi and n mod divi = 0
         sum += quot
         divcnt += 1
         break 1
      .
      if n mod divi = 0
         sum += divi + quot
         divcnt += 2
      .
      divi += 1
   .
   if sum mod divcnt = 0
      aricnt += 1
      if aricnt <= 100
         write n & " "
         if aricnt mod 10 = 0
            print ""
         .
      .
      if divcnt > 2
         compcnt += 1
      .
      if aricnt = 1e3 or aricnt = 1e4 or aricnt = 1e5
         print ""
         print aricnt & "th arithmetic number: " & n
         print "Composite arithmetic numbers: " & compcnt
      .
   .
   n += 1
.
*
* Arithmetic/Integer
*
@ https://rosettacode.org/wiki/Arithmetic/Integer@Task
*
a = number input
b = number input
print a + b
print a - b
print a * b
print a div b
print a mod b
print pow a b
*
* Array concatenation
*
@ https://rosettacode.org/wiki/Array_concatenation@Task
*
a[] = [ 1 2 3 ]
b[] = [ 4 5 6 ]
c[] = a[]
for h in b[]
  c[] &= h
.
print c[]
*
* Array length
*
@ https://rosettacode.org/wiki/Array_length@Task
*
fruit$[] = [ "apples" "oranges" ]
print len fruit$[]
*
* Arrays
*
@ https://rosettacode.org/wiki/Arrays@Task
*
len f[] 4
for i = 1 to len f[]
  f[i] = i
.
f[] &= 5
for i = 1 to len f[]
  print f[i]
.
*
* Averages/Arithmetic mean
*
@ https://rosettacode.org/wiki/Averages/Arithmetic_mean@Task
*
proc mean . f[] r .
   for i = 1 to len f[]
      s += f[i]
   .
   r = s / len f[]
.
f[] = [ 1 2 3 4 5 6 7 8 ]
mean f[] r
print r
*
* Averages/Median
*
@ https://rosettacode.org/wiki/Averages/Median@Task
*
proc quickselect k . list[] res .
   # 
   subr partition
      mid = left
      for i = left + 1 to right
         if list[i] < list[left]
            mid += 1
            swap list[i] list[mid]
         .
      .
      swap list[left] list[mid]
   .
   left = 1
   right = len list[]
   while left < right
      partition
      if mid < k
         left = mid + 1
      elif mid > k
         right = mid - 1
      else
         left = right
      .
   .
   res = list[k]
.
proc median . list[] res .
   h = len list[] div 2 + 1
   quickselect h list[] res
   if len list[] mod 2 = 0
      quickselect h - 1 list[] h
      res = (res + h) / 2
   .
.
test[] = [ 4.1 5.6 7.2 1.7 9.3 4.4 3.2 ]
median test[] med
print med
test[] = [ 4.1 7.2 1.7 9.3 4.4 3.2 ]
median test[] med
print med
*
* Babbage problem
*
@ https://rosettacode.org/wiki/Babbage_problem@Task
*
while n * n mod 1000000 <> 269696
  n += 1
.
print n
*
* Barnsley fern
*
@ https://rosettacode.org/wiki/Barnsley_fern@Task
*
color 060
for i = 1 to 200000
  r = randomf
  if r < 0.01
    nx = 0
    ny = 0.16 * y
  elif r < 0.08
    nx = 0.2 * x - 0.26 * y
    ny = 0.23 * x + 0.22 * y + 1.6
  elif r < 0.15
    nx = -0.15 * x + 0.28 * y
    ny = 0.26 * x + 0.24 * y + 0.44
  else
    nx = 0.85 * x + 0.04 * y
    ny = -0.04 * x + 0.85 * y + 1.6
  .
  x = nx
  y = ny
  move 50 + x * 15 y * 10
  rect 0.3 0.3
.
*
* Binary digits
*
@ https://rosettacode.org/wiki/Binary_digits@Task
*
func$ bin num .
   b$ = ""
   if num = 0
      b$ = "0"
   .
   while num > 0
      b$ = num mod 2 & b$
      num = num div 2
   .
   return b$
.
print bin 2
print bin 50
print bin 9000
*
* Binary search
*
@ https://rosettacode.org/wiki/Binary_search@Task
*
proc binSearch val . a[] res .
   low = 1
   high = len a[]
   res = 0
   while low <= high and res = 0
      mid = (low + high) div 2
      if a[mid] > val
         high = mid - 1
      elif a[mid] < val
         low = mid + 1
      else
         res = mid
      .
   .
.
a[] = [ 2 4 6 8 9 ]
binSearch 8 a[] r
print r
*
* Bitwise operations
*
@ https://rosettacode.org/wiki/Bitwise_operations@Task
*
# numbers are doubles, bit operations use 32 bits and are unsigned
x = 11
y = 2
print bitnot x
print bitand x y
print bitor x y
print bitxor x y
print bitshift x y
print bitshift x -y
*
* Boolean values
*
@ https://rosettacode.org/wiki/Boolean_values@Task
*
boolNumber = 1
if boolNumber = 1
   print "True"
else
   print "False"
.
*
* Brazilian numbers
*
@ https://rosettacode.org/wiki/Brazilian_numbers@Task
*
func sameDigits n b .
   f = n mod b
   repeat
      n = n div b
      until n = 0
      if n mod b <> f
         return 0
      .
   .
   return 1
.
func isBrazilian7 n .
   # n >= 7
   if n mod 2 = 0
      return 1
   .
   for b = 2 to n - 2
      if sameDigits n b = 1
         return 1
      .
   .
   return 0
.
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
for kind$ in [ "" "odd" "prime" ]
   print "First 20 " & kind$ & " Brazilian numbers:"
   n = 7
   cnt = 1
   while cnt <= 20
      if isBrazilian7 n = 1
         write n & " "
         cnt += 1
      .
      if kind$ = ""
         n += 1
      elif kind$ = "odd"
         n += 2
      else
         repeat
            n += 2
            until prime n = 1
         .
      .
   .
   print ""
.
*
* Brownian tree
*
@ https://rosettacode.org/wiki/Brownian_tree@Task
*
color3 0 1 1
len f[] 200 * 200
move 50 50
rect 0.5 0.5
f[100 * 200 + 100] = 1
n = 9000
while i < n
  repeat
    x = random 200 - 1
    y = random 200 - 1
    until f[y * 200 + x + 1] <> 1
  .
  while 1 = 1
    xo = x
    yo = y
    x += random 3 - 2
    y += random 3 - 2
    if x < 0 or y < 0 or x >= 200 or y >= 200
      break 1
    .
    if f[y * 200 + x + 1] = 1
      move xo / 2 yo / 2
      rect 0.5 0.5
      f[yo * 200 + xo + 1] = 1
      i += 1
      if i mod 16 = 0
        color3 0.2 + i / n 1 1
        sleep 0
      .
      break 1
    .
  .
.
*
* Bulls and cows
*
@ https://rosettacode.org/wiki/Bulls_and_cows@Task
*
dig[] = [ 1 2 3 4 5 6 7 8 9 ]
for i = 1 to 4
  h = i - 1 + random (10 - i)
  swap dig[i] dig[h]
.
# print dig[]
len g[] 4
attempts = 0
repeat
  repeat
    ok = 0
    s$[] = strchars input
    if len s$[] = 4
      ok = 1
      for i = 1 to 4
        g[i] = number s$[i]
        if g[i] = 0
          ok = 0
        .
      .
    .
    until ok = 1
  .
  print g[]
  attempts += 1
  bulls = 0
  cows = 0
  for i = 1 to 4
    if g[i] = dig[i]
      bulls += 1
    else
      for j = 1 to 4
        if dig[j] = g[i]
          cows += 1
        .
      .
    .
  .
  print "bulls:" & bulls & " cows:" & cows
  until bulls = 4
.
print "Well done! " & attempts & " attempts needed."
*
* Calculating the value of e
*
@ https://rosettacode.org/wiki/Calculating_the_value_of_e@Task
*
numfmt 0 5
fact = 1
n = 2
e = 2
while abs (e - e0) > 0.0001
  e0 = e
  fact = fact * n
  n += 1
  e += 1 / fact
.
print e
*
* Call a function
*
@ https://rosettacode.org/wiki/Call_a_function@Task
*
func sqr n .
   return n * n
.
sqr 3
# 
proc divmod a b . q r .
   q = a div b
   r = a mod b
.
divmod 11 3 q r
print q & " " & r
# 
subr sqr2
   a = a * a
.
a = 5
call sqr2
print a
*
* Case-sensitivity of identifiers
*
@ https://rosettacode.org/wiki/Case-sensitivity_of_identifiers@Task
*
dog$ = "Benjamin"
Dog$ = "Samba"
DOG$ = "Bernie"
# 
print "The three dogs are named " & dog$ & ", " & Dog$ & ", and " & DOG$ & "."
*
* Catalan numbers
*
@ https://rosettacode.org/wiki/Catalan_numbers@Task
*
func catalan n .
   if n = 0
      return 1
   .
   return 2 * (2 * n - 1) * catalan (n - 1) div (1 + n)
.
for i = 0 to 14
   print catalan i
.
*
* Catalan numbers/Pascal's triangle
*
@ https://rosettacode.org/wiki/Catalan_numbers/Pascal's_triangle@Task
*
print 1
for n = 2 to 15
   num = 1
   den = 1
   for k = 2 to n
      num *= n + k
      den *= k
      cat = num / den
   .
   print cat
.
*
* Chaos game
*
@ https://rosettacode.org/wiki/Chaos_game@Task
*
color 900
x[] = [ 0 100 50 ]
y[] = [ 7 7 93 ]
x = randomf * 100
y = randomf * 100
for i = 1 to 100000
  move x y
  rect 0.3 0.3
  h = random 3
  x = (x + x[h]) / 2
  y = (y + y[h]) / 2
.
*
* Character codes
*
@ https://rosettacode.org/wiki/Character_codes@Task
*
print strcode "a"
print strchar 97
*
* Chebyshev coefficients
*
@ https://rosettacode.org/wiki/Chebyshev_coefficients@Task
*
numfmt 12 0
a = 0
b = 1
n = 10
len coef[] n
len cheby[] n
for i = 0 to n - 1
   coef[i + 1] = cos (180 / pi * (cos (180 / n * (i + 1 / 2)) * (b - a) / 2 + (b + a) / 2))
.
for i = 0 to n - 1
   w = 0
   for j = 0 to n - 1
      w += coef[j + 1] * cos (180 / n * i * (j + 1 / 2))
   .
   cheby[i + 1] = w * 2 / n
   print cheby[i + 1]
.
*
* Chinese remainder theorem
*
@ https://rosettacode.org/wiki/Chinese_remainder_theorem@Task
*
func mul_inv a b .
   b0 = b
   x1 = 1
   if b <> 1
      while a > 1
         q = a div b
         t = b
         b = a mod b
         a = t
         t = x0
         x0 = x1 - q * x0
         x1 = t
      .
      if x1 < 0
         x1 += b0
      .
   .
   return x1
.
proc remainder . n[] a[] r .
   prod = 1
   sum = 0
   for i = 1 to len n[]
      prod *= n[i]
   .
   for i = 1 to len n[]
      p = prod / n[i]
      sum += a[i] * (mul_inv p n[i]) * p
      r = sum mod prod
   .
.
n[] = [ 3 5 7 ]
a[] = [ 2 3 2 ]
remainder n[] a[] h
print h
*
* Chowla numbers
*
@ https://rosettacode.org/wiki/Chowla_numbers@Task
*
fastfunc chowla n .
   sum = 0
   i = 2
   while i * i <= n
      if n mod i = 0
         j = n div i
         if i = j
            sum += i
         else
            sum += i + j
         .
      .
      i += 1
   .
   return sum
.
proc sieve . c[] .
   i = 3
   while i * 3 <= len c[]
      if c[i] = 0
         if chowla i = 0
            j = 3 * i
            while j <= len c[]
               c[j] = 1
               j += 2 * i
            .
         .
      .
      i += 2
   .
.
proc commatize n . s$ .
   s$[] = strchars n
   s$ = ""
   l = len s$[]
   for i = 1 to len s$[]
      if i > 1 and l mod 3 = 0
         s$ &= ","
      .
      l -= 1
      s$ &= s$[i]
   .
.
print "chowla number from 1 to 37"
for i = 1 to 37
   print "  " & i & ": " & chowla i
.
proc main . .
   print ""
   len c[] 10000000
   count = 1
   sieve c[]
   power = 100
   i = 3
   while i <= len c[]
      if c[i] = 0
         count += 1
      .
      if i = power - 1
         commatize power p$
         commatize count c$
         print "There are " & c$ & " primes up to " & p$
         power *= 10
      .
      i += 2
   .
   print ""
   limit = 35000000
   count = 0
   i = 2
   k = 2
   kk = 3
   repeat
      p = k * kk
      until p > limit
      if chowla p = p - 1
         commatize p s$
         print s$ & " is a perfect number"
         count += 1
      .
      k = kk + 1
      kk += k
      i += 1
   .
   commatize limit s$
   print "There are " & count & " perfect mumbers up to " & s$
.
call main
*
* Circular primes
*
@ https://rosettacode.org/wiki/Circular_primes@Task
*
fastfunc prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func cycle n .
   m = n
   p = 1
   while m >= 10
      p *= 10
      m = m div 10
   .
   return m + n mod p * 10
.
func circprime p .
   if prime p = 0
      return 0
   .
   p2 = cycle p
   while p2 <> p
      if p2 < p or prime p2 = 0
         return 0
      .
      p2 = cycle p2
   .
   return 1
.
p = 2
while count < 19
   if circprime p = 1
      print p
      count += 1
   .
   p += 1
.
*
* Code Golf: Code Golf
*
@ https://rosettacode.org/wiki/Code_Golf:_Code_Golf@Task
*
# with string literal (16 characters)
write"Code Golf"
# without quoted literals (53 characters)
# for i in [44 0 11 10 79 40 0 3 9]write strchar 111-i.
for i in [44 0 11 10 79 40 0 3 9]write strchar 111-i.
*
* Collections
*
@ https://rosettacode.org/wiki/Collections@Task
*
array[] &= 1
array[] &= 2
array[] &= 3
arrayArray[][] &= [ 1 2 ]
arrayArray[][] &= [ 3 4 ]
arrayArray[][] &= [ 5 6 ]
print array[]
print arrayArray[][]
*
* Colour bars/Display
*
@ https://rosettacode.org/wiki/Colour_bars/Display@Task
*
col[] = [ 000 900 090 009 909 099 990 999 ]
w = 100 / len col[]
for i = 1 to len col[]
   color col[i]
   move w * (i - 1) 0
   rect w 100
.
*
* Combinations
*
@ https://rosettacode.org/wiki/Combinations@Task
*
n = 5
m = 3
len result[] m
# 
proc combinations pos val . .
   if pos <= m
      for i = val to n - m
         result[pos] = pos + i
         combinations pos + 1 i
      .
   else
      print result[]
   .
.
combinations 1 0
*
* Combinations with repetitions
*
@ https://rosettacode.org/wiki/Combinations_with_repetitions@Task
*
items$[] = [ "iced" "jam" "plain" ]
n = len items$[]
k = 2
len result[] k
n_results = 0
# 
proc output . .
   n_results += 1
   if len items$[] > 0
      s$ = ""
      for i = 1 to k
         s$ &= items$[result[i]] & " "
      .
      print s$
   .
.
proc combine pos val . .
   if pos > k
      output
   else
      for i = val to n
         result[pos] = i
         combine pos + 1 i
      .
   .
.
combine 1 1
# 
n = 10
k = 3
len result[] k
items$[] = [ ]
n_results = 0
combine 1 1
print ""
print n_results & " results with 10 donuts"
*
* Comments
*
@ https://rosettacode.org/wiki/Comments@Task
*
# This is a comment
*
* Conditional structures
*
@ https://rosettacode.org/wiki/Conditional_structures@Task
*
i = random 10
if i mod 2 = 0
  print i & " is divisible by 2"
elif i mod 3 = 0
  print i & " is divisible by 3"
else
  print i & " is not divisible by 2 or 3"
.
*
* Convert seconds to compound duration
*
@ https://rosettacode.org/wiki/Convert_seconds_to_compound_duration@Task
*
func$ split sec .
   divs[] = [ 60 60 24 7 ]
   n$[] = [ "sec" "min" "hr" "d" "wk" ]
   len r[] 5
   for i = 1 to 4
      r[i] = sec mod divs[i]
      sec = sec div divs[i]
   .
   r[5] = sec
   for i = 5 downto 1
      if r[i] <> 0
         if s$ <> ""
            s$ &= ", "
         .
         s$ &= r[i] & " " & n$[i]
      .
   .
   return s$
.
print split 7259
print split 86400
print split 6000000
*
* Conway's Game of Life
*
@ https://rosettacode.org/wiki/Conway's_Game_of_Life@Task
*
n = 70
time = 0.1
# 
nx = n + 1
subr init
   for r = 1 to n
      for c = 1 to n
         i = r * nx + c
         if randomf < 0.3
            f[i] = 1
         .
      .
   .
.
f = 100 / n
subr show
   clear
   for r = 1 to n
      for c = 1 to n
         if f[r * nx + c] = 1
            move c * f - f r * f - f
            rect f * 0.9 f * 0.9
         .
      .
   .
.
subr update
   swap f[] p[]
   for r = 1 to n
      sm = 0
      i = r * nx + 1
      sr = p[i - nx] + p[i] + p[i + nx]
      for c = 1 to n
         sl = sm
         sm = sr
         in = i + 1
         sr = p[in - nx] + p[in] + p[in + nx]
         s = sl + sm + sr
         if s = 3 or s = 4 and p[i] = 1
            f[i] = 1
         else
            f[i] = 0
         .
         i = in
      .
   .
.
on timer
   update
   show
   timer time
.
on mouse_down
   c = mouse_x div f + 1
   r = mouse_y div f + 1
   i = r * nx + c
   f[i] = 1 - f[i]
   show
   timer 3
.
len f[] nx * nx + nx
len p[] nx * nx + nx
init
timer 0
*
* Copy a string
*
@ https://rosettacode.org/wiki/Copy_a_string@Task
*
a$ = "hello"
b$ = a$
print b$
*
* Count in factors
*
@ https://rosettacode.org/wiki/Count_in_factors@Task
*
proc decompose num . primes[] .
   primes[] = [ ]
   t = 2
   while t * t <= num
      if num mod t = 0
         primes[] &= t
         num = num / t
      else
         t += 1
      .
   .
   primes[] &= num
.
for i = 1 to 30
   write i & ": "
   decompose i primes[]
   for j = 1 to len primes[]
      if j > 1
         write " x "
      .
      write primes[j]
   .
   print ""
   primes[] = [ ]
.
*
* Count in octal
*
@ https://rosettacode.org/wiki/Count_in_octal@Task
*
func$ oct v .
   while v > 0
      r$ = v mod 8 & r$
      v = v div 8
   .
   if r$ = ""
      r$ = 0
   .
   return r$
.
for i = 0 to 10
   print oct i
.
print "."
print "."
max = pow 2 53
i = max - 10
repeat
   print oct i
   until i = max
   i += 1
.
*
* Count the coins
*
@ https://rosettacode.org/wiki/Count_the_coins@Task
*
len cache[] 100000 * 7 + 6
val[] = [ 1 5 10 25 50 100 ]
func count sum kind .
   if sum = 0
      return 1
   .
   if sum < 0 or kind = 0
      return 0
   .
   chind = sum * 7 + kind
   if cache[chind] > 0
      return cache[chind]
   .
   r2 = count (sum - val[kind]) kind
   r1 = count sum (kind - 1)
   r = r1 + r2
   cache[chind] = r
   return r
.
print count 100 4
print count 10000 6
print count 100000 6
# this is not exact, since numbers
# are doubles and r > 2^53
*
* Cumulative standard deviation
*
@ https://rosettacode.org/wiki/Cumulative_standard_deviation@Task
*
global sum sum2 n .
proc sd x . r .
   sum += x
   sum2 += x * x
   n += 1
   r = sqrt (sum2 / n - sum * sum / n / n)
.
v[] = [ 2 4 4 4 5 5 7 9 ]
for v in v[]
   sd v r
   print v & " " & r
.
*
* Day of the week of Christmas and New Year
*
@ https://rosettacode.org/wiki/Day_of_the_week_of_Christmas_and_New_Year@Task
*
func dayOfTheWeek year month day .
   # Based on Conway's doomsday algorithm
   century = floor (year / 100)
   if century mod 4 = 0
      centuryDoomsday = 2
   elif century mod 4 = 1
      centuryDoomsday = 0
   elif century mod 4 = 2
      centuryDoomsday = 5
   elif century mod 4 = 3
      centuryDoomsday = 3
   .
   mainYear = year mod 100
   yearDoomsday = (floor (mainYear / 12) + mainYear mod 12 + floor (mainYear mod 12 / 4) + centuryDoomsday) mod 7
   if mainYear = 0
      if century mod 4 = 0
         leap = 1
      else
         leap = 0
      .
   else
      if mainYear mod 4 = 0
         leap = 1
      else
         leap = 0
      .
   .
   if leap = 1
      januaryOne = (yearDoomsday + 4) mod 7
   else
      januaryOne = (yearDoomsday + 5) mod 7
   .
   monthDays[] = [ 0 31 59 90 120 151 181 212 243 273 304 334 ]
   nthDay = monthDays[month]
   if month > 2
      nthDay += leap
   .
   nthDay += day
   return (januaryOne + nthDay - 1) mod 7 + 1
.
days$[] = [ "Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" ]
# 
print "2021-12-25 is on " & days$[dayOfTheWeek 2021 12 25]
print "2022-1-1 is on " & days$[dayOfTheWeek 2022 1 1]
*
* Department numbers
*
@ https://rosettacode.org/wiki/Department_numbers@Task
*
numfmt 0 3
for pol = 2 step 2 to 6
   for san = 1 to 7
      for fire = 1 to 7
         if pol <> san and san <> fire and fire <> pol
            if pol + fire + san = 12
               print pol & san & fire
            .
         .
      .
   .
.
*
* Detect division by zero
*
@ https://rosettacode.org/wiki/Detect_division_by_zero@Task
*
func checkDivZero a b .
   r = a / b
   if r = number "nan" or r = number "inf" or r = number "-inf"
      return 1
   .
.
print checkDivZero 5 7
print checkDivZero -1 0
*
* Determine if a string is numeric
*
@ https://rosettacode.org/wiki/Determine_if_a_string_is_numeric@Task
*
func is_numeric a$ .
   h = number a$
   # because every variable must be used
   h = h
   return 1 - error
.
for s$ in [ "abc" "21a" "1234" "-13" "7.65" ]
   if is_numeric s$ = 1
      print s$ & " is numeric"
   else
      print s$ & " is not numeric"
   .
.
*
* Digital root
*
@ https://rosettacode.org/wiki/Digital_root@Task
*
proc digitalRoot n . x persistence .
   numberString$ = n
   currentPersist = 0
   while len numberString$ > 1
      for i = 1 to len numberString$
         sum += number substr numberString$ i 1
      .
      numberString$ = sum
      currentPersist += 1
      sum = 0
   .
   x = number numberString$
   persistence = currentPersist
.
numbers[] = [ 627615 39390 588225 393900588225 ]
for i in numbers[]
   digitalRoot i x persistence
   print i
   print "Additive persistence: " & persistence
   print "Digital root: " & x
.
*
* Dot product
*
@ https://rosettacode.org/wiki/Dot_product@Task
*
func dotprod a[] b[] .
   for i to len a[]
      r += a[i] * b[i]
   .
   return r
.
print dotprod [ 1 3 -5 ] [ 4 -2 -1 ]
*
* Dragon curve
*
@ https://rosettacode.org/wiki/Dragon_curve@Task
*
color 050
linewidth 0.5
x = 25
y = 60
move x y
angle = 0
# 
proc dragon size lev d . .
   if lev = 0
      x -= cos angle * size
      y += sin angle * size
      line x y
   else
      dragon size / sqrt 2 lev - 1 1
      angle -= d * 90
      dragon size / sqrt 2 lev - 1 -1
   .
.
dragon 60 12 1
*
* Draw a clock
*
@ https://rosettacode.org/wiki/Draw_a_clock@Task
*
proc draw hour min sec . .
   # dial
   color 333
   move 50 50
   circle 45
   color 797
   circle 44
   color 333
   for i range0 60
      a = i * 6
      move 50 + sin a * 40 50 + cos a * 40
      circle 0.25
   .
   for i range0 12
      a = i * 30
      move 50 + sin a * 40 50 + cos a * 40
      circle 1
   .
   # hour
   linewidth 2
   color 000
   a = (hour * 60 + min) / 2
   move 50 50
   line 50 + sin a * 32 50 + cos a * 32
   # min
   linewidth 1.5
   a = (sec + min * 60) / 10
   move 50 50
   line 50 + sin a * 40 50 + cos a * 40
   # sec  
   linewidth 1
   color 700
   a = sec * 6
   move 50 50
   line 50 + sin a * 40 50 + cos a * 40
.
on timer
   if t <> floor systime
      t = floor systime
      h$ = timestr t
      sec = number substr h$ 18 2
      min = number substr h$ 15 2
      hour = number substr h$ 12 2
      if hour > 12
         hour -= 12
      .
      draw hour min sec
   .
   timer 0.1
.
timer 0
*
* Draw a pixel
*
@ https://rosettacode.org/wiki/Draw_a_pixel@Task
*
color 900
move 50 50
rect 0.5 0.5
*
* Draw a rotating cube
*
@ https://rosettacode.org/wiki/Draw_a_rotating_cube@Task
*
node[][] = [ [ -1 -1 -1 ] [ -1 -1 1 ] [ -1 1 -1 ] [ -1 1 1 ] [ 1 -1 -1 ] [ 1 -1 1 ] [ 1 1 -1 ] [ 1 1 1 ] ]
edge[][] = [ [ 1 2 ] [ 2 4 ] [ 4 3 ] [ 3 1 ] [ 5 6 ] [ 6 8 ] [ 8 7 ] [ 7 5 ] [ 1 5 ] [ 2 6 ] [ 3 7 ] [ 4 8 ] ]
# 
proc scale f . .
   for i = 1 to len node[][]
      for d = 1 to 3
         node[i][d] *= f
      .
   .
.
proc rotate angx angy . .
   sinx = sin angx
   cosx = cos angx
   siny = sin angy
   cosy = cos angy
   for i = 1 to len node[][]
      x = node[i][1]
      z = node[i][3]
      node[i][1] = x * cosx - z * sinx
      y = node[i][2]
      z = z * cosx + x * sinx
      node[i][2] = y * cosy - z * siny
      node[i][3] = z * cosy + y * siny
   .
.
len nd[] 3
proc draw . .
   clear
   m = 999
   mi = -1
   for i = 1 to len node[][]
      if node[i][3] < m
         m = node[i][3]
         mi = i
      .
   .
   ix = 1
   for i = 1 to len edge[][]
      if edge[i][1] = mi
         nd[ix] = edge[i][2]
         ix += 1
      elif edge[i][2] = mi
         nd[ix] = edge[i][1]
         ix += 1
      .
   .
   for ni = 1 to len nd[]
      for i = 1 to len edge[][]
         if edge[i][1] = nd[ni] or edge[i][2] = nd[ni]
            x1 = node[edge[i][1]][1]
            y1 = node[edge[i][1]][2]
            x2 = node[edge[i][2]][1]
            y2 = node[edge[i][2]][2]
            move x1 + 50 y1 + 50
            line x2 + 50 y2 + 50
         .
      .
   .
.
scale 25
rotate 45 atan sqrt 2
draw
on animate
   rotate 1 0
   draw
.
*
* Empty string
*
@ https://rosettacode.org/wiki/Empty_string@Task
*
a$ = ""
if a$ = ""
  print "empty"
.
if a$ <> ""
  print "no empty"
.
*
* Ethiopian multiplication
*
@ https://rosettacode.org/wiki/Ethiopian_multiplication@Task
*
x = 17
y = 34
tot = 0
while x >= 1
  write x & "\t"
  if (x + 1) mod 2 = 0
    tot += y
    print y
  else
    print ""
  .
  x = x div 2
  y = 2 * y
.
print "=\t" & tot
*
* Euler's sum of powers conjecture
*
@ https://rosettacode.org/wiki/Euler's_sum_of_powers_conjecture@Task
*
n = 250
len p5[] n
len h5[] 65537
for i = 0 to n - 1
   p5[i + 1] = i * i * i * i * i
   h5[p5[i + 1] mod 65537 + 1] = 1
.
func search a s .
   y = -1
   b = n
   while a + 1 < b
      i = (a + b) div 2
      if p5[i + 1] > s
         b = i
      elif p5[i + 1] < s
         a = i
      else
         a = b
         y = i
      .
   .
   return y
.
for x0 = 0 to n - 1
   for x1 = 0 to x0
      sum1 = p5[x0 + 1] + p5[x1 + 1]
      for x2 = 0 to x1
         sum2 = p5[x2 + 1] + sum1
         for x3 = 0 to x2
            sum = p5[x3 + 1] + sum2
            if h5[sum mod 65537 + 1] = 1
               y = search x0 sum
               if y >= 0
                  print x0 & " " & x1 & " " & x2 & " " & x3 & " " & y
                  break 4
               .
            .
         .
      .
   .
.
*
* Factorial
*
@ https://rosettacode.org/wiki/Factorial@Task
*
func factorial n .
   r = 1
   for i = 2 to n
      r *= i
   .
   return r
.
print factorial 7
*
* Factors of an integer
*
@ https://rosettacode.org/wiki/Factors_of_an_integer@Task
*
n = 720
for i = 1 to n
  if n mod i = 0
    factors[] &= i
  .
.
print factors[]
*
* Fairshare between two and more
*
@ https://rosettacode.org/wiki/Fairshare_between_two_and_more@Task
*
func fairshare ind base .
   while ind > 0
      r += ind mod base
      ind = ind div base
   .
   r = r mod base
   return r
.
proc sequence n base . .
   write base & ": "
   for ind range0 n
      write (fairshare ind base) & " "
   .
   print ""
.
sequence 25 2
sequence 25 3
sequence 25 5
sequence 25 11
*
* Fibonacci sequence
*
@ https://rosettacode.org/wiki/Fibonacci_sequence@Task
*
func fib n .
   if n < 2
      return n
   .
   prev = 0
   val = 1
   for i = 2 to n
      h = prev + val
      prev = val
      val = h
   .
   return val
.
print fib 36
*
* Filter
*
@ https://rosettacode.org/wiki/Filter@Task
*
a[] = [ 1 2 3 4 5 6 7 8 9 ]
for i = 1 to len a[]
  if a[i] mod 2 = 0
    b[] &= a[i]
  .
.
print b[]
*
* Find limit of recursion
*
@ https://rosettacode.org/wiki/Find_limit_of_recursion@Task
*
proc recurse i . .
   if i mod 10 = 0
      print i
   .
   recurse i + 1
.
recurse 1
*
* Find square difference
*
@ https://rosettacode.org/wiki/Find_square_difference@Task
*
repeat
   i += 1
   square = pow i 2
   diffSquare = pow (i - 1) 2
   difference = square - diffSquare
   until difference > 1000
.
print i
*
* FizzBuzz
*
@ https://rosettacode.org/wiki/FizzBuzz@Task
*
for i = 1 to 100
  if i mod 15 = 0
    print "FizzBuzz"
  elif i mod 5 = 0
    print "Buzz"
  elif i mod 3 = 0
    print "Fizz"
  else
    print i
  .
.
*
* Forest fire
*
@ https://rosettacode.org/wiki/Forest_fire@Task
*
p_fire = 0.00002
p_tree = 0.002
# 
len f[] 102 * 102
len p[] len f[]
background 100
clear
for r = 0 to 99
   for c = 0 to 99
      i = r * 102 + c + 104
      if randomf < 0.5
         f[i] = 1
      .
   .
.
timer 0
# 
subr show
   for r = 0 to 99
      for c = 0 to 99
         i = r * 102 + c + 104
         h = f[i]
         if h <> p[i]
            move c + 0.5 r + 0.5
            if h = 0
               color 100
               circle 0.6
            elif h = 1
               color 151
               circle 0.5
            else
               color 9 * 100 + (18 - 2 * h) * 10
               circle 0.5
            .
         .
      .
   .
.
subr update
   swap f[] p[]
   for r = 0 to 99
      for c = 0 to 99
         i = r * 102 + c + 104
         if p[i] = 0
            f[i] = 0
            if randomf < p_tree
               f[i] = 1
            .
         elif p[i] = 1
            f[i] = 1
            s = p[i - 103] + p[i - 102] + p[i - 101]
            s += p[i - 1] + p[i + 1]
            s += p[i + 101] + p[i + 102] + p[i + 103]
            if s >= 9 or randomf < p_fire
               f[i] = 9
            .
         elif p[i] = 4
            f[i] = 0
         else
            f[i] = p[i] - 1
         .
      .
   .
.
on timer
   show
   update
   timer 0.2
.
*
* Fractal tree
*
@ https://rosettacode.org/wiki/Fractal_tree@Task
*
# Fractal tree
# 
color 555
proc tree x y deg n . .
   if n > 0
      linewidth n * 0.4
      move x y
      x += cos deg * n * 1.3 * (randomf + 0.5)
      y += sin deg * n * 1.3 * (randomf + 0.5)
      line x y
      tree x y deg - 20 n - 1
      tree x y deg + 20 n - 1
   .
.
timer 0
on timer
   clear
   tree 50 10 90 10
   timer 2
.
*
* Function definition
*
@ https://rosettacode.org/wiki/Function_definition@Task
*
func multiply a b .
   return a * b
.
print multiply 7 5
*
* Generate lower case ASCII alphabet
*
@ https://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet@Task
*
# Generated on an array
for i = 97 to 122
   alphabet$[] &= strchar i
.
print alphabet$[]
# Generated on a string
for i = 97 to 122
   alphabet$ &= strchar i
.
print alphabet$
*
* Giuga numbers
*
@ https://rosettacode.org/wiki/Giuga_numbers@Task
*
func giuga m .
   n = m
   for f = 2 to sqrt n
      while n mod f = 0
         if (m div f - 1) mod f <> 0
            return 0
         .
         n = n div f
         if f > n
            return 1
         .
      .
   .
.
n = 3
while cnt < 4
   if giuga n = 1
      cnt += 1
      print n
   .
   n += 1
.
*
* Goldbach's comet
*
@ https://rosettacode.org/wiki/Goldbach's_comet@Task
*
func isprim n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func goldbach n .
   for i = 2 to n div 2
      if isprim i = 1
         cnt += isprim (n - i)
      .
   .
   return cnt
.
numfmt 0 3
for n = 4 step 2 to 202
   write goldbach n
   if n mod 20 = 2
      print ""
   .
.
print goldbach 1000000
*
* Golden ratio/Convergence
*
@ https://rosettacode.org/wiki/Golden_ratio/Convergence@Task
*
phi0 = 1
repeat
   phi = 1 + 1 / phi0
   until abs (phi - phi0) < 1e-5
   phi0 = phi
   iter += 1
.
numfmt 10 0
print "Iterations: " & iter
print "Result: " & phi
print "Error: " & phi - (1 + sqrt 5) / 2
*
* Greatest common divisor
*
@ https://rosettacode.org/wiki/Greatest_common_divisor@Task
*
func gcd a b .
   while b <> 0
      h = b
      b = a mod b
      a = h
   .
   return a
.
print gcd 120 35
*
* Greatest element of a list
*
@ https://rosettacode.org/wiki/Greatest_element_of_a_list@Task
*
a[] = [ 2 9 4 3 8 5 ]
for e in a[]
  max = higher e max
.
print max
*
* Greyscale bars/Display
*
@ https://rosettacode.org/wiki/Greyscale_bars/Display@Task
*
n = 8
for row = 0 to 3
   sz = 100 / n
   for i = 0 to n - 1
      c = i / (n - 1)
      if row mod 2 = 1
         c = 1 - c
      .
      color3 c c c
      move sz * i 75 - row * 25
      rect sz + 1 25
      sleep 0.02
   .
   n *= 2
.
*
* Guess the number
*
@ https://rosettacode.org/wiki/Guess_the_number@Task
*
n = random 10
write "Guess a number between 1 and 10: "
repeat
  g = number input
  write g
  until g = n
  print " is wrong"
  write "try again: "
.
print " is correct. Well guessed!"
*
* Guess the number/With feedback
*
@ https://rosettacode.org/wiki/Guess_the_number/With_feedback@Task
*
print "Guess a number between 1 and 100!"
n = random 100
repeat
   g = number input
   write g
   if error = 1
      print "You must enter a number!"
   elif g > n
      print " is too high"
   elif g < n
      print " is too low"
   .
   until g = n
.
print " is correct"
*
* Hello world/Graphical
*
@ https://rosettacode.org/wiki/Hello_world/Graphical@Task
*
move 10 20
text "Goodbye, World!"
*
* Hello world/Newline omission
*
@ https://rosettacode.org/wiki/Hello_world/Newline_omission@Task
*
write "Goodbye, World!"
*
* Hello world/Text
*
@ https://rosettacode.org/wiki/Hello_world/Text@Task
*
print "Hello world!"
*
* Horizontal sundial calculations
*
@ https://rosettacode.org/wiki/Horizontal_sundial_calculations@Task
*
func getn s$ .
   write s$
   v = number input
   print v
   return v
.
lat = getn "Enter latitude: "
lng = getn "Enter longitude: "
merid = getn "Enter legal meridian: "
slat = sin lat
diff = lng - merid
print ""
print "    sine of latitude: " & slat
print "    diff longitude: " & diff
print ""
print "Hour\tSun hour angle\tDial hour line angle"
for h = -6 to 6
   hra = 15 * h - diff
   hla = atan2 (slat * sin hra) cos hra
   print h + 12 & "\t" & hra & "\t\t" & hla
.
*
* Implicit type conversion
*
@ https://rosettacode.org/wiki/Implicit_type_conversion@Task
*
string$ = 32
print string$
*
* Increment a numerical string
*
@ https://rosettacode.org/wiki/Increment_a_numerical_string@Task
*
a$ = "12"
a$ = number a$ + 1
print a$
*
* Input loop
*
@ https://rosettacode.org/wiki/Input_loop@Task
*
repeat
  l$ = input
  until error = 1
  print l$
.
*
* Integer comparison
*
@ https://rosettacode.org/wiki/Integer_comparison@Task
*
a = number input
b = number input
if a < b
  print "less"
.
if a = b
  print "equal"
.
if a > b
  print "greater"
.
*
* Integer sequence
*
@ https://rosettacode.org/wiki/Integer_sequence@Task
*
max = pow 2 53
repeat
   print i
   if i = 10
      print "."
      print "."
      i = max - 10
   .
   until i = max
   i += 1
.
*
* ISBN13 check digit
*
@ https://rosettacode.org/wiki/ISBN13_check_digit@Task
*
func ISBN13check isbn$ .
   for c$ in strchars isbn$
      if c$ <> "-"
         ndigs += 1
      .
      dig = number c$
      if ndigs mod 2 = 0
         dig *= 3
      .
      sum += dig
   .
   if sum mod 10 <> 0
      return 0
   .
   return 1
.
codes$[] = [ "978-0596528126" "978-0596528120" "978-1788399081" "978-1788399083" ]
for code$ in codes$[]
   if ISBN13check code$ = 1
      print code$ & " is a valid ISBN"
   else
      print code$ & " is not a valid ISBN"
   .
.
*
* Josephus problem
*
@ https://rosettacode.org/wiki/Josephus_problem@Task
*
n = 41
k = 3
print "prisoners: " & n
print "step size: " & k
for i = 1 to n
   lm = (lm + k) mod i
.
print "final survivor: " & lm
*
* Julia set
*
@ https://rosettacode.org/wiki/Julia_set@Task
*
cx = -0.7
cy = 0.27015
for y = 0 to 299
  for x = 0 to 299
    zx = (x - 150) / 100
    zy = (y - 150) / 150
    color3 0 0 0
    for iter = 0 to 127
      if zx * zx + zy * zy > 4
        color3 iter / 16 0 0
        break 1
      .
      h = zx * zx - zy * zy + cx
      zy = 2 * zx * zy + cy
      zx = h
    .
    move x / 3 y / 3
    rect 0.4 0.4
  .
.
*
* Knapsack problem/0-1
*
@ https://rosettacode.org/wiki/Knapsack_problem/0-1@Task
*
name$[] = [ "map" "compass" "water" "sandwich" "glucose" "tin" "banana" "apple" "cheese" "beer" "suntan cream" "camera" "t-shirt" "trousers" "umbrella" "waterproof trousers" "waterproof overclothes" "note-case" "sunglasses" "towel" "socks" "book" ]
weight[] = [ 9 13 153 50 15 68 27 39 23 52 11 32 24 48 73 42 43 22 7 18 4 30 ]
value[] = [ 150 35 200 160 60 45 60 40 30 10 70 30 15 10 40 70 75 80 20 12 50 10 ]
max_w = 400
# 
proc solve i maxw . items[] wres vres .
   if i <= 0
      wres = 0
      vres = 0
      items[] = [ ]
   elif weight[i] > maxw
      solve i - 1 maxw items[] wres vres
   else
      solve i - 1 maxw items[] wres vres
      solve i - 1 maxw - weight[i] items1[] w1 v1
      v1 += value[i]
      if v1 > vres
         swap items[] items1[]
         items[] &= i
         wres = w1 + weight[i]
         vres = v1
      .
   .
.
solve len weight[] max_w items[] w v
print "weight: " & w
print "value: " & v
print "items:"
for item in items[]
   print "  " & name$[item]
.
*
* Knuth shuffle
*
@ https://rosettacode.org/wiki/Knuth_shuffle@Task
*
proc shuffle . a[] .
   for i = len a[] downto 2
      r = random i
      swap a[r] a[i]
   .
.
arr[] = [ 1 2 3 ]
shuffle arr[]
print arr[]
*
* Koch curve
*
@ https://rosettacode.org/wiki/Koch_curve@Task
*
proc koch x1 y1 x2 y2 iter . .
   x3 = (x1 * 2 + x2) / 3
   y3 = (y1 * 2 + y2) / 3
   x4 = (x1 + x2 * 2) / 3
   y4 = (y1 + y2 * 2) / 3
   x5 = x3 + (x4 - x3) * cos 60 + (y4 - y3) * sin 60
   y5 = y3 - (x4 - x3) * sin 60 + (y4 - y3) * cos 60
   if iter > 0
      iter -= 1
      koch x1 y1 x3 y3 iter
      koch x3 y3 x5 y5 iter
      koch x5 y5 x4 y4 iter
      koch x4 y4 x2 y2 iter
   else
      line x1 y1
      line x3 y3
      line x5 y5
      line x4 y4
      line x2 y2
   .
.
linewidth 0.3
x1 = 15
y1 = 30
move x1 y1
for ang = 0 step 120 to 240
   x2 = x1 + 70 * cos ang
   y2 = y1 + 70 * sin ang
   koch x1 y1 x2 y2 4
   x1 = x2
   y1 = y2
.
*
* Langton's ant
*
@ https://rosettacode.org/wiki/Langton's_ant@Task
*
len f[] 100 * 100
proc show . .
   for y = 0 to 99
      for x = 0 to 99
         if f[y * 100 + x + 1] = 1
            move x y
            rect 1 1
         .
      .
   .
.
proc run x y dir . .
   dx[] = [ 0 1 0 -1 ]
   dy[] = [ -1 0 1 0 ]
   while x >= 0 and x < 100 and y >= 0 and y < 100
      v = f[y * 100 + x + 1]
      f[y * 100 + x + 1] = 1 - v
      dir = (dir + 2 * v) mod 4 + 1
      x += dx[dir]
      y += dy[dir]
   .
.
run 70 40 0
show
*
* Largest number divisible by its digits
*
@ https://rosettacode.org/wiki/Largest_number_divisible_by_its_digits@Task
*
global found dig[] .
proc test . .
   for i to len dig[]
      n = n * 10 + dig[i]
   .
   for i to len dig[]
      if n mod dig[i] <> 0
         break 2
      .
   .
   found = 1
   print n
.
len use[] 9
proc perm pos . .
   if found = 1
      break 1
   .
   for i = 9 downto 1
      dig[pos] = i
      if use[i] = 0
         use[i] = 1
         if pos = len dig[]
            test
         else
            perm pos + 1
         .
         use[i] = 0
      .
   .
.
for ndig = 9 downto 1
   len dig[] ndig
   perm 1
.
*
* Largest proper divisor of n
*
@ https://rosettacode.org/wiki/Largest_proper_divisor_of_n@Task
*
func lpdiv v .
   r = 1
   for i = 2 to v div 2
      if v mod i = 0
         r = i
      .
   .
   return r
.
numfmt 0 3
for i = 1 to 100
   write lpdiv i
   if i mod 10 = 0
      print ""
   .
.
*
* Literals/Floating point
*
@ https://rosettacode.org/wiki/Literals/Floating_point@Task
*
decimal = 57.1
decimalWithE = 5710E-2
hexadecimal = 0x39.1999999999
print decimal
print decimalWithE
print hexadecimal
*
* Literals/Integer
*
@ https://rosettacode.org/wiki/Literals/Integer@Task
*
decimal = 57
hexadecimal = 0x39
print decimal
print hexadecimal
*
* Literals/String
*
@ https://rosettacode.org/wiki/Literals/String@Task
*
print "EasyLang"
print "简"
*
* Logical operations
*
@ https://rosettacode.org/wiki/Logical_operations@Task
*
proc logic a b . .
   if a = 1 and b = 1
      r1 = 1
   .
   if a = 1 or b = 1
      r2 = 1
   .
   if a = 0
      r3 = 1
   .
   print r1 & " " & r2 & " " & r3
.
logic 0 0
logic 0 1
logic 1 0
logic 1 1
*
* Long multiplication
*
@ https://rosettacode.org/wiki/Long_multiplication@Task
*
func$ mult a$ b$ .
   a[] = number strchars a$
   b[] = number strchars b$
   len r[] len a[] + len b[]
   for ib = len b[] downto 1
      h = 0
      for ia = len a[] downto 1
         h += r[ia + ib] + b[ib] * a[ia]
         r[ia + ib] = h mod 10
         h = h div 10
      .
      r[ib] += h
   .
   r$ = ""
   for i = 1 to len r[]
      if r$ <> "" or r[i] <> 0 or i = len r[]
         r$ &= r[i]
      .
   .
   return r$
.
print mult "18446744073709551616" "18446744073709551616"
*
* Loops/Break
*
@ https://rosettacode.org/wiki/Loops/Break@Task
*
repeat
  a = random 20
  print a
  until a = 10
  print random 20
.
*
* Loops/Do-while
*
@ https://rosettacode.org/wiki/Loops/Do-while@Task
*
value = 0
repeat
   value += 1
   print value
   until value mod 6 = 0
.
*
* Loops/Downward for
*
@ https://rosettacode.org/wiki/Loops/Downward_for@Task
*
for i = 10 downto 0
  print i
.
*
* Loops/For
*
@ https://rosettacode.org/wiki/Loops/For@Task
*
for i = 1 to 5
  for j = 1 to i
    write "*"
  .
  print ""
.
*
* Loops/For with a specified step
*
@ https://rosettacode.org/wiki/Loops/For_with_a_specified_step@Task
*
# Prints even numbers from 0 to 100
for i = 0 step 2 to 100
   print i
.
*
* Loops/Foreach
*
@ https://rosettacode.org/wiki/Loops/Foreach@Task
*
for i in [ 5 1 19 25 12 1 14 7 ]
   print i
.
*
* Loops/Infinite
*
@ https://rosettacode.org/wiki/Loops/Infinite@Task
*
while 1 = 1
   print "SPAM"
.
*
* Loops/N plus one half
*
@ https://rosettacode.org/wiki/Loops/N_plus_one_half@Task
*
for i = 1 to 10
   write i
   if i < 10
      write ", "
   .
.
*
* Loops/Nested
*
@ https://rosettacode.org/wiki/Loops/Nested@Task
*
arr[][] = [ [ 2 12 10 4 ] [ 18 11 20 2 ] ]
for i to len arr[][]
   for j to len arr[i][]
      if arr[i][j] = 20
         print "20 at " & i & "," & j
         break 2
      .
   .
.
*
* Loops/While
*
@ https://rosettacode.org/wiki/Loops/While@Task
*
i = 1024
while i > 0
  print i
  i = i div 2
.
*
* Mandelbrot set
*
@ https://rosettacode.org/wiki/Mandelbrot_set@Task
*
# Mandelbrot
#  
res = 4
maxiter = 200
# 
# better but slower:
# res = 8
# maxiter = 300
# 
#  
mid = res * 50
center_x = 3 * mid / 2
center_y = mid
scale = mid
# 
background 000
textsize 2
# 
fastfunc iter cx cy maxiter .
   while xx + yy < 4 and it < maxiter
      y = 2 * x * y + cy
      x = xx - yy + cx
      xx = x * x
      yy = y * y
      it += 1
   .
   return it
.
proc draw . .
   clear
   for scr_y = 0 to 2 * mid - 1
      cy = (scr_y - center_y) / scale
      for scr_x = 0 to 2 * mid - 1
         cx = (scr_x - center_x) / scale
         it = iter cx cy maxiter
         if it < maxiter
            color3 it / 20 it / 100 it / 150
            move scr_x / res scr_y / res
            rect 1 / res 1 / res
         .
      .
   .
   color 990
   move 1 1
   text "Short press to zoom in, long to zoom out"
.
on mouse_down
   time0 = systime
.
on mouse_up
   center_x += mid - mouse_x * res
   center_y += mid - mouse_y * res
   if systime - time0 < 0.3
      center_x -= mid - center_x
      center_y -= mid - center_y
      scale *= 2
   else
      center_x += (mid - center_x) * 3 / 4
      center_y += (mid - center_y) * 3 / 4
      scale /= 4
   .
   draw
.
draw
*
* Mastermind
*
@ https://rosettacode.org/wiki/Mastermind@Task
*
# Mastermind:w90
# 
col[] = [ 802 990 171 229 950 808 ]
len code[] 4
len guess[] 4
# 
subr init_vars
   row = 0
.
proc draw_rate r black white . .
   for j range0 2
      for c range0 2
         move c * 3.5 + 71.5 r * 11.5 + 9.4 - j * 3.5
         if black > 0
            color 000
            circle 1.4
            black -= 1
         elif white > 0
            color 999
            circle 1.4
            white -= 1
         else
            color 310
            circle 0.7
         .
      .
   .
.
proc show_code . .
   color 531
   move 22 92
   rect 46 8
   for i to 4
      move i * 8 + 20 97
      color col[code[i]]
      circle 2
   .
.
proc draw_guess . .
   for c to 4
      move c * 12 + 8 row * 11.5 + 7.5
      color col[guess[c]]
      circle 3.8
   .
.
proc next_row . .
   color 420
   linewidth 11
   move 17 row * 11.5 + 7.5
   line 60 row * 11.5 + 7.5
   draw_guess
   move 73.5 row * 11.5 + 7.5
   color 310
   circle 5.0
   color 753
   move 71.5 row * 11.5 + 5
   textsize 7
   text "✓"
.
proc rate . .
   move 73.5 row * 11.5 + 7.5
   color 531
   circle 5.2
   c[] = code[]
   g[] = guess[]
   for i to 4
      if c[i] = g[i]
         black += 1
         c[i] = -1
         g[i] = -2
      .
   .
   for i to 4
      for j to 4
         if c[i] = g[j]
            white += 1
            c[i] = -1
            g[j] = -2
         .
      .
   .
   draw_rate row black white
   color 531
   linewidth 12
   move 17 row * 11.5 + 7.5
   line 60 row * 11.5 + 7.5
   draw_guess
   row += 1
   if black = 4
      row = 8
   .
   if row = 8
      show_code
      timer 2
   else
      next_row
   .
.
on timer
   row = -2
.
proc new . .
   init_vars
   for i to 4
      code[i] = random 6
   .
   color 531
   move 10 10
   rect 70 80
   linewidth 10
   move 5 95
   line 5 5
   line 85 5
   line 85 95
   line 5 95
   color 310
   linewidth 7
   move 28 96.5
   line 58 96.5
   move 30 95
   color 864
   textsize 4
   text "Mastermind"
   color 310
   linewidth 0.5
   move 10 90
   line 10 4
   move 67 90
   line 67 4
   move 80 90
   line 80 4
   for r range0 8
      for c range0 4
         move c * 12 + 20 r * 11.5 + 7.5
         circle 2
      .
      draw_rate r 0 0
   .
   guess[1] = 1
   guess[2] = 1
   guess[3] = 2
   guess[4] = 2
   next_row
.
proc do_move . .
   c = (mouse_x - 15) div 12
   guess[c + 1] = guess[c + 1] mod 6 + 1
   draw_guess
.
on mouse_down
   if row = -2
      new
   elif mouse_y > row * 11.5 + 0.5 and mouse_y < row * 11.5 + 10.5 and row < 8
      if mouse_x > 15 and mouse_x < 61
         do_move
      elif mouse_x > 67 and mouse_x < 80
         rate
      .
   .
.
new
*
* Maze solving
*
@ https://rosettacode.org/wiki/Maze_solving@Task
*
# maze generation and solving
# 
size = 15
n = 2 * size + 1
f = 100 / (n - 0.5)
len m[] n * n
# 
background 000
proc show_maze . .
   clear
   for i = 1 to len m[]
      if m[i] = 0
         x = (i - 1) mod n
         y = (i - 1) div n
         color 999
         move x * f - f / 2 y * f - f / 2
         rect f * 1.5 f * 1.5
      .
   .
   sleep 0.01
.
offs[] = [ 1 n -1 (-n) ]
proc m_maze pos . .
   m[pos] = 0
   show_maze
   d[] = [ 1 2 3 4 ]
   for i = 4 downto 1
      d = random i
      dir = offs[d[d]]
      d[d] = d[i]
      if m[pos + dir] = 1 and m[pos + 2 * dir] = 1
         m[pos + dir] = 0
         m_maze pos + 2 * dir
      .
   .
.
endpos = n * n - 1
proc make_maze . .
   for i = 1 to len m[]
      m[i] = 1
   .
   for i = 1 to n
      m[i] = 2
      m[n * i] = 2
      m[n * i - n + 1] = 2
      m[n * n - n + i] = 2
   .
   h = 2 * random 15 - n + n * 2 * random 15
   m_maze h
   m[endpos] = 0
.
make_maze
show_maze
# 
proc mark pos col . .
   x = (pos - 1) mod n
   y = (pos - 1) div n
   color col
   move x * f + f / 4 y * f + f / 4
   circle f / 3.5
.
proc solve dir0 pos . found .
   mark pos 900
   sleep 0.05
   if pos = endpos
      found = 1
      break 1
   .
   of = random 4 - 1
   for h = 1 to 4
      dir = (h + of) mod1 4
      posn = pos + offs[dir]
      if dir <> dir0 and m[posn] = 0 and found = 0
         solve (dir + 1) mod 4 + 1 posn found
         if found = 0
            mark posn 888
            sleep 0.08
         .
      .
   .
.
sleep 1
solve 0 n + 2 found
*
* MD5/Implementation
*
@ https://rosettacode.org/wiki/MD5/Implementation@Task
*
len md5k[] 64
proc md5init . .
   for i = 1 to 64
      md5k[i] = floor (0x100000000 * abs sin (i * 180 / pi))
   .
.
md5init
# 
proc md5 inp$ . s$ .
   subr addinp
      if inp4 = 1
         inp[] &= 0
      .
      inp[len inp[]] += b * inp4
      inp4 *= 0x100
      if inp4 = 0x100000000
         inp4 = 1
      .
   .
   s[] = [ 7 12 17 22 7 12 17 22 7 12 17 22 7 12 17 22 5 9 14 20 5 9 14 20 5 9 14 20 5 9 14 20 4 11 16 23 4 11 16 23 4 11 16 23 4 11 16 23 6 10 15 21 6 10 15 21 6 10 15 21 6 10 15 21 ]
   inp[] = [ ]
   inp4 = 1
   for i = 1 to len inp$
      b = strcode substr inp$ i 1
      addinp
   .
   b = 0x80
   addinp
   while len inp[] mod 16 <> 14 or inp4 <> 1
      b = 0
      addinp
   .
   h = len inp$ * 8
   for i = 1 to 4
      b = h mod 0x100
      addinp
      h = h div 0x100
   .
   inp[] &= 0
   # 
   a0 = 0x67452301
   b0 = 0xefcdab89
   c0 = 0x98badcfe
   d0 = 0x10325476
   for chunk = 1 step 16 to len inp[] - 15
      a = a0 ; b = b0 ; c = c0 ; d = d0
      for i = 1 to 64
         if i <= 16
            h1 = bitand b c
            h2 = bitand bitnot b d
            f = bitor h1 h2
            g = i - 1
         elif i <= 32
            h1 = bitand d b
            h2 = bitand bitnot d c
            f = bitor h1 h2
            g = (5 * i - 4) mod 16
         elif i <= 48
            h1 = bitxor b c
            f = bitxor h1 d
            g = (3 * i + 2) mod 16
         else
            h1 = bitor b bitnot d
            f = bitxor c h1
            g = (7 * i - 7) mod 16
         .
         f = (f + a + md5k[i] + inp[chunk + g])
         a = d
         d = c
         c = b
         h1 = bitshift f s[i]
         h2 = bitshift f (s[i] - 32)
         b = (b + h1 + h2)
      .
      a0 += a ; b0 += b ; c0 += c ; d0 += d
   .
   s$ = ""
   for a in [ a0 b0 c0 d0 ]
      for i = 1 to 4
         b = a mod 256
         a = a div 256
         for h in [ b div 16 b mod 16 ]
            h += 48
            if h > 57
               h += 39
            .
            s$ &= strchar h
         .
      .
   .
.
repeat
   s$ = input
   until error = 1
   md5 s$ h$
   print h$
.
input_data
a
abc
message digest
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
12345678901234567890123456789012345678901234567890123456789012345678901234567890
*
* Middle three digits
*
@ https://rosettacode.org/wiki/Middle_three_digits@Task
*
func$ midThreeDigits num .
   trueNumber$ = abs num
   if (len trueNumber$ < 3) or (len trueNumber$ mod 2 = 0)
      r$ = "error"
   else
      r$ = substr trueNumber$ ((len trueNumber$ - 3) / 2 + 1) 3
   .
   return r$
.
numbers[] = [ 123 12345 1234567 987654321 10001 -10001 -123 -100 100 -12345 1 2 -1 -10 2002 -2002 0 ]
for i in numbers[]
   print midThreeDigits i
.
*
* Minesweeper game
*
@ https://rosettacode.org/wiki/Minesweeper_game@Task
*
len cell[] 56
len cnt[] 56
len flag[] 56
# 
subr initvars
   state = 0
   ticks = 0
   indx = -1
   no_time = 0
.
func getind r c .
   ind = -1
   if r >= 0 and r <= 6 and c >= 0 and c <= 7
      ind = r * 8 + c + 1
   .
   return ind
.
proc draw_cell ind h . .
   ind -= 1
   r = ind div 8
   c = ind mod 8
   x = c * 12 + 2.5
   y = r * 12 + 2.5
   move x y
   rect 11 11
   if h > 0
      # count
      move x + 3 y + 3
      color 000
      text h
   elif h = -3
      # flag
      x += 4
      color 000
      linewidth 0.8
      move x y + 3
      line x y + 8
      color 600
      linewidth 2
      move x + 0.5 y + 7
      line x + 2 y + 7
   elif h <> 0
      # mine
      color 333
      if h = -2
         color 800
      .
      move x + 5 y + 5
      circle 3
      line x + 8 y + 9
   .
.
proc open ind . .
   if ind <> -1 and cell[ind] = 0
      cell[ind] = 2
      flag[ind] = 0
      color 686
      draw_cell ind cnt[ind]
      if cnt[ind] = 0
         ind -= 1
         r0 = ind div 8
         c0 = ind mod 8
         for r = r0 - 1 to r0 + 1
            for c = c0 - 1 to c0 + 1
               if r <> r0 or c <> c0
                  open getind r c
               .
            .
         .
      .
   .
.
proc show_mines m . .
   for ind to 56
      if cell[ind] = 1
         color 686
         if m = -1
            color 353
         .
         draw_cell ind m
      .
   .
.
proc outp col s$ . .
   move 2.5 87
   color col
   rect 59 11
   color 000
   move 5 90
   text s$
.
proc upd_info . .
   for i to 56
      nm += flag[i]
      if cell[i] < 2
         nc += 1
      .
   .
   if nc = 8
      outp 484 "Well done"
      show_mines -1
      state = 1
   else
      outp 464 8 - nm & " mines left"
   .
.
proc test ind . .
   if cell[ind] < 2 and flag[ind] = 0
      if cell[ind] = 1
         show_mines -1
         color 686
         draw_cell ind -2
         outp 844 "B O O M !"
         state = 1
      else
         open ind
         upd_info
      .
   .
.
background 676
proc start . .
   clear
   color 353
   for ind to 56
      cnt[ind] = 0
      cell[ind] = 0
      flag[ind] = 0
      draw_cell ind 0
   .
   n = 8
   while n > 0
      c = random 8 - 1
      r = random 7 - 1
      ind = r * 8 + c + 1
      if cell[ind] = 0
         n -= 1
         cell[ind] = 1
         for rx = r - 1 to r + 1
            for cx = c - 1 to c + 1
               ind = getind rx cx
               if ind > -1
                  cnt[ind] += 1
               .
            .
         .
      .
   .
   initvars
   outp 464 ""
   textsize 4
   move 5 93
   text "Minesweeper - 8 mines"
   move 5 88.2
   text "Long-press for flagging"
   textsize 6
   timer 0
.
on mouse_down
   if state = 0
      if mouse_y > 86 and mouse_x > 60
         no_time = 1
         move 64.5 87
         color 464
         rect 33 11
      .
      indx = getind ((mouse_y - 2) div 12) ((mouse_x - 2) div 12)
      ticks0 = ticks
   elif state = 3
      start
   .
.
on mouse_up
   if state = 0 and indx <> -1
      test indx
   .
   indx = -1
.
on timer
   if state = 1
      state = 2
      timer 1
   elif state = 2
      state = 3
   elif no_time = 0 and ticks > 3000
      outp 844 "B O O M !"
      show_mines -2
      state = 2
      timer 1
   else
      if indx > 0 and ticks = ticks0 + 2
         if cell[indx] < 2
            color 353
            flag[indx] = 1 - flag[indx]
            opt = 0
            if flag[indx] = 1
               opt = -3
            .
            draw_cell indx opt
            upd_info
         .
         indx = -1
      .
      if no_time = 0 and ticks mod 10 = 0
         move 64.5 87
         color 464
         if ticks >= 2500
            color 844
         .
         rect 33 11
         color 000
         move 66 90
         text "Time:" & 300 - ticks / 10
      .
      ticks += 1
      timer 0.1
   .
.
start
*
* Modular inverse
*
@ https://rosettacode.org/wiki/Modular_inverse@Task
*
func mod_inv a b .
   b0 = b
   x1 = 1
   if b = 1
      return 1
   .
   while a > 1
      q = a div b
      t = b
      b = a mod b
      a = t
      t = x0
      x0 = x1 - q * x0
      x1 = t
   .
   if x1 < 0
      x1 += b0
   .
   return x1
.
print mod_inv 42 2017
*
* Monte Carlo methods
*
@ https://rosettacode.org/wiki/Monte_Carlo_methods@Task
*
func mc n .
   for i = 1 to n
      x = randomf
      y = randomf
      if x * x + y * y < 1
         hit += 1
      .
   .
   return 4.0 * hit / n
.
numfmt 4 0
print mc 10000
print mc 100000
print mc 1000000
print mc 10000000
*
* Morse code
*
@ https://rosettacode.org/wiki/Morse_code@Task
*
txt$ = "sos sos"
# 
chars$[] = strchars "abcdefghijklmnopqrstuvwxyz "
code$[] = [ ".-" "-..." "-.-." "-.." "." "..-." "--." "...." ".." ".---" "-.-" ".-.." "--" "-." "---" ".--." "--.-" ".-." "..." "-" "..-" "...-" ".--" "-..-" "-.--" "--.." " " ]
# 
proc morse ch$ . .
   ind = 1
   while ind <= len chars$[] and chars$[ind] <> ch$
      ind += 1
   .
   if ind <= len chars$[]
      write ch$ & " "
      sleep 0.4
      for c$ in strchars code$[ind]
         write c$
         if c$ = "."
            sound [ 440 0.2 ]
            sleep 0.4
         elif c$ = "-"
            sound [ 440 0.6 ]
            sleep 0.8
         elif c$ = " "
            sleep 0.8
         .
      .
      print ""
   .
.
for ch$ in strchars txt$
   morse ch$
.
*
* Mouse position
*
@ https://rosettacode.org/wiki/Mouse_position@Task
*
on mouse_move
  clear
  text mouse_x & " " & mouse_y
.
*
* Multiplication tables
*
@ https://rosettacode.org/wiki/Multiplication_tables@Task
*
n = 12
numfmt 0 4
write "     "
for i = 1 to n
   write i
.
print ""
write "     "
for i = 1 to n
   write "----"
.
print ""
for i = 1 to n
   write i
   write "|"
   for j = 1 to n
      if j < i
         write "    "
      else
         write i * j
      .
   .
   print ""
.
*
* Munching squares
*
@ https://rosettacode.org/wiki/Munching_squares@Task
*
sc = 100 / 64
for x range0 64
   for y range0 64
      h = bitand bitxor x y 63
      c = h / 63
      color3 c c c
      move x * sc y * sc
      rect sc + 0.1 sc + 0.1
   .
.
*
* Musical scale
*
@ https://rosettacode.org/wiki/Musical_scale@Task
*
n[] = [ 262 294 330 349 392 440 494 523 ]
for t in n[]
  sound [ t 0.5 ]
  sleep 0.6
.
*
* N'th
*
@ https://rosettacode.org/wiki/N'th@Task
*
func$ nth num .
   last2 = num mod 100
   last = num mod 10
   if last2 >= 11 and last2 <= 13
      return num & "th"
   elif last = 1
      return num & "st"
   elif last = 2
      return num & "nd"
   elif last = 3
      return num & "rd"
   else
      return num & "th"
   .
.
print "0 to 25:"
for i = 0 to 25
   write nth i & " "
.
print ""
print "250 to 265:"
for i = 250 to 265
   write nth i & " "
.
print ""
print "1000 to 1025:"
for i = 1000 to 1025
   write nth i & " "
.
*
* N-queens problem
*
@ https://rosettacode.org/wiki/N-queens_problem@Task
*
subr show_sol
   print "Solution " & n_sol
   print ""
   for i = 1 to n
      write "  "
      for j = 1 to n
         if j = x[i]
            write "Q "
         else
            write ". "
         .
      .
      print ""
   .
   print ""
.
subr test
   ok = 1
   for i = 1 to y - 1
      if x[y] = x[i] or abs (x[i] - x[y]) = abs (y - i)
         ok = 0
      .
   .
.
n = 8
len x[] n
y = 1
x[1] = 1
while y >= 1
   test
   if ok = 1 and y + 1 <= n
      y += 1
      x[y] = 1
   else
      if ok = 1
         n_sol += 1
         if n_sol <= 1
            show_sol
         .
      .
      while y >= 1 and x[y] = n
         y -= 1
      .
      if y >= 1
         x[y] += 1
      .
   .
.
print n_sol & " solutions"
*
* Narcissistic decimal number
*
@ https://rosettacode.org/wiki/Narcissistic_decimal_number@Task
*
while cnt < 25
   s$ = n
   ln = len s$
   s = 0
   for i to ln
      s += pow number substr s$ i 1 ln
   .
   if s = n
      print s
      cnt += 1
   .
   n += 1
.
*
* Nim game
*
@ https://rosettacode.org/wiki/Nim_game@Task
*
token = 12
while token > 0
   repeat
      print "There are " & token & " tokens remaining."
      write "How many would you like to take? (1,2 or 3) "
      h = number input
      print h
      until h >= 1 and h <= 3
   .
   sleep 1
   print "On my turn I will take " & 4 - h & " token(s)."
   print ""
   token -= 4
.
print "I got the last token. I win! Better luck next time."
*
* Nth root
*
@ https://rosettacode.org/wiki/Nth_root@Task
*
func power x n .
   r = 1
   for i = 1 to n
      r *= x
   .
   return r
.
func nth_root x n .
   r = 2
   repeat
      p = power r (n - 1)
      d = (x / p - r) / n
      r += d
      until abs d < 0.0001
   .
   return r
.
numfmt 4 0
x = power 3.1416 10
print nth_root x 10
*
* Palindrome detection
*
@ https://rosettacode.org/wiki/Palindrome_detection@Task
*
func$ reverse s$ .
   a$[] = strchars s$
   for i = 1 to len a$[] div 2
      swap a$[i] a$[len a$[] - i + 1]
   .
   return strjoin a$[]
.
func palin s$ .
   if s$ = reverse s$
      return 1
   .
   return 0
.
for s$ in [ "rotor" "rosetta" "step on no pets" "été" "🦊😀🦊" ]
   if palin s$ = 1
      print s$ & " is a palindrome"
   else
      print s$ & " is not a palindrome"
   .
.
*
* Pentagram
*
@ https://rosettacode.org/wiki/Pentagram@Task
*
xp = 10
yp = 60
linewidth 2
move xp yp
while angle < 720
   x = xp + cos angle * 80
   y = yp + sin -angle * 80
   line x y
   f[] &= x
   f[] &= y
   xp = x
   yp = y
   angle += 144
.
color 900
polygon f[]
*
* Percolation/Mean run density
*
@ https://rosettacode.org/wiki/Percolation/Mean_run_density@Task
*
numfmt 3 6
for p in [ 0.1 0.3 0.5 0.7 0.9 ]
   theory = p * (1 - p)
   print "p:" & p & " theory:" & theory
   print "    n    sim"
   for n in [ 1e2 1e3 1e4 ]
      sum = 0
      for t to 100
         run = 0
         for j to n
            h = if randomf < p
            if h = 1 and run = 0
               sum += 1
            .
            run = h
         .
      .
      print n & "  " & sum / n / t
   .
   print ""
.
*
* Permutations
*
@ https://rosettacode.org/wiki/Permutations@Task
*
proc permlist k . list[] .
   for i = k to len list[]
      swap list[i] list[k]
      permlist k + 1 list[]
      swap list[k] list[i]
   .
   if k = len list[]
      print list[]
   .
.
l[] = [ 1 2 3 ]
permlist 1 l[]
*
* Pick random element
*
@ https://rosettacode.org/wiki/Pick_random_element@Task
*
ar$[] = [ "spring" "summer" "autumn" "winter" ]
print ar$[random len ar$[]]
*
* Plot coordinate pairs
*
@ https://rosettacode.org/wiki/Plot_coordinate_pairs@Task
*
x[] = [ 0 1 2 3 4 5 6 7 8 9 ]
y[] = [ 2.7 2.8 31.4 38.1 58.0 76.2 100.5 130.0 149.3 180.0 ]
# 
clear
linewidth 0.5
move 10 97
line 10 5
line 95 5
textsize 3
n = len x[]
m = 0
for i = 1 to n
   if y[i] > m
      m = y[i]
   .
.
linewidth 0.1
sty = m div 9
for i range0 10
   move 2 4 + i * 10
   text i * sty
   move 10 5 + i * 10
   line 95 5 + i * 10
.
stx = x[n] div 9
for i range0 10
   move i * 9 + 10 1
   text i * stx
   move i * 9 + 10 5
   line i * 9 + 10 97
.
color 900
linewidth 0.5
for i = 1 to n
   x = x[i] * 9 / stx + 10
   y = y[i] / sty * 10 + 5
   if i = 1
      move x y
   else
      line x y
   .
.
*
* Polyspiral
*
@ https://rosettacode.org/wiki/Polyspiral@Task
*
color 944
linewidth 0.3
on animate
   clear
   incr = (incr + 0.05) mod 360
   x1 = 50
   y1 = 50
   length = 1
   angle = incr
   move x1 y1
   for i = 1 to 150
      x2 = x1 + cos angle * length
      y2 = y1 + sin angle * length
      line x2 y2
      x1 = x2
      y1 = y2
      length += 1
      angle = (angle + incr) mod 360
   .
.
*
* Primality by trial division
*
@ https://rosettacode.org/wiki/Primality_by_trial_division@Task
*
func isprim n .
   if n < 2
      return 0
   .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
*
* Prime decomposition
*
@ https://rosettacode.org/wiki/Prime_decomposition@Task
*
proc decompose num . primes[] .
   primes[] = [ ]
   t = 2
   while t * t <= num
      if num mod t = 0
         primes[] &= t
         num = num / t
      else
         t += 1
      .
   .
   primes[] &= num
.
decompose 9007199254740991 r[]
print r[]
*
* Pseudo-random numbers/Middle-square method
*
@ https://rosettacode.org/wiki/Pseudo-random_numbers/Middle-square_method@Task
*
global seed .
seed = 675248
func rand .
   strSeed$ = seed
   s$ = seed * seed
   while not len s$ = len strSeed$ * 2
      s$ = "0" & s$
   .
   seed = number substr s$ (len strSeed$ / 2 + 1) len strSeed$
   randNum = seed
   return randNum
.
for i = 1 to 5
   print rand
.
*
* Pythagoras tree
*
@ https://rosettacode.org/wiki/Pythagoras_tree@Task
*
proc tree x1 y1 x2 y2 depth . .
   if depth < 8
      dx = x2 - x1
      dy = y1 - y2
      x3 = x2 + dy
      y3 = y2 + dx
      x4 = x1 + dy
      y4 = y1 + dx
      x5 = x4 + 0.5 * (dx + dy)
      y5 = y4 + 0.5 * (dx - dy)
      color3 0.3 0.2 + depth / 18 0.1
      polygon [ x1 y1 x2 y2 x3 y3 x4 y4 ]
      polygon [ x3 y3 x4 y4 x5 y5 ]
      tree x4 y4 x5 y5 depth + 1
      tree x5 y5 x3 y3 depth + 1
   .
.
tree 41 10 59 10 0
*
* Quickselect algorithm
*
@ https://rosettacode.org/wiki/Quickselect_algorithm@Task
*
proc qselect k . list[] res .
   # 
   subr partition
      mid = left
      for i = left + 1 to right
         if list[i] < list[left]
            mid += 1
            swap list[i] list[mid]
         .
      .
      swap list[left] list[mid]
   .
   left = 1
   right = len list[]
   while left < right
      partition
      if mid < k
         left = mid + 1
      elif mid > k
         right = mid - 1
      else
         left = right
      .
   .
   res = list[k]
.
d[] = [ 9 8 7 6 5 0 1 2 3 4 ]
for i = 1 to len d[]
   qselect i d[] r
   print r
.
*
* Quine
*
@ https://rosettacode.org/wiki/Quine@Task
*
S$ = "print strchar 83 & strchar 36 & strchar 32 & strchar 61 & strchar 32 & strchar 34 & S$ & strchar 34 & strchar 10 & S$"
print strchar 83 & strchar 36 & strchar 32 & strchar 61 & strchar 32 & strchar 34 & S$ & strchar 34 & strchar 10 & S$
*
* Random numbers
*
@ https://rosettacode.org/wiki/Random_numbers@Task
*
for i = 1 to 1000
  a[] &= 1 + 0.5 * sqrt (-2 * logn randomf) * cos (360 * randomf)
.
print a[]
*
* Real constants and functions
*
@ https://rosettacode.org/wiki/Real_constants_and_functions@Task
*
x = 1.5
# calculate e
e = pow 3 (1 / logn 3)
numfmt 4 0
# e
print e
# square root
print sqrt x
# natural logarithm
print logn x
# exponential
print pow e x
# absolute value
print abs x
# floor
print floor x
# ceiling
if x > floor x
   print floor x + 1
else
   print x
end
# power
print pow 2 x
*
* Recaman's sequence
*
@ https://rosettacode.org/wiki/Recaman's_sequence@Task
*
arrbase a[] 0
arrbase seen[] 0
len seen[] 100
# 
a[] &= 0
seen[0] = 1
i = 1
repeat
   h = a[i - 1] - i
   if h <= 0 or seen[h] = 1
      h = a[i - 1] + i
   .
   until seen[h] = 1
   seen[h] = 1
   a[] &= h
   if i = 14
      print a[]
   .
   i += 1
.
print h
*
* Remove duplicate elements
*
@ https://rosettacode.org/wiki/Remove_duplicate_elements@Task
*
a[] = [ 1 2 1 4 5 2 15 1 3 4 ]
for a in a[]
   found = 0
   for b in b[]
      if a = b
         found = 1
         break 1
      .
   .
   if found = 0
      b[] &= a
   .
.
print b[]
*
* Return multiple values
*
@ https://rosettacode.org/wiki/Return_multiple_values@Task
*
proc addSubtract a b . sum diff .
   sum = a + b
   diff = a - b
.
addSubtract 7 5 sum diff
print "Sum: " & sum
print "Difference: " & diff
*
* Reverse a string
*
@ https://rosettacode.org/wiki/Reverse_a_string@Task
*
func$ reverse s$ .
   a$[] = strchars s$
   for i = 1 to len a$[] div 2
      swap a$[i] a$[len a$[] - i + 1]
   .
   return strjoin a$[]
.
print reverse "hello"
*
* Roman numerals/Decode
*
@ https://rosettacode.org/wiki/Roman_numerals/Decode@Task
*
func rom2dec rom$ .
   symbols$[] = [ "M" "D" "C" "L" "X" "V" "I" ]
   values[] = [ 1000 500 100 50 10 5 1 ]
   val = 0
   for dig$ in strchars rom$
      for i = 1 to len symbols$[]
         if symbols$[i] = dig$
            v = values[i]
         .
      .
      val += v
      if oldv < v
         val -= 2 * oldv
      .
      oldv = v
   .
   return val
.
print rom2dec "MCMXC"
print rom2dec "MMVIII"
print rom2dec "MDCLXVI"
*
* Roman numerals/Encode
*
@ https://rosettacode.org/wiki/Roman_numerals/Encode@Task
*
func$ dec2rom dec .
   values[] = [ 1000 900 500 400 100 90 50 40 10 9 5 4 1 ]
   symbol$[] = [ "M" "CM" "D" "CD" "C" "XC" "L" "XL" "X" "IX" "V" "IV" "I" ]
   for i = 1 to len values[]
      while dec >= values[i]
         rom$ &= symbol$[i]
         dec -= values[i]
      .
   .
   return rom$
.
print dec2rom 1990
print dec2rom 2008
print dec2rom 1666
*
* Rot-13
*
@ https://rosettacode.org/wiki/Rot-13@Task
*
func$ rot13 str$ .
   for c$ in strchars str$
      code = strcode c$
      if code >= 65 and code <= 90
         encCode = code + 13
         if encCode > 90
            encCode = 64 + encCode - 90
         .
      elif code >= 97 and code <= 122
         encCode = code + 13
         if encCode > 122
            encCode = 96 + encCode - 122
         .
      else
         encCode = code
      .
      encStr$ &= strchar encCode
   .
   return encStr$
.
print rot13 "Rosetta Code"
*
* Run-length encoding
*
@ https://rosettacode.org/wiki/Run-length_encoding@Task
*
func$ rlenc in$ .
   for c$ in strchars in$
      if c$ = c0$
         cnt += 1
      else
         if cnt > 0
            out$ &= cnt & c0$ & " "
         .
         c0$ = c$
         cnt = 1
      .
   .
   out$ &= cnt & c0$
   return out$
.
func$ rldec in$ .
   for h$ in strsplit in$ " "
      c$ = substr h$ len h$ 1
      for i to number h$
         out$ &= c$
      .
   .
   return out$
.
s$ = input
print s$
s$ = rlenc s$
print s$
s$ = rldec s$
print s$
# 
input_data
WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
*
* Sattolo cycle
*
@ https://rosettacode.org/wiki/Sattolo_cycle@Task
*
proc sattolo_cycle . a[] .
   for i = len a[] downto 2
      r = random (i - 1)
      swap a[r] a[i]
   .
.
arr[] = [ 1 2 3 ]
sattolo_cycle arr[]
print arr[]
*
* Self-describing numbers
*
@ https://rosettacode.org/wiki/Self-describing_numbers@Task
*
proc test d[] . .
   cnt[] = [ 0 0 0 0 0 0 0 0 0 0 ]
   for d in d[]
      cnt[d + 1] += 1
   .
   for i to len d[]
      if cnt[i] <> d[i]
         break 2
      .
   .
   # found
   for d in d[]
      write d
   .
   print ""
.
proc backtr ind max . d[] .
   if ind > len d[]
      test d[]
      break 1
   .
   for d = 0 to max
      if d < 10
         d[ind] = d
         backtr ind + 1 max - d d[]
      .
   .
.
for i = 1 to 10
   len d[] i
   backtr 1 len d[] d[]
.
*
* Sequence of primes by trial division
*
@ https://rosettacode.org/wiki/Sequence_of_primes_by_trial_division@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   while i <= sqrt n
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
proc primeSequ first last . sequ[] .
   for i = first to last
      if prime i = 1
         sequ[] &= i
      .
   .
.
primeSequ 2 100 seq[]
print seq[]
*
* Seven-sided dice from five-sided dice
*
@ https://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice@Task
*
func dice5 .
   return random 5
.
func dice25 .
   return (dice5 - 1) * 5 + dice5
.
func dice7a .
   return dice25 mod1 7
.
func dice7b .
   repeat
      h = dice25
      until h <= 21
   .
   return h mod1 7
.
numfmt 3 0
n = 1000000
len dist[] 7
# 
proc checkdist . .
   for i to len dist[]
      h = dist[i] / n * 7
      if abs (h - 1) > 0.01
         bad = 1
      .
      dist[i] = 0
      print h
   .
   if bad = 1
      print "-> not uniform"
   else
      print "-> uniform"
   .
.
# 
for i to n
   dist[dice7a] += 1
.
checkdist
# 
print ""
for i to n
   dist[dice7b] += 1
.
checkdist
*
* Shoelace formula for polygonal area
*
@ https://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area@Task
*
proc shoelace . p[][] res .
   sum = 0
   for i = 1 to len p[][] - 1
      sum += p[i][1] * p[i + 1][2]
      sum -= p[i + 1][1] * p[i][2]
   .
   sum += p[i][1] * p[1][2]
   sum -= p[1][1] * p[i][2]
   res = abs sum / 2
.
data[][] = [ [ 3 4 ] [ 5 11 ] [ 12 8 ] [ 9 5 ] [ 5 6 ] ]
shoelace data[][] res
print res
*
* Show ASCII table
*
@ https://rosettacode.org/wiki/Show_ASCII_table@Task
*
numfmt 0 3
for i range0 16
   for j = 32 + i step 16 to 127
      if j = 32
         x$ = "Spc"
      elif j = 127
         x$ = "Del"
      else
         x$ = strchar j & "  "
      .
      write j & ": " & x$
   .
   print ""
.
*
* Sierpinski arrowhead curve
*
@ https://rosettacode.org/wiki/Sierpinski_arrowhead_curve@Task
*
x = 5
y = 10
ang = 60
linewidth 0.5
# 
proc curv o l a . .
   if o = 0
      x += cos ang * l
      y += sin ang * l
      line x y
   else
      o -= 1
      l /= 2
      curv o l (-a)
      ang += a
      curv o l a
      ang += a
      curv o l (-a)
   .
.
move x y
curv 7 90 -60
*
* Sierpinski carpet
*
@ https://rosettacode.org/wiki/Sierpinski_carpet@Task
*
proc carp x y sz . .
   move x - sz / 2 y - sz / 2
   rect sz sz
   if sz > 0.5
      h = sz / 3
      carp x - sz y - sz h
      carp x - sz y h
      carp x - sz y + sz h
      carp x + sz y - sz h
      carp x + sz y h
      carp x + sz y + sz h
      carp x y - sz h
      carp x y + sz h
   .
.
background 000
clear
color 633
carp 50 50 100 / 3
*
* Sierpinski pentagon
*
@ https://rosettacode.org/wiki/Sierpinski_pentagon@Task
*
order = 5
# 
clear
linewidth 0.2
scale = 1 / (2 + cos 72 * 2)
# 
proc pentagon x y side depth . .
   if depth = 0
      move x y
      for angle = 0 step 72 to 288
         x += cos angle * side
         y += sin angle * side
         line x y
      .
   else
      side *= scale
      dist = side + side * cos 72 * 2
      for angle = 0 step 72 to 288
         x += cos angle * dist
         y += sin angle * dist
         pentagon x y side depth - 1
      .
   .
.
pentagon 25 15 50 order - 1
*
* Sierpinski triangle/Graphical
*
@ https://rosettacode.org/wiki/Sierpinski_triangle/Graphical@Task
*
proc triang lev x y size . .
   if lev = 0
      move x y
      circle 0.15
   else
      lev -= 1
      size /= 2
      triang lev x + size y size
      triang lev x + size / 2 y + size size
      triang lev x y size
   .
.
triang 8 5 5 90
*
* Sieve of Eratosthenes
*
@ https://rosettacode.org/wiki/Sieve_of_Eratosthenes@Task
*
len is_divisible[] 100
max = sqrt len is_divisible[]
for d = 2 to max
   if is_divisible[d] = 0
      for i = d * d step d to len is_divisible[]
         is_divisible[i] = 1
      .
   .
.
for i = 2 to len is_divisible[]
   if is_divisible[i] = 0
      print i
   .
.
*
* Simple turtle graphics
*
@ https://rosettacode.org/wiki/Simple_turtle_graphics@Task
*
subr home
   deg = 0
   x = 50
   y = 50
   down = 0
   move x y
.
home
# 
proc forward n . .
   x += cos deg * n
   y += sin deg * n
   if down = 1
      line x y
   else
      move x y
   .
   sleep 0.1
.
proc turn a . .
   deg -= a
.
# 
proc house . .
   turn 180
   forward 45
   turn 180
   down = 1
   # 
   forward 30
   turn 90
   forward 30
   turn 90
   forward 30
   turn 90
   forward 30
   # 
   turn 30
   forward 30
   turn 120
   forward 30
   home
.
house
# 
proc bar a[] . .
   turn 90
   forward 30
   turn -90
   down = 1
   for i to len a[]
      max = higher max a[i]
   .
   for i to len a[]
      h = a[i] / max * 50
      w = 45 / len a[]
      turn -90
      forward h
      turn 90
      forward w
      turn 90
      forward h
      turn -90
   .
   turn 180
   forward 45
   home
.
bar [ 50 33 200 130 50 ]
*
* Snake
*
@ https://rosettacode.org/wiki/Snake@Task
*
subr fruit
   rx = (random 20 - 1) * 5 + 2.5
   ry = (random 20 - 1) * 5 + 2.5
.
subr start
   fruit
   game = 1
   sx[] = [ 52.5 0 0 0 0 ]
   sy[] = [ 52.5 0 0 0 0 ]
   dir = random 4
   timer 0
.
background 242
move 30 70
clear
color 997
text "SNAKE"
textsize 5
move 10 40
text "Arrow keys for controlling"
move 10 30
text "Press space to to start"
# 
on key
   if keybkey = "ArrowUp" and dir <> 3
      dir = 1
   elif keybkey = "ArrowRight" and dir <> 4
      dir = 2
   elif keybkey = "ArrowDown" and dir <> 1
      dir = 3
   elif keybkey = "ArrowLeft" and dir <> 2
      dir = 4
   elif keybkey = " " and game = 0
      start
   .
.
on timer
   clear
   color 997
   move 2 96
   text "Score: " & 10 * len sx[] - 50
   color 966
   move rx ry
   circle 1.5
   # 
   sx = sx[1] ; sy = sy[1]
   if dir = 1
      sy += 5
   elif dir = 2
      sx += 5
   elif dir = 3
      sy -= 5
   elif dir = 4
      sx -= 5
   .
   if sx < 0 or sx > 100 or sy < 0 or sy > 100
      game = 0
   .
   color 494
   for i = len sx[] downto 2
      if sx = sx[i] and sy = sy[i]
         game = 0
      .
      sx[i] = sx[i - 1]
      sy[i] = sy[i - 1]
      if sx[i] > 0
         move sx[i] sy[i]
         circle 2.5
      .
   .
   move sx sy
   circle 2.5
   color 000
   if dir = 2 or dir = 4
      move sx sy + 1
      circle 0.5
      move sx sy - 1
      circle 0.5
   else
      move sx + 1 sy
      circle 0.5
      move sx - 1 sy
      circle 0.5
   .
   if sx = rx and sy = ry
      len sx[] len sx[] + 3
      len sy[] len sy[] + 3
      fruit
   .
   sx[1] = sx ; sy[1] = sy
   if game = 1
      timer 0.15
   else
      color 997
      move 10 10
      text "Press space for new game"
   .
.
*
* Solve triangle solitare puzzle
*
@ https://rosettacode.org/wiki/Solve_triangle_solitare_puzzle@Task
*
brd$[] = strchars "
┏━━━━━━━━━┓
┃    ·    ┃
┃   ● ●   ┃
┃  ● ● ●  ┃
┃ ● ● ● ● ┃
┃● ● ● ● ●┃
┗━━━━━━━━━┛"
proc solve . solution$ .
   solution$ = ""
   for pos = 1 to len brd$[]
      if brd$[pos] = "●"
         npegs += 1
         for dir in [ -13 -11 2 13 11 -2 ]
            if brd$[pos + dir] = "●" and brd$[pos + 2 * dir] = "·"
               brd$[pos] = "·"
               brd$[pos + dir] = "·"
               brd$[pos + 2 * dir] = "●"
               solve solution$
               brd$[pos] = "●"
               brd$[pos + dir] = "●"
               brd$[pos + 2 * dir] = "·"
               if solution$ <> ""
                  solution$ = strjoin brd$[] & solution$
                  break 3
               .
            .
         .
      .
   .
   if npegs = 1
      solution$ = strjoin brd$[]
   .
.
solve solution$
print solution$
*
* Sorting algorithms/Bubble sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort@Task
*
proc bubbleSort . a[] .
   repeat
      changed = 0
      for i = 1 to len a[] - 1
         if a[i] > a[i + 1]
            swap a[i] a[i + 1]
            changed = 1
         .
      .
      until changed = 0
   .
.
array[] = [ 5 1 19 25 12 1 14 7 ]
bubbleSort array[]
print array[]
*
* Sorting algorithms/Heapsort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Heapsort@Task
*
proc sort . d[] .
   n = len d[]
   # make heap
   for i = 2 to n
      if d[i] > d[(i + 1) div 2]
         j = i
         repeat
            h = (j + 1) div 2
            until d[j] <= d[h]
            swap d[j] d[h]
            j = h
         .
      .
   .
   for i = n downto 2
      swap d[1] d[i]
      j = 1
      ind = 2
      while ind < i
         if ind + 1 < i and d[ind + 1] > d[ind]
            ind += 1
         .
         if d[j] < d[ind]
            swap d[j] d[ind]
         .
         j = ind
         ind = 2 * j
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Insertion sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort@Task
*
proc sort . d[] .
   for i = 2 to len d[]
      h = d[i]
      j = i - 1
      while j >= 1 and h < d[j]
         d[j + 1] = d[j]
         j -= 1
      .
      d[j + 1] = h
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Merge sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Merge_sort@Task
*
proc sort . d[] .
   len tmp[] len d[]
   sz = 1
   while sz < len d[]
      swap tmp[] d[]
      left = 1
      while left < len d[]
         # merge
         mid = left + sz - 1
         if mid > len d[]
            mid = len d[]
         .
         right = mid + sz
         if right > len d[]
            right = len d[]
         .
         l = left
         r = mid + 1
         for i = left to right
            if r > right or l <= mid and tmp[l] < tmp[r]
               d[i] = tmp[l]
               l += 1
            else
               d[i] = tmp[r]
               r += 1
            .
         .
         left += 2 * sz
      .
      sz *= 2
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Quicksort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Quicksort@Task
*
proc qsort left right . d[] .
   while left < right
      # partition 
      piv = d[left]
      mid = left
      for i = left + 1 to right
         if d[i] < piv
            mid += 1
            swap d[i] d[mid]
         .
      .
      swap d[left] d[mid]
      # 
      if mid < (right + left) / 2
         qsort left mid - 1 d[]
         left = mid + 1
      else
         qsort mid + 1 right d[]
         right = mid - 1
      .
   .
.
proc sort . d[] .
   qsort 1 len d[] d[]
.
d[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort d[]
print d[]
*
* Sorting algorithms/Radix sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Radix_sort@Task
*
proc sort . d[] .
   # radix = 10
   radix = 256
   max = 0
   for di = 1 to len d[]
      if d[di] > max
         max = d[di]
      .
   .
   len buck[][] radix
   pos = 1
   while pos <= max
      for i = 1 to radix
         len buck[i][] 0
      .
      for di = 1 to len d[]
         h = d[di] div pos mod radix + 1
         buck[h][] &= d[di]
      .
      di = 1
      for i = 1 to radix
         for j = 1 to len buck[i][]
            d[di] = buck[i][j]
            di += 1
         .
      .
      pos *= radix
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Selection sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Selection_sort@Task
*
proc sort . d[] .
   for i = 1 to len d[] - 1
      for j = i + 1 to len d[]
         if d[j] < d[i]
            swap d[j] d[i]
         .
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Steffensen's method
*
@ https://rosettacode.org/wiki/Steffensen's_method@Task
*
func deCasteljau c0 c1 c2 t .
   s = 1 - t
   c01 = s * c0 + t * c1
   c12 = s * c1 + t * c2
   return s * c01 + t * c12
.
func xConvexLeftPar t .
   return deCasteljau 2 (-8) 2 t
.
func yConvexRightPar t .
   return deCasteljau 1 2 3 t
.
func implicitEq x y .
   return 5 * x * x + y - 5
.
func f t r .
   x = xConvexLeftPar t
   y = yConvexRightPar t
   r = implicitEq x y
   return r + t
.
func aitken p0 .
   p1 = f p0 p1
   p2 = f p1 p2
   p1m0 = p1 - p0
   return p0 - p1m0 * p1m0 / (p2 - 2 * p1 + p0)
.
func steffAitken p0 tol maxiter .
   for i to maxiter
      p = aitken p0
      if abs (p - p0) < tol
         return p
      .
      p0 = p
   .
   return number "nan"
.
for i to 11
   numfmt 1 0
   write "t0 = " & t0 & " : "
   t = steffAitken t0 0.00000001 1000
   numfmt 3 0
   if t <> t
      # nan
      print "no answer"
   else
      x = xConvexLeftPar t
      y = yConvexRightPar t
      r = implicitEq x y
      if abs r <= 0.000001
         print "intersection at (" & x & " " & y & ")"
      else
         print "spurious solution"
      .
   .
   t0 += 0.1
.
*
* String append
*
@ https://rosettacode.org/wiki/String_append@Task
*
a$ = "hello"
a$ &= " world"
print a$
*
* String case
*
@ https://rosettacode.org/wiki/String_case@Task
*
func$ toUpper s$ .
   for c$ in strchars s$
      code = strcode c$
      if code >= 97 and code <= 122
         code -= 32
      .
      res$ &= strchar code
   .
   return res$
.
func$ toLower s$ .
   for c$ in strchars s$
      code = strcode c$
      if code >= 65 and code <= 90
         code += 32
      .
      res$ &= strchar code
   .
   return res$
.
string$ = "alphaBETA"
print string$
print toUpper string$
print toLower string$
*
* String comparison
*
@ https://rosettacode.org/wiki/String_comparison@Task
*
a$ = "hello"
if a$ = "hello"
   print "equal"
.
if a$ <> "hello2"
   print "not equal"
.
if strcmp a$ "hello" = 0
   print "equal"
.
if strcmp a$ "world" < 0
   print "lexically before"
.
if number "10" > number "2"
   print "numerically after"
.
*
* String concatenation
*
@ https://rosettacode.org/wiki/String_concatenation@Task
*
a$ = "hello"
b$ = a$ & " world"
print b$
*
* String length
*
@ https://rosettacode.org/wiki/String_length@Task
*
# 5
print len "møøse"
# 7
print len "𝔘𝔫𝔦𝔠𝔬𝔡𝔢"
# 8
print len "J̲o̲s̲é̲"
# 1
print len "😀"
*
* String prepend
*
@ https://rosettacode.org/wiki/String_prepend@Task
*
string$ = "Lang"
string$ = "Easy" & string$
print string$
*
* Substring
*
@ https://rosettacode.org/wiki/Substring@Task
*
a$ = "2019-05-22 22:54:22"
print substr a$ 12 5
print substr a$ 12 -1
*
* Substring/Top and tail
*
@ https://rosettacode.org/wiki/Substring/Top_and_tail@Task
*
string$ = "EasyLang"
print substr string$ 1 len string$ - 1 # Without the last character
print substr string$ 2 len string$ - 1 # Without the first character
print substr string$ 2 len string$ - 2 # Without the first and last characters
*
* Sudoku
*
@ https://rosettacode.org/wiki/Sudoku@Task
*
len row[] 90
len col[] 90
len box[] 90
len grid[] 82
# 
proc init . .
   for pos = 1 to 81
      if pos mod 9 = 1
         s$ = input
         if s$ = ""
            s$ = input
         .
         len inp[] 0
         for i = 1 to len s$
            if substr s$ i 1 <> " "
               inp[] &= number substr s$ i 1
            .
         .
      .
      dig = number inp[(pos - 1) mod 9 + 1]
      if dig > 0
         grid[pos] = dig
         r = (pos - 1) div 9
         c = (pos - 1) mod 9
         b = r div 3 * 3 + c div 3
         row[r * 10 + dig] = 1
         col[c * 10 + dig] = 1
         box[b * 10 + dig] = 1
      .
   .
.
init
# 
proc display . .
   for i = 1 to 81
      write grid[i] & " "
      if i mod 3 = 0
         write " "
      .
      if i mod 9 = 0
         print ""
      .
      if i mod 27 = 0
         print ""
      .
   .
.
# 
proc solve pos . .
   while grid[pos] <> 0
      pos += 1
   .
   if pos > 81
      # solved
      display
      break 1
   .
   r = (pos - 1) div 9
   c = (pos - 1) mod 9
   b = r div 3 * 3 + c div 3
   r *= 10
   c *= 10
   b *= 10
   for d = 1 to 9
      if row[r + d] = 0 and col[c + d] = 0 and box[b + d] = 0
         grid[pos] = d
         row[r + d] = 1
         col[c + d] = 1
         box[b + d] = 1
         solve pos + 1
         row[r + d] = 0
         col[c + d] = 0
         box[b + d] = 0
      .
   .
   grid[pos] = 0
.
solve 1
# 
input_data
5 3 0  0 2 4  7 0 0
0 0 2  0 0 0  8 0 0
1 0 0  7 0 3  9 0 2

0 0 8  0 7 2  0 4 9
0 2 0  9 8 0  0 7 0
7 9 0  0 0 0  0 8 0

0 0 0  0 3 0  5 0 6
9 6 0  0 1 0  3 0 0
0 5 0  6 9 0  0 1 0
*
* Sum and product of an array
*
@ https://rosettacode.org/wiki/Sum_and_product_of_an_array@Task
*
array[] = [ 5 1 19 25 12 1 14 7 ]
product = 1
for item in array[]
   sum += item
   product *= item
.
print "Sum: " & sum
print "Product: " & product
*
* Sum digits of an integer
*
@ https://rosettacode.org/wiki/Sum_digits_of_an_integer@Task
*
func sumdig s$ .
   for c$ in strchars s$
      h = strcode c$ - 48
      if h >= 10
         h -= 39
      .
      r += h
   .
   return r
.
print sumdig "1"
print sumdig "1234"
print sumdig "fe"
print sumdig "f0e"
*
* Sum of a series
*
@ https://rosettacode.org/wiki/Sum_of_a_series@Task
*
numfmt 8 0
for i = 1 to 1000
   s += 1 / (i * i)
.
print s
*
* Sum of squares
*
@ https://rosettacode.org/wiki/Sum_of_squares@Task
*
nums[] = [ 1 2 3 4 5 ]
for v in nums[]
   sum += v * v
.
print sum
*
* Summarize primes
*
@ https://rosettacode.org/wiki/Summarize_primes@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   while i <= sqrt n
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
for i = 2 to 999
   if prime i = 1
      ind += 1
      sum += i
      if prime sum = 1
         print ind & ": " & sum
      .
   .
.
*
* Symmetric difference
*
@ https://rosettacode.org/wiki/Symmetric_difference@Task
*
a$[] = [ "John" "Bob" "Mary" "Serena" ]
b$[] = [ "Jim" "Mary" "John" "Bob" ]
for i to 2
   for a$ in a$[]
      for b$ in b$[]
         if a$ = b$
            break 1
         .
      .
      if a$ <> b$
         for c$ in c$[]
            if c$ = a$
               break 1
            .
         .
         if c$ <> a$
            c$[] &= a$
         .
      .
   .
   swap a$[] b$[]
.
print c$[]
*
* System time
*
@ https://rosettacode.org/wiki/System_time@Task
*
print timestr systime
*
* Temperature conversion
*
@ https://rosettacode.org/wiki/Temperature_conversion@Task
*
k = number input
print k & " °K"
print k - 273.15 & " °C"
print k * 1.8 - 459.67 & " °F"
print k * 1.8 & " °R"
*
* The Name Game
*
@ https://rosettacode.org/wiki/The_Name_Game@Task
*
proc toLowercase string$ . result$ .
   for i = 1 to len string$
      code = strcode substr string$ i 1
      if code >= 65 and code <= 90
         code += 32
      .
      result$ &= strchar code
   .
.
proc findInStrArray array$[] item$ . index .
   for i = 1 to len array$[]
      if array$[i] = item$
         index = i
         break 2
      .
   .
   index = 0
.
# This version actually handles consonant clusters
name$ = input
toLowercase name$ lowerName$
vowels$[] = [ "a" "e" "i" "o" "u" ]
for i = 1 to len lowerName$
   letter$ = substr lowerName$ i 1
   findInStrArray vowels$[] letter$ index
   if index <> 0
      truncName1$ = substr lowerName$ i len lowerName$
      break 1
   .
   truncName1$ = ""
.
firstLetter$ = substr lowerName$ 1 1
if firstLetter$ <> "b"
   b$ = "b"
.
if firstLetter$ <> "f"
   f$ = "f"
.
if firstLetter$ <> "m"
   m$ = "m"
.
if b$ = "" or f$ = "" or m$ = ""
   truncName2$ = substr lowerName$ 2 len lowerName$
.
# Determine the appropriate name for each line
if b$ = ""
   bName$ = truncName2$
else
   bName$ = truncName1$
.
if f$ = ""
   fName$ = truncName2$
else
   fName$ = truncName1$
.
if m$ = ""
   mName$ = truncName2$
else
   mName$ = truncName1$
.
# Print the song
print name$ & ", " & name$ & ", " & "bo-" & b$ & bName$
print "Banana-fana fo-" & f$ & fName$
print "Fee-fi-mo-" & m$ & mName$
print name$ & "!"
*
* The Twelve Days of Christmas
*
@ https://rosettacode.org/wiki/The_Twelve_Days_of_Christmas@Task
*
days$[] = [ "first" "second" "third" "forth" "fifth" "sixth" "seventh" "eighth" "ninth" "tenth" "eleventh" "twelfth" ]
gifts$[] &= "Twelve drummers drumming"
gifts$[] &= "Eleven pipers piping"
gifts$[] &= "Ten lords a-leaping"
gifts$[] &= "Nine ladies dancing"
gifts$[] &= "Eight maids a-milking"
gifts$[] &= "Seven swans a-swimming"
gifts$[] &= "Six geese a-laying"
gifts$[] &= "Five golden rings"
gifts$[] &= "Four calling birds"
gifts$[] &= "Three french hens"
gifts$[] &= "Two turtle doves and"
gifts$[] &= "A partridge in a pear tree."
for i = 1 to 12
   print "On the " & days$[i] & " day of Christmas,"
   print "My true love gave to me:"
   for j = 13 - i to 12
      print gifts$[j]
   .
   print ""
.
*
* Tic-tac-toe
*
@ https://rosettacode.org/wiki/Tic-tac-toe@Task
*
# Tic tac toe
# 
len f[] 9
state = 0
textsize 14
# 
proc init . .
   linewidth 2
   clear
   color 666
   move 34 96
   line 34 20
   move 62 96
   line 62 20
   move 10 72
   line 86 72
   move 10 44
   line 86 44
   linewidth 2.5
   for i = 1 to 9
      f[i] = 0
   .
   if state = 1
      timer 0.2
   .
.
proc draw ind . .
   c = (ind - 1) mod 3
   r = (ind - 1) div 3
   x = c * 28 + 20
   y = r * 28 + 30
   if f[ind] = 4
      color 900
      move x - 7 y - 7
      line x + 7 y + 7
      move x + 7 y - 7
      line x - 7 y + 7
   elif f[ind] = 1
      color 009
      move x y
      circle 10
      color -2
      circle 7.5
   .
.
proc sum3 a d . st .
   for i = 1 to 3
      s += f[a]
      a += d
   .
   if s = 3
      st = -1
   elif s = 12
      st = 1
   .
.
proc rate . res done .
   res = 0
   for i = 1 step 3 to 7
      sum3 i 1 res
   .
   for i = 1 to 3
      sum3 i 3 res
   .
   sum3 1 4 res
   sum3 3 2 res
   cnt = 1
   for i = 1 to 9
      if f[i] = 0
         cnt += 1
      .
   .
   res *= cnt
   done = 1
   if res = 0 and cnt > 1
      done = 0
   .
.
proc minmax player alpha beta . rval rmov .
   rate rval done
   if done = 1
      if player = 1
         rval = -rval
      .
   else
      rval = alpha
      start = random 9
      mov = start
      repeat
         if f[mov] = 0
            f[mov] = player
            minmax (5 - player) (-beta) (-rval) val h
            val = -val
            f[mov] = 0
            if val > rval
               rval = val
               rmov = mov
            .
         .
         mov = mov mod 9 + 1
         until mov = start or rval >= beta
      .
   .
.
proc show_result val . .
   color 555
   move 16 4
   if val < 0
      # this never happens
      text "You won"
   elif val > 0
      text "You lost"
   else
      text "Tie"
   .
   state += 2
.
proc computer . .
   minmax 4 -11 11 val mov
   f[mov] = 4
   draw mov
   rate val done
   state = 0
   if done = 1
      show_result val
   .
.
proc human . .
   mov = floor ((mouse_x - 6) / 28) + 3 * floor ((mouse_y - 16) / 28) + 1
   if f[mov] = 0
      f[mov] = 1
      draw mov
      state = 1
      timer 0.5
   .
.
on timer
   rate val done
   if done = 1
      show_result val
   else
      computer
   .
.
on mouse_down
   if state = 0
      if mouse_x > 6 and mouse_x < 90 and mouse_y > 16
         human
      .
   elif state >= 2
      state -= 2
      init
   .
.
init
*
* Towers of Hanoi
*
@ https://rosettacode.org/wiki/Towers_of_Hanoi@Task
*
proc hanoi n src dst aux . .
   if n >= 1
      hanoi n - 1 src aux dst
      print "Move " & src & " to " & dst
      hanoi n - 1 aux dst src
   .
.
hanoi 5 1 2 3
*
* Two bullet roulette
*
@ https://rosettacode.org/wiki/Two_bullet_roulette@Task
*
len cyl[] 6
proc rshift . .
   h = cyl[6]
   for i = 6 downto 2
      cyl[i] = cyl[i - 1]
   .
   cyl[1] = h
.
proc unload . .
   for i = 1 to 6
      cyl[i] = 0
   .
.
proc load . .
   while cyl[1] = 1
      rshift
   .
   cyl[1] = 1
   rshift
.
proc spin . .
   lim = random 6
   for i = 1 to lim - 1
      rshift
   .
.
func fire .
   shot = cyl[1]
   rshift
   return shot
.
func method m[] .
   unload
   for m in m[]
      if m = 1
         load
      elif m = 2
         spin
      elif m = 3
         if fire = 1
            return 1
         .
      .
   .
   return 0
.
method$[] = [ "load" "spin" "fire" ]
proc test m[] . .
   n = 100000
   for i = 1 to n
      sum += method m[]
   .
   for i = 1 to len m[]
      write method$[m[i]] & " "
   .
   print "-> " & 100 * sum / n & "% death"
.
test [ 1 2 1 2 3 2 3 ]
test [ 1 2 1 2 3 3 ]
test [ 1 1 2 3 2 3 ]
test [ 1 1 2 3 3 ]
*
* Two sum
*
@ https://rosettacode.org/wiki/Two_sum@Task
*
proc twoSum sum . array[] pair[] .
   i = 1
   j = len array[]
   # The array remains empty if no sum is found
   pair[] = [ ]
   repeat
      if array[i] + array[j] = sum
         pair[] = [ i j ]
         break 2
      elif array[i] + array[j] > sum
         j -= 1
      elif array[i] + array[j] < sum
         i += 1
      .
      until i = j
   .
.
numbers[] = [ 0 2 11 19 90 ]
call twoSum 21 numbers[] pair[]
print "[" & pair[1] & ", " & pair[2] & "]"
*
* User input/Text
*
@ https://rosettacode.org/wiki/User_input/Text@Task
*
write "Enter a string: "
a$ = input
print ""
repeat
  write "Enter the number 75000: "
  h = number input
  print ""
  until h = 75000
.
print a$ & " " & h
*
* Van der Corput sequence
*
@ https://rosettacode.org/wiki/Van_der_Corput_sequence@Task
*
func vdc b n .
   s = 1
   while n > 0
      s *= b
      m = n mod b
      v += m / s
      n = n div b
   .
   return v
.
for b = 2 to 5
   write "base " & b & ":"
   for n range0 10
      write " " & vdc b n
   .
   print ""
.
*
* Van Eck sequence
*
@ https://rosettacode.org/wiki/Van_Eck_sequence@Task
*
len arr[] 1000
for n to 1000 - 1
   for m = n - 1 downto 1
      if arr[m] = arr[n]
         arr[n + 1] = n - m
         break 1
      .
   .
.
for i to 10
   write arr[i] & " "
.
print ""
for i = 991 to 1000
   write arr[i] & " "
.
*
* Variables
*
@ https://rosettacode.org/wiki/Variables@Task
*
# it is statically typed
# 
# global number variable
n = 99
print n
# global array of numbers
a[] = [ 2.1 3.14 3 ]
# 
proc foo . .
   # i is local, because it is first used in the function  
   for i = 1 to len a[]
      print a[i]
   .
.
foo
# 
# string
domain$ = "easylang.dev"
print domain$
# 
# array of strings
fruits$[] = [ "apple" "banana" "orange" ]
print fruits$[]
*
* Vibrating rectangles
*
@ https://rosettacode.org/wiki/Vibrating_rectangles@Task
*
on timer
  sz -= 2
  if sz < 0
    sz = 49
    color random 1000 - 1
  .
  move 50 - sz 50 - sz
  line 50 + sz 50 - sz
  line 50 + sz 50 + sz
  line 50 - sz 50 + sz
  line 50 - sz 50 - sz
  timer 0.2
.
timer 0.2
*
* Vigenère cipher
*
@ https://rosettacode.org/wiki/Vigenère_cipher@Task
*
func$ encr txt$ pw$ d .
   txt$[] = strchars txt$
   for c$ in strchars pw$
      pw[] &= strcode c$ - 65
   .
   for c$ in txt$[]
      c = strcode c$
      if c >= 97
         c -= 32
      .
      if c >= 65 and c <= 97
         pwi = (pwi + 1) mod1 len pw[]
         c = (c - 65 + d * pw[pwi]) mod 26 + 65
         r$ &= strchar c
      .
   .
   return r$
.
s$ = "Beware the Jabberwock, my son! The jaws that bite, the claws that catch!"
pw$ = "VIGENERECIPHER"
r$ = encr s$ pw$ 1
print r$
print encr r$ pw$ -1
*
* Wagstaff primes
*
@ https://rosettacode.org/wiki/Wagstaff_primes@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   while i <= sqrt n
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
pri = 1
while nwag <> 10
   pri += 2
   if prime pri = 1
      wag = (pow 2 pri + 1) / 3
      if prime wag = 1
         nwag += 1
         print pri & " => " & wag
      .
   .
.
*
* Water collected between towers
*
@ https://rosettacode.org/wiki/Water_collected_between_towers@Task
*
proc water h[] . .
   n = len h[]
   len left[] n
   len right[] n
   for i = 1 to n
      max = higher max h[i]
      left[i] = max
   .
   max = 0
   for i = n downto 1
      max = higher max h[i]
      right[i] = max
   .
   for i = 1 to n
      sum += (lower left[i] right[i]) - h[i]
   .
   print sum
.
repeat
   s$ = input
   until s$ = ""
   water number strsplit s$ " "
.
# 
input_data
1 5 3 7 2
5 3 7 2 6 4 5 9 1 2
2 6 3 5 2 8 1 4 2 2 5 3 5 7 4 1
5 5 5 5
5 6 7 8
8 7 7 6
6 7 10 7 6
*
* Word wrap
*
@ https://rosettacode.org/wiki/Word_wrap@Task
*
linew = 40
# 
ind = 1
repeat
   if ind > len words$[]
      inp$ = input
      words$[] = strsplit inp$ " "
      ind = 1
   .
   until inp$ = ""
   w$ = words$[ind]
   ind += 1
   if len out$ + len w$ + 1 <= linew
      if out$ <> ""
         out$ &= " "
      .
      out$ &= w$
   else
      print out$
      out$ = w$
   .
.
print out$
# 
input_data
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face. Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.’
*
* Zero to the zero power
*
@ https://rosettacode.org/wiki/Zero_to_the_zero_power@Task
*
print pow 0 0
`
function hook() {
	var dom = window.location.host
	tut.insertAdjacentHTML("beforeend", `
<p><hr><p>
The examples were created with <a href=..>${dom}<a>
<p><small>christof.kaser@gmail.com</small>
`)
}
</script>
