<!doctype html>
<meta charset=utf-8><title>Easylang - Rosetta Code</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<link rel="icon" href="../icon.png" type="image/x-png">

<div id=tut><b>Loading ...</b></div>
<script src=easy_code2.js></script>
<script src=easy_tut2.js></script>

<script>

txt_split = "\n*\n"

txt_tutor=String.raw`* Rosetta Code with Easylang
*
* 100 doors
*
@ https://rosettacode.org/wiki/100_doors@Task
*
len d[] 100
for p = 1 to 100
   i = p
   while i <= 100
      d[i] = 1 - d[i]
      i += p
   .
.
for i = 1 to 100
   if d[i] = 1
      print i
   .
.
*
* 100 prisoners
*
@ https://rosettacode.org/wiki/100_prisoners@Task
*
for i = 1 to 100
   drawer[] &= i
   sampler[] &= i
.
subr shuffle_drawer
   for i = len drawer[] downto 2
      r = random i
      swap drawer[r] drawer[i]
   .
.
subr play_random
   shuffle_drawer
   for prisoner = 1 to 100
      found = 0
      for i = 1 to 50
         r = random (100 - i)
         card = drawer[sampler[r]]
         swap sampler[r] sampler[100 - i - 1]
         if card = prisoner
            found = 1
            break 1
         .
      .
      if found = 0
         break 1
      .
   .
.
subr play_optimal
   shuffle_drawer
   for prisoner = 1 to 100
      reveal = prisoner
      found = 0
      for i = 1 to 50
         card = drawer[reveal]
         if card = prisoner
            found = 1
            break 1
         .
         reveal = card
      .
      if found = 0
         break 1
      .
   .
.
n = 10000
win = 0
for _ = 1 to n
   play_random
   win += found
.
print "random: " & 100.0 * win / n & "%"
# 
win = 0
for _ = 1 to n
   play_optimal
   win += found
.
print "optimal: " & 100.0 * win / n & "%"
*
* 10001th prime
*
@ https://rosettacode.org/wiki/10001th_prime@Task
*
fastfunc isprim num .
   if num mod 2 = 0 and num > 2
      return 0
   .
   i = 3
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
i = 2
repeat
   if isprim i = 1
      nprim += 1
   .
   until nprim = 10001
   i += 1
.
print i
*
* 15 puzzle game
*
@ https://rosettacode.org/wiki/15_puzzle_game@Task
*
sys topleft
background 432
textsize 13
len f[] 16
proc draw . .
   clear
   for i = 1 to 16
      h = f[i]
      if h < 16
         x = (i - 1) mod 4 * 24 + 3
         y = (i - 1) div 4 * 24 + 3
         color 210
         move x y
         rect 22 22
         move x + 4 y + 6
         if h < 10
            move x + 6 y + 6
         .
         color 885
         text h
      .
   .
.
global done .
proc smiley . .
   s = 3.5
   x = 86
   y = 86
   move x y
   color 983
   circle 2.8 * s
   color 000
   move x - s y - s
   circle s / 3
   move x + 3.5 y - 3.5
   circle s / 3
   linewidth s / 3
   curve [ x - s y + s x y + 2 * s x + s y + s ]
.
proc init . .
   done = 0
   for i = 1 to 16
      f[i] = i
   .
   # shuffle
   for i = 15 downto 2
      r = random i
      swap f[r] f[i]
   .
   # make it solvable
   inv = 0
   for i = 1 to 15
      for j = 1 to i - 1
         if f[j] > f[i]
            inv += 1
         .
      .
   .
   if inv mod 2 <> 0
      swap f[1] f[2]
   .
   textsize 12
   draw
.
proc move_tile . .
   c = mouse_x div 25
   r = mouse_y div 25
   i = r * 4 + c + 1
   if c > 0 and f[i - 1] = 16
      swap f[i] f[i - 1]
   elif r > 0 and f[i - 4] = 16
      swap f[i] f[i - 4]
   elif r < 3 and f[i + 4] = 16
      swap f[i] f[i + 4]
   elif c < 3 and f[i + 1] = 16
      swap f[i] f[i + 1]
   .
   draw
   for i = 1 to 15
      if f[i] > f[i + 1]
         return
      .
   .
   done = 1
   timer 0.5
.
on mouse_down
   if done = 0
      move_tile
   elif done = 3
      init
   .
.
on timer
   if done = 1
      smiley
      done = 2
      timer 2
   else
      done = 3
   .
.
init
*
* 21 game
*
@ https://rosettacode.org/wiki/21_game@Task
*
print "Who reaches 21, wins"
print "Do you want to begin (y/n)"
who = 1
if input = "n"
  who = 2
.
who$[] = [ "Human" "Computer" ]
repeat
  if who = 1
    repeat
      print ""
      print "Choose 1,2 or 3 (q for quit)"
      a$ = input
      n = number a$
      until a$ = "q" or (n >= 1 and n <= 3)
    .
  else
    sleep 1
    if sum mod 4 = 1
      n = random 3
    else
      n = 4 - (sum + 3) mod 4
    .
  .
  sum += n
  print who$[who] & ": " & n & " --> " & sum
  until sum >= 21 or a$ = "q"
  who = who mod 2 + 1
.
if a$ <> "q"
  print ""
  if who = 0
    print "Congratulation, you won"
  else
    print "Sorry, you lost"
  .
.
*
* 4-rings or 4-squares puzzle
*
@ https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle@Task
*
func ok v t[] .
   for h in t[]
      if v = h
         return 0
      .
   .
   return 1
.
proc four lo hi uni show . .
   # 
   subr bf
      for f = lo to hi
         if uni = 0 or ok f [ a c d g e ] = 1
            b = e + f - c
            if b >= lo and b <= hi and (uni = 0 or ok b [ a c d g e f ] = 1)
               solutions += 1
               if show = 1
                  for h in [ a b c d e f g ]
                     write h & " "
                  .
                  print ""
               .
            .
         .
      .
   .
   subr ge
      for e = lo to hi
         if uni = 0 or ok e [ a c d ] = 1
            g = d + e
            if g >= lo and g <= hi and (uni = 0 or ok g [ a c d e ] = 1)
               bf
            .
         .
      .
   .
   subr acd
      for c = lo to hi
         for d = lo to hi
            if uni = 0 or c <> d
               a = c + d
               if a >= lo and a <= hi and (uni = 0 or c <> 0 and d <> 0)
                  ge
               .
            .
         .
      .
   .
   print "low:" & lo & " hi:" & hi & " unique:" & uni
   acd
   print solutions & " solutions"
   print ""
.
four 1 7 1 1
four 3 9 1 1
four 0 9 0 0
*
* 99 bottles of beer
*
@ https://rosettacode.org/wiki/99_bottles_of_beer@Task
*
func$ bottle num .
   if num = 1
      return "bottle"
   .
   return "bottles"
.
# 
i = 99
repeat
   print i & " " & bottle i & " of beer on the wall"
   print i & " " & bottle i & " of beer"
   print "Take one down, pass it around"
   i -= 1
   until i = 0
   print i & " " & bottle i & " of beer on the wall"
   print ""
.
print "No more bottles of beer on the wall"
*
* A+B
*
@ https://rosettacode.org/wiki/A+B@Task
*
a$ = input
i = 1
while i < len a$ and substr a$ i 1 <> " "
  i += 1
.
a = number substr a$ 1 i
b = number substr a$ i -1
print a + b
*
* ABC problem
*
@ https://rosettacode.org/wiki/ABC_problem@Task
*
b$[][] = [ [ "B" "O" ] [ "X" "K" ] [ "D" "Q" ] [ "C" "P" ] [ "N" "A" ] [ "G" "T" ] [ "R" "E" ] [ "T" "G" ] [ "Q" "D" ] [ "F" "S" ] [ "J" "W" ] [ "H" "U" ] [ "V" "I" ] [ "A" "N" ] [ "O" "B" ] [ "E" "R" ] [ "F" "S" ] [ "L" "Y" ] [ "P" "C" ] [ "Z" "M" ] ]
len b[] len b$[][]
global w$[] cnt .
#
proc backtr wi . .
   if wi > len w$[]
      cnt += 1
      return
   .
   for i = 1 to len b$[][]
      if b[i] = 0 and (b$[i][1] = w$[wi] or b$[i][2] = w$[wi])
         b[i] = 1
         backtr wi + 1
         b[i] = 0
      .
   .
.
for s$ in [ "A" "BARK" "BOOK" "TREAT" "COMMON" "SQUAD" "CONFUSE" ]
   w$[] = strchars s$
   cnt = 0
   backtr 1
   print s$ & " can be spelled in " & cnt & " ways"
.
*
* Abundant odd numbers
*
@ https://rosettacode.org/wiki/Abundant_odd_numbers@Task
*
fastfunc sumdivs n .
   sum = 1
   i = 3
   while i <= sqrt n
      if n mod i = 0
         sum += i
         j = n / i
         if i <> j
            sum += j
         .
      .
      i += 2
   .
   return sum
.
n = 1
numfmt 0 6
while cnt < 1000
   sum = sumdivs n
   if sum > n
      cnt += 1
      if cnt <= 25 or cnt = 1000
         print cnt & "    n: " & n & " sum: " & sum
      .
   .
   n += 2
.
print ""
n = 1000000001
repeat
   sum = sumdivs n
   until sum > n
   n += 2
.
print "1st > 1B: " & n & " sum: " & sum
*
* Abundant, deficient and perfect number classifications
*
@ https://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications@Task
*
func sumprop num .
   if num < 2
      return 0
   .
   i = 2
   sum = 1
   root = sqrt num
   while i < root
      if num mod i = 0
         sum += i + num / i
      .
      i += 1
   .
   if num mod root = 0
      sum += root
   .
   return sum
.
for j = 1 to 20000
   sump = sumprop j
   if sump < j
      deficient += 1
   elif sump = j
      perfect += 1
   else
      abundant += 1
   .
.
print "Perfect: " & perfect
print "Abundant: " & abundant
print "Deficient: " & deficient
*
* Ackermann function
*
@ https://rosettacode.org/wiki/Ackermann_function@Task
*
func ackerm m n .
   if m = 0
      return n + 1
   elif n = 0
      return ackerm (m - 1) 1
   else
      return ackerm (m - 1) ackerm m (n - 1)
   .
.
print ackerm 3 6
*
* Additive primes
*
@ https://rosettacode.org/wiki/Additive_primes@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func digsum n .
   while n > 0
      sum += n mod 10
      n = n div 10
   .
   return sum
.
for i = 2 to 500
   if prime i = 1
      s = digsum i
      if prime s = 1
         write i & " "
      .
   .
.
print ""
*
* Air mass
*
@ https://rosettacode.org/wiki/Air_mass@Task
*
func rho a .
   return pow 2.718281828459 (-a / 8500)
.
func height a z d .
   AA = 6371000 + a
   HH = sqrt (AA * AA + d * d - 2 * d * AA * cos (180 - z))
   return HH - 6371000
.
func density a z .
   while d < 10000000
      delta = higher 0.001 (0.001 * d)
      sum += rho height a z (d + 0.5 * delta) * delta
      d += delta
   .
   return sum
.
func airmass a z .
   return density a z / density a 0
.
numfmt 8 2
print "Angle   0 m      13700 m"
print "------------------------"
for z = 0 step 5 to 90
   print z & "   " & airmass 0 z & " " & airmass 13700 z
.
*
* Align columns
*
@ https://rosettacode.org/wiki/Align_columns@Task
*
global width inp$[] .
proc read . .
   repeat
      inp$ = input
      until inp$ = ""
      inp$[] &= inp$
      ar$[] = strsplit inp$ "$"
      for s$ in ar$[]
         width = higher width len s$
      .
   .
.
call read
# 
proc out mode . .
   for inp$ in inp$[]
      ar$[] = strsplit inp$ "$"
      for s$ in ar$[]
         spc = width - len s$ + 1
         if mode = 1
            write s$
            for i to spc
               write " "
            .
         elif mode = 2
            for i to spc
               write " "
            .
            write s$
         elif mode = 3
            for i to spc div 2
               write " "
            .
            write s$
            for i to spc - spc div 2
               write " "
            .
         .
      .
      print ""
   .
.
call out 1
print ""
call out 2
print ""
call out 3
# 
input_data
Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.
*
* Aliquot sequence classifications
*
@ https://rosettacode.org/wiki/Aliquot_sequence_classifications@Task
*
fastfunc sumprop num .
   if num = 1
      return 0
   .
   sum = 1
   root = sqrt num
   i = 2
   while i < root
      if num mod i = 0
         sum += i + num / i
      .
      i += 1
   .
   if num mod root = 0
      sum += root
   .
   return sum
.
func$ tostr ar[] .
   for v in ar[]
      s$ &= " " & v
   .
   return s$
.
func$ class k .
   oldk = k
   newk = sumprop oldk
   oldk = newk
   seq[] &= newk
   if newk = 0
      return "terminating " & tostr seq[]
   .
   if newk = k
      return "perfect " & tostr seq[]
   .
   newk = sumprop oldk
   oldk = newk
   seq[] &= newk
   if newk = 0
      return "terminating " & tostr seq[]
   .
   if newk = k
      return "amicable " & tostr seq[]
   .
   for t = 4 to 16
      newk = sumprop oldk
      seq[] &= newk
      if newk = 0
         return "terminating " & tostr seq[]
      .
      if newk = k
         return "sociable (period " & t - 1 & ") " & tostr seq[]
      .
      if newk = oldk
         return "aspiring " & tostr seq[]
      .
      for i to len seq[] - 1
         if newk = seq[i]
            return "cyclic (at " & newk & ") " & tostr seq[]
         .
      .
      if newk > 140737488355328
         return "non-terminating (term > 140737488355328) " & tostr seq[]
      .
      oldk = newk
   .
   return "non-terminating (after 16 terms)  " & tostr seq[]
.
print "Number classification sequence"
for j = 1 to 12
   print j & " " & class j
.
for j in [ 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080 ]
   print j & " " & class j
.
*
* Almost prime
*
@ https://rosettacode.org/wiki/Almost_prime@Task
*
func kprime n k .
   i = 2
   while i <= n
      while n mod i = 0
         if f = k
            return 0
         .
         f += 1
         n /= i
      .
      i += 1
   .
   if f = k
      return 1
   .
   return 0
.
for k = 1 to 5
   write "k=" & k & " : "
   i = 2
   c = 0
   while c < 10
      if kprime i k = 1
         write i & " "
         c += 1
      .
      i += 1
   .
   print ""
.
*
* Amicable pairs
*
@ https://rosettacode.org/wiki/Amicable_pairs@Task
*
func sumdivs n .
   sum = 1
   for d = 2 to sqrt n
      if n mod d = 0
         sum += d + n div d
      .
   .
   return sum
.
for n = 1 to 20000
   m = sumdivs n
   if m > n
      if sumdivs m = n
         print n & " " & m
      .
   .
.
*
* Angle difference between two bearings
*
@ https://rosettacode.org/wiki/Angle_difference_between_two_bearings@Task
*
func angdiff a b .
   r = (b - a) mod 360
   if r < -180
      r += 360
   elif r >= 180
      r -= 360
   .
   return r
.
proc pd a b . .
   print b & " " & a & " -> " & angdiff a b
.
pd 20 45
pd -45 45
pd -85 90
pd -95 90
pd -45 125
pd -45 145
pd 29.4803 -88.6381
pd -78.3251 -159.036
pd -70099.74233810938 29840.67437876723
pd -165313.6666297357 33693.9894517456
pd 1174.8380510598456 -154146.66490124757
pd 60175.77306795546 42213.07192354373
*
* Angles (geometric), normalization and conversion
*
@ https://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion@Task
*
func angconv ang f$ t$ .
   sgn = sign ang
   ang = abs ang
   if f$ = "degree"
      turn = ang / 360 mod 1
   elif f$ = "gradian"
      turn = ang / 400 mod 1
   elif f$ = "mil"
      turn = ang / 6400 mod 1
   elif f$ = "radian"
      turn = ang / (2 * pi) mod 1
   .
   if t$ = "degree"
      ang = turn * 360
   elif t$ = "gradian"
      ang = turn * 400
   elif t$ = "mil"
      ang = turn * 6400
   elif t$ = "radian"
      ang = turn * 2 * pi
   .
   return ang * sgn
.
func$ fmt s$ .
   return substr "        " 1 (9 - len s$) & s$ & " "
.
# 
scales$[] = [ "degree" "gradian" "mil" "radian" ]
values[] = [ -2 -1 0 1 2 6.2831853 16 57.2957795 359 399 6399 1000000 ]
numfmt 3 10
for f$ in scales$[]
   write fmt f$
   for t$ in scales$[]
      write fmt t$
   .
   print ""
   print "  ------------------------------------------------"
   for v in values[]
      write v
      for t$ in scales$[]
         write angconv v f$ t$
      .
      print ""
   .
   print ""
.
*
* Animate a pendulum
*
@ https://rosettacode.org/wiki/Animate_a_pendulum@Task
*
ang = 45
on animate
  clear
  move 50 50
  circle 1
  x = 50 + 40 * sin ang
  y = 50 + 40 * cos ang
  line x y
  circle 6
  vel += sin ang / 5
  ang += vel
.
*
* Animation
*
@ https://rosettacode.org/wiki/Animation@Task
*
s$ = "Hello world! "
textsize 16
lg = len s$
on timer
   color 333
   move 10 20
   rect 80 20
   color 999
   move 12 24
   text s$
   if forw = 0
      s$ = substr s$ lg 1 & substr s$ 1 (lg - 1)
   else
      s$ = substr s$ 2 (lg - 1) & substr s$ 1 1
   .
   timer 0.2
.
on mouse_down
   if mouse_x > 10 and mouse_x < 90
      if mouse_y > 20 and mouse_y < 40
         forw = 1 - forw
      .
   .
.
timer 0
*
* Anti-primes
*
@ https://rosettacode.org/wiki/Anti-primes@Task
*
func divcnt v .
   n = v
   tot = 1
   p = 2
   while p <= sqrt n
      cnt = 1
      while n mod p = 0
         cnt += 1
         n = n div p
      .
      p += 1
      tot *= cnt
   .
   if n > 1
      tot *= 2
   .
   return tot
.
while count < 20
   n += 1
   divs = divcnt n
   if divs > max
      print n
      max = divs
      count += 1
   .
.
*
* Append numbers at same position in strings
*
@ https://rosettacode.org/wiki/Append_numbers_at_same_position_in_strings@Task
*
list1[] = [ 1 2 3 4 5 6 7 8 9 ]
list2[] = [ 10 11 12 13 14 15 16 17 18 ]
list3[] = [ 19 20 21 22 23 24 25 26 27 ]
# 
for i to len list1[]
   s$ = list1[i] & list2[i] & list3[i]
   r[] &= number s$
.
print r[]
*
* Archimedean spiral
*
@ https://rosettacode.org/wiki/Archimedean_spiral@Task
*
linewidth 0.4
x = 50
y = 50
while r < 50
   line r * cos t + x r * sin t + y
   r += 0.05
   t += 3
.
*
* Arithmetic evaluation
*
@ https://rosettacode.org/wiki/Arithmetic_evaluation@Task
*
subr nch
   if inp_ind > len inp$[]
      ch$ = strchar 0
   else
      ch$ = inp$[inp_ind]
      inp_ind += 1
   .
   ch = strcode ch$
.
# 
subr ntok
   while ch$ = " "
      nch
   .
   if ch >= 48 and ch <= 58
      tok$ = "n"
      s$ = ""
      while ch >= 48 and ch <= 58 or ch$ = "."
         s$ &= ch$
         nch
      .
      tokv = number s$
   elif ch = 0
      tok$ = "end of text"
   else
      tok$ = ch$
      nch
   .
.
subr init0
   astop$[] = [ ]
   astleft[] = [ ]
   astright[] = [ ]
   err = 0
.
proc init s$ . .
   inp$[] = strchars s$
   inp_ind = 1
   nch
   ntok
   init0
.
proc ast_print nd . .
   write "AST:"
   for i to len astop$[]
      write " ( "
      write astop$[i] & " "
      write astleft[i] & " "
      write astright[i]
      write " )"
   .
   print " Start: " & nd
.
func node .
   astop$[] &= ""
   astleft[] &= 0
   astright[] &= 0
   return len astop$[]
.
# 
funcdecl parse_expr .
# 
func parse_factor .
   if tok$ = "n"
      nd = node
      astop$[nd] = "n"
      astleft[nd] = tokv
      ntok
   elif tok$ = "("
      ntok
      nd = parse_expr
      if tok$ <> ")"
         err = 1
         print "error: ) expected, got " & tok$
      .
      ntok
   else
      err = 1
      print "error: factor expected, got " & tok$
   .
   return nd
.
func parse_term .
   ndx = parse_factor
   while tok$ = "*" or tok$ = "/"
      nd = node
      astleft[nd] = ndx
      astop$[nd] = tok$
      ntok
      astright[nd] = parse_factor
      ndx = nd
   .
   return ndx
.
func parse_expr .
   ndx = parse_term
   while tok$ = "+" or tok$ = "-"
      nd = node
      astleft[nd] = ndx
      astop$[nd] = tok$
      ntok
      astright[nd] = parse_term
      ndx = nd
   .
   return ndx
.
func parse s$ .
   init s$
   return parse_expr
.
func eval nd .
   if astop$[nd] = "n"
      return astleft[nd]
   .
   le = eval astleft[nd]
   ri = eval astright[nd]
   a$ = astop$[nd]
   if a$ = "+"
      return le + ri
   elif a$ = "-"
      return le - ri
   elif a$ = "*"
      return le * ri
   elif a$ = "/"
      return le / ri
   .
.
repeat
   inp$ = input
   until inp$ = ""
   print "Inp: " & inp$
   nd = parse inp$
   ast_print nd
   if err = 0
      print "Eval: " & eval nd
   .
   print ""
.
input_data
4 * 
4.2 * ((5.3+8)*3 + 4)
2.5 * 2 + 2 * 3.14
*
* Arithmetic numbers
*
@ https://rosettacode.org/wiki/Arithmetic_numbers@Task
*
print "The first 100 arithmetic numbers are:"
numfmt 0 3
n = 1
while aricnt <= 1e5
   divi = 1 ; divcnt = 0 ; sum = 0
   repeat
      quot = n div divi
      until quot < divi
      if quot = divi and n mod divi = 0
         sum += quot
         divcnt += 1
         break 1
      .
      if n mod divi = 0
         sum += divi + quot
         divcnt += 2
      .
      divi += 1
   .
   if sum mod divcnt = 0
      aricnt += 1
      if aricnt <= 100
         write n & " "
         if aricnt mod 10 = 0
            print ""
         .
      .
      if divcnt > 2
         compcnt += 1
      .
      if aricnt = 1e3 or aricnt = 1e4 or aricnt = 1e5
         print ""
         print aricnt & "th arithmetic number: " & n
         print "Composite arithmetic numbers: " & compcnt
      .
   .
   n += 1
.
*
* Arithmetic-geometric mean
*
@ https://rosettacode.org/wiki/Arithmetic-geometric_mean@Task
*
func agm a g .
   repeat
      a0 = a
      a = (a0 + g) / 2
      g = sqrt (a0 * g)
      until abs (a0 - a) < abs (a) * 1e-15
   .
   return a
.
numfmt 16 0
print agm 1 sqrt 0.5
*
* Arithmetic-geometric mean/Calculate Pi
*
@ https://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi@Task
*
an = 1
bn = sqrt 0.5
tn = 0.25
pn = 1
while pn <= 5
   prevAn = an
   an = (bn + an) / 2
   bn = sqrt (bn * prevAn)
   prevAn -= an
   tn -= (pn * prevAn * prevAn)
   pn *= 2
.
mypi = (an + bn) * (an + bn) / (tn * 4)
numfmt 15 0
print mypi
*
* Arithmetic/Integer
*
@ https://rosettacode.org/wiki/Arithmetic/Integer@Task
*
a = number input
b = number input
print a + b
print a - b
print a * b
print a div b
print a mod b
print pow a b
*
* Array concatenation
*
@ https://rosettacode.org/wiki/Array_concatenation@Task
*
a[] = [ 1 2 3 ]
b[] = [ 4 5 6 ]
c[] = a[]
for h in b[]
  c[] &= h
.
print c[]
*
* Array length
*
@ https://rosettacode.org/wiki/Array_length@Task
*
fruit$[] = [ "apples" "oranges" ]
print len fruit$[]
*
* Arrays
*
@ https://rosettacode.org/wiki/Arrays@Task
*
len f[] 4
for i = 1 to len f[]
  f[i] = i
.
f[] &= 5
for i = 1 to len f[]
  print f[i]
.
*
* Ascending primes
*
@ https://rosettacode.org/wiki/Ascending_primes@Task
*
func isprim num .
   if num < 2
      return 0
   .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
proc nextasc n . .
   if isprim n = 1
      write n & " "
   .
   if n > 123456789
      return
   .
   for d = n mod 10 + 1 to 9
      nextasc n * 10 + d
   .
.
nextasc 0
*
* Associative array/Creation
*
@ https://rosettacode.org/wiki/Associative_array/Creation@Task
*
# use array of array for this
proc hashGet ind$ . ar$[][] item$ .
   for i to len ar$[][]
      if ar$[i][1] = ind$
         item$ = ar$[i][2]
         return
      .
   .
   item$ = ""
.
proc hashSet ind$ val$ . ar$[][] .
   for i to len ar$[][]
      if ar$[i][1] = ind$
         ar$[i][2] = val$
         return
      .
   .
.
clothing$[][] = [ [ "type" "t-shirt" ] [ "color" "red" ] ]
clothing$[][] &= [ "size" "xl" ]
# 
hashSet "color" "green" clothing$[][]
hashGet "color" clothing$[][] col$
print col$
*
* Associative array/Iteration
*
@ https://rosettacode.org/wiki/Associative_array/Iteration@Task
*
# use array of array for this
clothing$[][] = [ [ "type" "t-shirt" ] [ "color" "red" ] [ "size" "xl" ] ]
for i to len clothing$[][]
   print clothing$[i][1] & ": " & clothing$[i][2]
.
*
* Attractive numbers
*
@ https://rosettacode.org/wiki/Attractive_numbers@Task
*
func isprim num .
   if num < 2
      return 0
   .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
func count n .
   f = 2
   repeat
      if n mod f = 0
         cnt += 1
         n /= f
      else
         f += 1
      .
      until n = 1
   .
   return cnt
.
for i = 2 to 120
   n = count i
   if isprim n = 1
      write i & " "
   .
.
*
* Averages/Arithmetic mean
*
@ https://rosettacode.org/wiki/Averages/Arithmetic_mean@Task
*
proc mean . f[] r .
   for i = 1 to len f[]
      s += f[i]
   .
   r = s / len f[]
.
f[] = [ 1 2 3 4 5 6 7 8 ]
mean f[] r
print r
*
* Averages/Mean angle
*
@ https://rosettacode.org/wiki/Averages/Mean_angle@Task
*
func mean ang[] .
   for ang in ang[]
      x += cos ang
      y += sin ang
   .
   return atan2 (y / len ang[]) (x / len ang[])
.
print mean [ 350 10 ]
print mean [ 90 180 270 360 ]
print mean [ 10 20 30 ]
*
* Averages/Mean time of day
*
@ https://rosettacode.org/wiki/Averages/Mean_time_of_day@Task
*
func tm2deg t$ .
   t[] = number strsplit t$ ":"
   return 360 * t[1] / 24.0 + 360 * t[2] / (24 * 60.0) + 360 * t[3] / (24 * 3600.0)
.
func$ deg2tm deg .
   len t[] 3
   h = floor (24 * 60 * 60 * deg / 360)
   t[3] = h mod 60
   h = h div 60
   t[2] = h mod 60
   t[1] = h div 60
   for h in t[]
      if h < 10
         s$ &= 0
      .
      s$ &= h
      s$ &= ":"
   .
   return substr s$ 1 8
.
func mean ang[] .
   for ang in ang[]
      x += cos ang
      y += sin ang
   .
   return atan2 (y / len ang[]) (x / len ang[])
.
in$ = "23:00:17 23:40:20 00:12:45 00:17:19"
for s$ in strsplit in$ " "
   ar[] &= tm2deg s$
.
print deg2tm (360 + mean ar[])
*
* Averages/Median
*
@ https://rosettacode.org/wiki/Averages/Median@Task
*
proc quickselect k . list[] res .
   # 
   subr partition
      mid = left
      for i = left + 1 to right
         if list[i] < list[left]
            mid += 1
            swap list[i] list[mid]
         .
      .
      swap list[left] list[mid]
   .
   left = 1
   right = len list[]
   while left < right
      partition
      if mid < k
         left = mid + 1
      elif mid > k
         right = mid - 1
      else
         left = right
      .
   .
   res = list[k]
.
proc median . list[] res .
   h = len list[] div 2 + 1
   quickselect h list[] res
   if len list[] mod 2 = 0
      quickselect h - 1 list[] h
      res = (res + h) / 2
   .
.
test[] = [ 4.1 5.6 7.2 1.7 9.3 4.4 3.2 ]
median test[] med
print med
test[] = [ 4.1 7.2 1.7 9.3 4.4 3.2 ]
median test[] med
print med
*
* Averages/Root mean square
*
@ https://rosettacode.org/wiki/Averages/Root_mean_square@Task
*
func rms v[] .
   for v in v[]
      sum += v * v
   .
   return sqrt (sum / len v[])
.
v[] = [ 1 2 3 4 5 6 7 8 9 10 ]
print rms v[]
*
* Babbage problem
*
@ https://rosettacode.org/wiki/Babbage_problem@Task
*
while n * n mod 1000000 <> 269696
  n += 1
.
print n
*
* Barnsley fern
*
@ https://rosettacode.org/wiki/Barnsley_fern@Task
*
color 060
for i = 1 to 200000
  r = randomf
  if r < 0.01
    nx = 0
    ny = 0.16 * y
  elif r < 0.08
    nx = 0.2 * x - 0.26 * y
    ny = 0.23 * x + 0.22 * y + 1.6
  elif r < 0.15
    nx = -0.15 * x + 0.28 * y
    ny = 0.26 * x + 0.24 * y + 0.44
  else
    nx = 0.85 * x + 0.04 * y
    ny = -0.04 * x + 0.85 * y + 1.6
  .
  x = nx
  y = ny
  move 50 + x * 15 y * 10
  rect 0.3 0.3
.
*
* Bell numbers
*
@ https://rosettacode.org/wiki/Bell_numbers@Task
*
func bell n .
   len list[] n
   list[1] = 1
   for i = 2 to n
      for j = 1 to i - 2
         list[i - j - 1] += list[i - j]
      .
      list[i] = list[1] + list[i - 1]
   .
   return list[n]
.
for i = 1 to 15
   print bell i
.
*
* Benford's law
*
@ https://rosettacode.org/wiki/Benford's_law@Task
*
func$ add a$ b$ .
   for i to higher len a$ len b$
      a = number substr a$ i 1
      b = number substr b$ i 1
      r = a + b + c
      c = r div 10
      r$ &= r mod 10
   .
   if c > 0
      r$ &= c
   .
   return r$
.
# 
len fibdist[] 9
proc mkfibdist . .
   # generate 1000 fibonacci numbers as
   # (reversed) strings, because 53 bit
   # integers are too small
   # 
   n = 1000
   prev$ = 0
   val$ = 1
   fibdist[1] = 1
   for i = 2 to n
      h$ = add prev$ val$
      prev$ = val$
      val$ = h$
      ind = number substr val$ len val$ 1
      fibdist[ind] += 1
   .
   for i to len fibdist[]
      fibdist[i] = fibdist[i] / n
   .
.
mkfibdist
# 
func log10 x .
   return logn x / logn 10
.
len benfdist[] 9
proc mkbenfdist . .
   for i to 9
      benfdist[i] = log10 (1 + 1.0 / i)
   .
.
mkbenfdist
# 
numfmt 3 0
print "Actual Expected"
for i to 9
   print fibdist[i] & "   " & benfdist[i]
.
*
* Binary digits
*
@ https://rosettacode.org/wiki/Binary_digits@Task
*
func$ bin num .
   b$ = ""
   if num = 0
      b$ = "0"
   .
   while num > 0
      b$ = num mod 2 & b$
      num = num div 2
   .
   return b$
.
print bin 2
print bin 50
print bin 9000
*
* Binary search
*
@ https://rosettacode.org/wiki/Binary_search@Task
*
proc binSearch val . a[] res .
   low = 1
   high = len a[]
   res = 0
   while low <= high and res = 0
      mid = (low + high) div 2
      if a[mid] > val
         high = mid - 1
      elif a[mid] < val
         low = mid + 1
      else
         res = mid
      .
   .
.
a[] = [ 2 4 6 8 9 ]
binSearch 8 a[] r
print r
*
* Bioinformatics/base count
*
@ https://rosettacode.org/wiki/Bioinformatics/base_count@Task
*
len d[] 26
pos = 1
numfmt 0 4
repeat
   s$ = input
   until s$ = ""
   for c$ in strchars s$
      if pos mod 40 = 1
         write pos & ":"
      .
      if pos mod 4 = 1
         write " "
      .
      write c$
      if pos mod 40 = 0
         print ""
      .
      pos += 1
      c = strcode c$
      d[c - 64] += 1
   .
.
print ""
for i in [ 1 3 7 20 ]
   write strchar (64 + i) & ": "
   print d[i]
.
print "Total: " & d[1] + d[3] + d[7] + d[20]
input_data
CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATG
CTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTG
AGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGAT
GGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT
CGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGG
TCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA
TTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTAT
CGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTG
TCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGAC
GACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT
*
* Bitwise operations
*
@ https://rosettacode.org/wiki/Bitwise_operations@Task
*
# numbers are doubles, bit operations use 32 bits and are unsigned
x = 11
y = 2
print bitnot x
print bitand x y
print bitor x y
print bitxor x y
print bitshift x y
print bitshift x -y
*
* Blum integer
*
@ https://rosettacode.org/wiki/Blum_integer@Task
*
fastfunc semiprim n .
   d = 3
   while d * d <= n
      while n mod d = 0
         if c = 2
            return 0
         .
         n /= d
         c += 1
      .
      d += 2
   .
   if c = 1
      return n
   .
.
print "The first 50 Blum integers:"
n = 3
numfmt 0 4
repeat
   prim1 = semiprim n
   if prim1 <> 0
      if prim1 mod 4 = 3
         prim2 = n div prim1
         if prim2 <> prim1 and prim2 mod 4 = 3
            c += 1
            if c <= 50
               write n
               if c mod 10 = 0 ; print "" ; .
            .
         .
      .
   .
   until c >= 26828
   n += 2
.
print ""
print "The 26828th Blum integer is: " & n
*
* Boolean values
*
@ https://rosettacode.org/wiki/Boolean_values@Task
*
boolNumber = 1
if boolNumber = 1
   print "True"
else
   print "False"
.
*
* Brazilian numbers
*
@ https://rosettacode.org/wiki/Brazilian_numbers@Task
*
func sameDigits n b .
   f = n mod b
   repeat
      n = n div b
      until n = 0
      if n mod b <> f
         return 0
      .
   .
   return 1
.
func isBrazilian7 n .
   # n >= 7
   if n mod 2 = 0
      return 1
   .
   for b = 2 to n - 2
      if sameDigits n b = 1
         return 1
      .
   .
   return 0
.
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
for kind$ in [ "" "odd" "prime" ]
   print "First 20 " & kind$ & " Brazilian numbers:"
   n = 7
   cnt = 1
   while cnt <= 20
      if isBrazilian7 n = 1
         write n & " "
         cnt += 1
      .
      if kind$ = ""
         n += 1
      elif kind$ = "odd"
         n += 2
      else
         repeat
            n += 2
            until prime n = 1
         .
      .
   .
   print ""
.
*
* Brownian tree
*
@ https://rosettacode.org/wiki/Brownian_tree@Task
*
color3 0 1 1
len f[] 200 * 200
move 50 50
rect 0.5 0.5
f[100 * 200 + 100] = 1
n = 9000
while i < n
  repeat
    x = random 200 - 1
    y = random 200 - 1
    until f[y * 200 + x + 1] <> 1
  .
  while 1 = 1
    xo = x
    yo = y
    x += random 3 - 2
    y += random 3 - 2
    if x < 0 or y < 0 or x >= 200 or y >= 200
      break 1
    .
    if f[y * 200 + x + 1] = 1
      move xo / 2 yo / 2
      rect 0.5 0.5
      f[yo * 200 + xo + 1] = 1
      i += 1
      if i mod 16 = 0
        color3 0.2 + i / n 1 1
        sleep 0
      .
      break 1
    .
  .
.
*
* Bulls and cows
*
@ https://rosettacode.org/wiki/Bulls_and_cows@Task
*
dig[] = [ 1 2 3 4 5 6 7 8 9 ]
for i = 1 to 4
  h = i - 1 + random (10 - i)
  swap dig[i] dig[h]
.
# print dig[]
len g[] 4
attempts = 0
repeat
  repeat
    ok = 0
    s$[] = strchars input
    if len s$[] = 4
      ok = 1
      for i = 1 to 4
        g[i] = number s$[i]
        if g[i] = 0
          ok = 0
        .
      .
    .
    until ok = 1
  .
  print g[]
  attempts += 1
  bulls = 0
  cows = 0
  for i = 1 to 4
    if g[i] = dig[i]
      bulls += 1
    else
      for j = 1 to 4
        if dig[j] = g[i]
          cows += 1
        .
      .
    .
  .
  print "bulls:" & bulls & " cows:" & cows
  until bulls = 4
.
print "Well done! " & attempts & " attempts needed."
*
* Calculating the value of e
*
@ https://rosettacode.org/wiki/Calculating_the_value_of_e@Task
*
numfmt 5 0
fact = 1
n = 2
e = 2
while abs (e - e0) > 0.0001
  e0 = e
  fact = fact * n
  n += 1
  e += 1 / fact
.
print e
*
* Call a function
*
@ https://rosettacode.org/wiki/Call_a_function@Task
*
func sqr n .
   return n * n
.
sqr 3
# 
proc divmod a b . q r .
   q = a div b
   r = a mod b
.
divmod 11 3 q r
print q & " " & r
# 
subr sqr2
   a = a * a
.
a = 5
sqr2
print a
*
* Case-sensitivity of identifiers
*
@ https://rosettacode.org/wiki/Case-sensitivity_of_identifiers@Task
*
dog$ = "Benjamin"
Dog$ = "Samba"
DOG$ = "Bernie"
# 
print "The three dogs are named " & dog$ & ", " & Dog$ & ", and " & DOG$ & "."
*
* Catalan numbers
*
@ https://rosettacode.org/wiki/Catalan_numbers@Task
*
func catalan n .
   if n = 0
      return 1
   .
   return 2 * (2 * n - 1) * catalan (n - 1) div (1 + n)
.
for i = 0 to 14
   print catalan i
.
*
* Catalan numbers/Pascal's triangle
*
@ https://rosettacode.org/wiki/Catalan_numbers/Pascal's_triangle@Task
*
print 1
for n = 2 to 15
   num = 1
   den = 1
   for k = 2 to n
      num *= n + k
      den *= k
      cat = num / den
   .
   print cat
.
*
* Chaos game
*
@ https://rosettacode.org/wiki/Chaos_game@Task
*
color 900
x[] = [ 0 100 50 ]
y[] = [ 7 7 93 ]
x = randomf * 100
y = randomf * 100
for i = 1 to 100000
  move x y
  rect 0.3 0.3
  h = random 3
  x = (x + x[h]) / 2
  y = (y + y[h]) / 2
.
*
* Character codes
*
@ https://rosettacode.org/wiki/Character_codes@Task
*
print strcode "a"
print strchar 97
*
* Chebyshev coefficients
*
@ https://rosettacode.org/wiki/Chebyshev_coefficients@Task
*
numfmt 12 0
a = 0
b = 1
n = 10
len coef[] n
len cheby[] n
for i = 0 to n - 1
   coef[i + 1] = cos (180 / pi * (cos (180 / n * (i + 1 / 2)) * (b - a) / 2 + (b + a) / 2))
.
for i = 0 to n - 1
   w = 0
   for j = 0 to n - 1
      w += coef[j + 1] * cos (180 / n * i * (j + 1 / 2))
   .
   cheby[i + 1] = w * 2 / n
   print cheby[i + 1]
.
*
* Chinese remainder theorem
*
@ https://rosettacode.org/wiki/Chinese_remainder_theorem@Task
*
func mul_inv a b .
   b0 = b
   x1 = 1
   if b <> 1
      while a > 1
         q = a div b
         t = b
         b = a mod b
         a = t
         t = x0
         x0 = x1 - q * x0
         x1 = t
      .
      if x1 < 0
         x1 += b0
      .
   .
   return x1
.
proc remainder . n[] a[] r .
   prod = 1
   sum = 0
   for i = 1 to len n[]
      prod *= n[i]
   .
   for i = 1 to len n[]
      p = prod / n[i]
      sum += a[i] * (mul_inv p n[i]) * p
      r = sum mod prod
   .
.
n[] = [ 3 5 7 ]
a[] = [ 2 3 2 ]
remainder n[] a[] h
print h
*
* Chowla numbers
*
@ https://rosettacode.org/wiki/Chowla_numbers@Task
*
fastfunc chowla n .
   sum = 0
   i = 2
   while i * i <= n
      if n mod i = 0
         j = n div i
         if i = j
            sum += i
         else
            sum += i + j
         .
      .
      i += 1
   .
   return sum
.
proc sieve . c[] .
   i = 3
   while i * 3 <= len c[]
      if c[i] = 0
         if chowla i = 0
            j = 3 * i
            while j <= len c[]
               c[j] = 1
               j += 2 * i
            .
         .
      .
      i += 2
   .
.
proc commatize n . s$ .
   s$[] = strchars n
   s$ = ""
   l = len s$[]
   for i = 1 to len s$[]
      if i > 1 and l mod 3 = 0
         s$ &= ","
      .
      l -= 1
      s$ &= s$[i]
   .
.
print "chowla number from 1 to 37"
for i = 1 to 37
   print "  " & i & ": " & chowla i
.
proc main . .
   print ""
   len c[] 10000000
   count = 1
   sieve c[]
   power = 100
   i = 3
   while i <= len c[]
      if c[i] = 0
         count += 1
      .
      if i = power - 1
         commatize power p$
         commatize count c$
         print "There are " & c$ & " primes up to " & p$
         power *= 10
      .
      i += 2
   .
   print ""
   limit = 35000000
   count = 0
   i = 2
   k = 2
   kk = 3
   repeat
      p = k * kk
      until p > limit
      if chowla p = p - 1
         commatize p s$
         print s$ & " is a perfect number"
         count += 1
      .
      k = kk + 1
      kk += k
      i += 1
   .
   commatize limit s$
   print "There are " & count & " perfect mumbers up to " & s$
.
main
*
* Circular primes
*
@ https://rosettacode.org/wiki/Circular_primes@Task
*
fastfunc prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func cycle n .
   m = n
   p = 1
   while m >= 10
      p *= 10
      m = m div 10
   .
   return m + n mod p * 10
.
func circprime p .
   if prime p = 0
      return 0
   .
   p2 = cycle p
   while p2 <> p
      if p2 < p or prime p2 = 0
         return 0
      .
      p2 = cycle p2
   .
   return 1
.
p = 2
while count < 19
   if circprime p = 1
      print p
      count += 1
   .
   p += 1
.
*
* Code Golf: Code Golf
*
@ https://rosettacode.org/wiki/Code_Golf:_Code_Golf@Task
*
# with string literal (16 characters)
write"Code Golf"
# without quoted literals (53 characters)
# for i in [44 0 11 10 79 40 0 3 9]write strchar 111-i.
for i in [44 0 11 10 79 40 0 3 9]write strchar 111-i.
*
* Collections
*
@ https://rosettacode.org/wiki/Collections@Task
*
array[] &= 1
array[] &= 2
array[] &= 3
arrayArray[][] &= [ 1 2 ]
arrayArray[][] &= [ 3 4 ]
arrayArray[][] &= [ 5 6 ]
print array[]
print arrayArray[][]
*
* Colour bars/Display
*
@ https://rosettacode.org/wiki/Colour_bars/Display@Task
*
col[] = [ 000 900 090 009 909 099 990 999 ]
w = 100 / len col[]
for i = 1 to len col[]
   color col[i]
   move w * (i - 1) 0
   rect w 100
.
*
* Combinations
*
@ https://rosettacode.org/wiki/Combinations@Task
*
n = 5
m = 3
len result[] m
# 
proc combinations pos val . .
   if pos <= m
      for i = val to n - m
         result[pos] = pos + i
         combinations pos + 1 i
      .
   else
      print result[]
   .
.
combinations 1 0
*
* Combinations with repetitions
*
@ https://rosettacode.org/wiki/Combinations_with_repetitions@Task
*
items$[] = [ "iced" "jam" "plain" ]
n = len items$[]
k = 2
len result[] k
n_results = 0
# 
proc output . .
   n_results += 1
   if len items$[] > 0
      s$ = ""
      for i = 1 to k
         s$ &= items$[result[i]] & " "
      .
      print s$
   .
.
proc combine pos val . .
   if pos > k
      output
   else
      for i = val to n
         result[pos] = i
         combine pos + 1 i
      .
   .
.
combine 1 1
# 
n = 10
k = 3
len result[] k
items$[] = [ ]
n_results = 0
combine 1 1
print ""
print n_results & " results with 10 donuts"
*
* Comments
*
@ https://rosettacode.org/wiki/Comments@Task
*
# This is a comment
*
* Compare a list of strings
*
@ https://rosettacode.org/wiki/Compare_a_list_of_strings@Task
*
proc test s$[] . .
   ident = 1
   ascend = 1
   for i = 2 to len s$[]
      h = strcmp s$[i] s$[i - 1]
      if h <> 0
         ident = 0
      .
      if h <= 0
         ascend = 0
      .
   .
   print s$[]
   if ident = 1
      print "all equal"
   .
   if ascend = 1
      print "ascending"
   .
   print ""
.
test [ "AA" "BB" "CC" ]
test [ "AA" "AA" "AA" ]
test [ "AA" "CC" "BB" ]
test [ "AA" "ACB" "BB" "CC" ]
test [ "single_element" ]
*
* Compare length of two strings
*
@ https://rosettacode.org/wiki/Compare_length_of_two_strings@Task
*
proc scmp a$ b$ . .
   if len a$ < len b$
      swap a$ b$
   .
   print a$ & " - " & len a$
   print b$ & " - " & len b$
   print ""
.
call scmp "Easy" "Language"
call scmp "Rosetta" "Code"
*
* Conditional structures
*
@ https://rosettacode.org/wiki/Conditional_structures@Task
*
i = random 10
if i mod 2 = 0
  print i & " is divisible by 2"
elif i mod 3 = 0
  print i & " is divisible by 3"
else
  print i & " is not divisible by 2 or 3"
.
*
* Conjugate a Latin verb
*
@ https://rosettacode.org/wiki/Conjugate_a_Latin_verb@Task
*
proc conj inf$ . .
   if substr inf$ len inf$ - 2 -1 <> "are"
      print "Not a first conjugation verb."
      return
   .
   stem$ = substr inf$ 1 len inf$ - 3
   if stem$ = ""
      print "Stem cannot be empty."
      return
   .
   print "Present indicative tense of " & inf$ & ":"
   for en$ in [ "o" "as" "at" "amus" "atis" "ant" ]
      print stem$ & en$
   .
.
for s$ in [ "amare" "dare" ]
   conj s$
   print ""
.
*
* Continued fraction
*
@ https://rosettacode.org/wiki/Continued_fraction@Task
*
numfmt 8 0
func calc_sqrt .
   n = 100
   sum = n
   while n >= 1
      a = 1
      if n > 1
         a = 2
      .
      b = 1
      sum = a + b / sum
      n -= 1
   .
   return sum
.
func calc_e .
   n = 100
   sum = n
   while n >= 1
      a = 2
      if n > 1
         a = n - 1
      .
      b = 1
      if n > 1
         b = n - 1
      .
      sum = a + b / sum
      n -= 1
   .
   return sum
.
func calc_pi .
   n = 100
   sum = n
   while n >= 1
      a = 3
      if n > 1
         a = 6
      .
      b = 2 * n - 1
      b *= b
      sum = a + b / sum
      n -= 1
   .
   return sum
.
print calc_sqrt
print calc_e
print calc_pi
*
* Convert seconds to compound duration
*
@ https://rosettacode.org/wiki/Convert_seconds_to_compound_duration@Task
*
func$ split sec .
   divs[] = [ 60 60 24 7 ]
   n$[] = [ "sec" "min" "hr" "d" "wk" ]
   len r[] 5
   for i = 1 to 4
      r[i] = sec mod divs[i]
      sec = sec div divs[i]
   .
   r[5] = sec
   for i = 5 downto 1
      if r[i] <> 0
         if s$ <> ""
            s$ &= ", "
         .
         s$ &= r[i] & " " & n$[i]
      .
   .
   return s$
.
print split 7259
print split 86400
print split 6000000
*
* Conway's Game of Life
*
@ https://rosettacode.org/wiki/Conway's_Game_of_Life@Task
*
n = 70
time = 0.1
# 
nx = n + 1
subr init
   for r = 1 to n
      for c = 1 to n
         i = r * nx + c
         if randomf < 0.3
            f[i] = 1
         .
      .
   .
.
f = 100 / n
subr show
   clear
   for r = 1 to n
      for c = 1 to n
         if f[r * nx + c] = 1
            move c * f - f r * f - f
            rect f * 0.9 f * 0.9
         .
      .
   .
.
subr update
   swap f[] p[]
   for r = 1 to n
      sm = 0
      i = r * nx + 1
      sr = p[i - nx] + p[i] + p[i + nx]
      for c = 1 to n
         sl = sm
         sm = sr
         in = i + 1
         sr = p[in - nx] + p[in] + p[in + nx]
         s = sl + sm + sr
         if s = 3 or s = 4 and p[i] = 1
            f[i] = 1
         else
            f[i] = 0
         .
         i = in
      .
   .
.
on timer
   update
   show
   timer time
.
on mouse_down
   c = mouse_x div f + 1
   r = mouse_y div f + 1
   i = r * nx + c
   f[i] = 1 - f[i]
   show
   timer 3
.
len f[] nx * nx + nx
len p[] nx * nx + nx
init
timer 0
*
* Copy a string
*
@ https://rosettacode.org/wiki/Copy_a_string@Task
*
a$ = "hello"
b$ = a$
print b$
*
* Count how many vowels and consonants occur in a string
*
@ https://rosettacode.org/wiki/Count_how_many_vowels_and_consonants_occur_in_a_string@Task
*
proc count s$ . .
   for c$ in strchars s$
      c = strcode c$
      if c >= 97 and c <= 122
         c -= 32
      .
      if c >= 65 and c <= 91
         c$ = strchar c
         if c$ = "A" or c$ = "E" or c$ = "I" or c$ = "O" or c$ = "U"
            vow += 1
         else
            cons += 1
         .
      .
   .
   print "There are " & vow & " vowels and " & cons & " consonants"
.
count "Now is the time for all good men to come to the aid of their country."
*
* Count in factors
*
@ https://rosettacode.org/wiki/Count_in_factors@Task
*
proc decompose num . primes[] .
   primes[] = [ ]
   t = 2
   while t * t <= num
      if num mod t = 0
         primes[] &= t
         num = num / t
      else
         t += 1
      .
   .
   primes[] &= num
.
for i = 1 to 30
   write i & ": "
   decompose i primes[]
   for j = 1 to len primes[]
      if j > 1
         write " x "
      .
      write primes[j]
   .
   print ""
   primes[] = [ ]
.
*
* Count in octal
*
@ https://rosettacode.org/wiki/Count_in_octal@Task
*
func$ oct v .
   while v > 0
      r$ = v mod 8 & r$
      v = v div 8
   .
   if r$ = ""
      r$ = 0
   .
   return r$
.
for i = 0 to 10
   print oct i
.
print "."
print "."
max = pow 2 53
i = max - 10
repeat
   print oct i
   until i = max
   i += 1
.
*
* Count occurrences of a substring
*
@ https://rosettacode.org/wiki/Count_occurrences_of_a_substring@Task
*
func count str$ pat$ .
   ind = 1
   while ind + len pat$ - 1 <= len str$
      if substr str$ ind len pat$ = pat$
         cnt += 1
         ind += len pat$
      else
         ind += 1
      .
   .
   return cnt
.
print count "the three truths" "th"
print count "ababababab" "abab"
print count "11111111" "11"
print count "11111111" "12"
print count "12" "12"
*
* Count the coins
*
@ https://rosettacode.org/wiki/Count_the_coins@Task
*
len cache[] 100000 * 7 + 6
val[] = [ 1 5 10 25 50 100 ]
func count sum kind .
   if sum = 0
      return 1
   .
   if sum < 0 or kind = 0
      return 0
   .
   chind = sum * 7 + kind
   if cache[chind] > 0
      return cache[chind]
   .
   r2 = count (sum - val[kind]) kind
   r1 = count sum (kind - 1)
   r = r1 + r2
   cache[chind] = r
   return r
.
print count 100 4
print count 10000 6
print count 100000 6
# this is not exact, since numbers
# are doubles and r > 2^53
*
* Cullen and Woodall numbers
*
@ https://rosettacode.org/wiki/Cullen_and_Woodall_numbers@Task
*
for n = 1 to 20
   write n * pow 2 n + 1 & " "
.
print ""
for n = 1 to 20
   write n * pow 2 n - 1 & " "
.
print ""
*
* Cumulative standard deviation
*
@ https://rosettacode.org/wiki/Cumulative_standard_deviation@Task
*
global sum sum2 n .
proc sd x . r .
   sum += x
   sum2 += x * x
   n += 1
   r = sqrt (sum2 / n - sum * sum / n / n)
.
v[] = [ 2 4 4 4 5 5 7 9 ]
for v in v[]
   sd v r
   print v & " " & r
.
*
* Curzon numbers
*
@ https://rosettacode.org/wiki/Curzon_numbers@Task
*
func pow_mod b power modulus .
   x = 1
   while power > 0
      if power mod 2 = 1
         x = x * b mod modulus
      .
      b = b * b mod modulus
      power = power div 2
   .
   return x
.
numfmt 0 4
for k = 2 step 2 to 10
   print "The first 50 Curzon numbers using a base of" & k & ":"
   n = 1
   count = 0
   repeat
      m = k * n + 1
      p = pow_mod k n m + 1
      if p = m
         count += 1
         if count <= 50
            write " " & n
            if count mod 10 = 0
               print ""
            .
         .
      .
      until count = 1000
      n += 1
   .
   print "" ; print "One thousandth: " & n
   print ""
.
*
* CUSIP
*
@ https://rosettacode.org/wiki/CUSIP@Task
*
func check inp$ .
   for i = 1 to 8
      c = strcode substr inp$ i 1
      if c >= 48 and c <= 57
         v = c - 48
      elif c >= 65 and c <= 91
         v = c - 64 + 9
      elif c = 42
         v = 36
      elif c = 64
         v = 37
      elif c = 35
         v = 38
      .
      if i mod 2 = 0
         v *= 2
      .
      sum += v div 10 + v mod 10
   .
   return if (10 - (sum mod 10)) mod 10 = number substr inp$ 9 1
.
for s$ in [ "037833100" "17275R102" "38259P508" "594918104" "68389X106" "68389X105" ]
   write s$ & " is "
   if check s$ = 1
      print "valid"
   else
      print "invalid"
   .
.
*
* Day of the week
*
@ https://rosettacode.org/wiki/Day_of_the_week@Task
*
func dayOfTheWeek year month day .
   # Based on Conway's doomsday algorithm
   # 1. Calculate the doomsday for the century
   century = floor (year / 100)
   if century mod 4 = 0
      centuryDoomsday = 2
   elif century mod 4 = 1
      centuryDoomsday = 0
   elif century mod 4 = 2
      centuryDoomsday = 5
   elif century mod 4 = 3
      centuryDoomsday = 3
   .
   # 2. Find the doomsday of the year
   mainYear = year mod 100
   yearDoomsday = (floor (mainYear / 12) + mainYear mod 12 + floor (mainYear mod 12 / 4) + centuryDoomsday) mod 7
   # 3. Check if the year is leap
   if mainYear = 0
      if century mod 4 = 0
         leap = 1
      else
         leap = 0
      .
   else
      if mainYear mod 4 = 0
         leap = 1
      else
         leap = 0
      .
   .
   # 4. Calculate the DOTW of January 1
   if leap = 1
      januaryOne = (yearDoomsday + 4) mod 7
   else
      januaryOne = (yearDoomsday + 5) mod 7
   .
   # 5. Determine the nth day of the year
   if month = 1
      NthDay = 0
   elif month = 2
      NthDay = 31
   elif month = 3
      NthDay = 59 + leap
   elif month = 4
      NthDay = 90 + leap
   elif month = 5
      NthDay = 120 + leap
   elif month = 6
      NthDay = 151 + leap
   elif month = 7
      NthDay = 181 + leap
   elif month = 8
      NthDay = 212 + leap
   elif month = 9
      NthDay = 243 + leap
   elif month = 10
      NthDay = 273 + leap
   elif month = 11
      NthDay = 304 + leap
   elif month = 12
      NthDay = 334 + leap
   .
   NthDay += day
   # 6. Finally, calculate the day of the week
   return (januaryOne + NthDay - 1) mod 7
.
for i = 2008 to 2121
   if dayOfTheWeek i 12 25 = 0
      print "Christmas in " & i & " is on Sunday"
   .
.
*
* Day of the week of Christmas and New Year
*
@ https://rosettacode.org/wiki/Day_of_the_week_of_Christmas_and_New_Year@Task
*
func dayOfTheWeek year month day .
   # Based on Conway's doomsday algorithm
   century = floor (year / 100)
   if century mod 4 = 0
      centuryDoomsday = 2
   elif century mod 4 = 1
      centuryDoomsday = 0
   elif century mod 4 = 2
      centuryDoomsday = 5
   elif century mod 4 = 3
      centuryDoomsday = 3
   .
   mainYear = year mod 100
   yearDoomsday = (floor (mainYear / 12) + mainYear mod 12 + floor (mainYear mod 12 / 4) + centuryDoomsday) mod 7
   if mainYear = 0
      if century mod 4 = 0
         leap = 1
      else
         leap = 0
      .
   else
      if mainYear mod 4 = 0
         leap = 1
      else
         leap = 0
      .
   .
   if leap = 1
      januaryOne = (yearDoomsday + 4) mod 7
   else
      januaryOne = (yearDoomsday + 5) mod 7
   .
   monthDays[] = [ 0 31 59 90 120 151 181 212 243 273 304 334 ]
   nthDay = monthDays[month]
   if month > 2
      nthDay += leap
   .
   nthDay += day
   return (januaryOne + nthDay - 1) mod 7 + 1
.
days$[] = [ "Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" ]
# 
print "2021-12-25 is on " & days$[dayOfTheWeek 2021 12 25]
print "2022-1-1 is on " & days$[dayOfTheWeek 2022 1 1]
*
* De Polignac numbers
*
@ https://rosettacode.org/wiki/De_Polignac_numbers@Task
*
func isprim num .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
p = 2
for i to 20
   pow2[] &= p
   p *= 2
.
n = 1
while count < 50
   j = 1
   repeat
      p = pow2[j]
      until p > n or isprim (n - p) = 1
      j += 1
   .
   if p > n
      count += 1
      print n
   .
   n += 2
.
*
* Department numbers
*
@ https://rosettacode.org/wiki/Department_numbers@Task
*
numfmt 0 3
for pol = 2 step 2 to 6
   for san = 1 to 7
      for fire = 1 to 7
         if pol <> san and san <> fire and fire <> pol
            if pol + fire + san = 12
               print pol & san & fire
            .
         .
      .
   .
.
*
* Descending primes
*
@ https://rosettacode.org/wiki/Descending_primes@Task
*
func isprim num .
   if num < 2
      return 0
   .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
proc nextdesc n . .
   if isprim n = 1
      write n & " "
   .
   if n > 987654321
      return
   .
   for d = n mod 10 - 1 downto 1
      nextdesc n * 10 + d
   .
.
for i = 9 downto 1
   nextdesc i
.
*
* Detect division by zero
*
@ https://rosettacode.org/wiki/Detect_division_by_zero@Task
*
func checkDivZero a b .
   r = a / b
   if r = number "nan" or r = number "inf" or r = number "-inf"
      return 1
   .
.
print checkDivZero 5 7
print checkDivZero -1 0
*
* Determine if a string has all the same characters
*
@ https://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters@Task
*
func$ hex h .
   for d in [ h div 16 h mod 16 ]
      if d > 9
         d += 7
      .
      h$ &= strchar (d + 48)
   .
   return h$
.
proc samechar s$ . .
   s$[] = strchars s$
   for i = 2 to len s$[]
      if s$[i] <> s$[i - 1]
         h = strcode s$[i]
         write " --> different: '" & s$[i] & "' (" & hex h & "h)"
         print "'  position: " & i
         return
      .
   .
   print " --> ok"
.
repeat
   s$ = input
   until s$ = "EOF"
   print "'" & s$ & "'" & " length " & len s$
   call samechar s$
   print ""
.
input_data

   
2
333
.55
tttTTT
4444 444k
EOF
*
* Determine if a string has all unique characters
*
@ https://rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters@Task
*
func$ hex h .
   for d in [ h div 16 h mod 16 ]
      if d > 9
         d += 7
      .
      h$ &= strchar (d + 48)
   .
   return h$
.
proc unichar s$ . .
   len d[] 65536
   s$[] = strchars s$
   for i to len s$[]
      h = strcode s$[i]
      if d[h] <> 0
         write " --> duplicates: '" & s$[i] & "' (" & hex h & "h)"
         print "'  positions: " & d[h] & ", " & i
         return
      .
      d[h] = i
   .
   print "ok"
.
repeat
   s$ = input
   until s$ = "EOF"
   print "'" & s$ & "'" & " length " & len s$
   call unichar s$
   print ""
.
input_data

.
abcABC
XYZ ZYX
1234567890ABCDEFGHIJKLMN0PQRSTUVWXYZ
EOF
*
* Determine if a string is numeric
*
@ https://rosettacode.org/wiki/Determine_if_a_string_is_numeric@Task
*
func is_numeric a$ .
   h = number a$
   # because every variable must be used
   h = h
   return 1 - error
.
for s$ in [ "abc" "21a" "1234" "-13" "7.65" ]
   if is_numeric s$ = 1
      print s$ & " is numeric"
   else
      print s$ & " is not numeric"
   .
.
*
* Digital root
*
@ https://rosettacode.org/wiki/Digital_root@Task
*
proc digitalRoot n . x persistence .
   numberString$ = n
   currentPersist = 0
   while len numberString$ > 1
      for i = 1 to len numberString$
         sum += number substr numberString$ i 1
      .
      numberString$ = sum
      currentPersist += 1
      sum = 0
   .
   x = number numberString$
   persistence = currentPersist
.
numbers[] = [ 627615 39390 588225 393900588225 ]
for i in numbers[]
   digitalRoot i x persistence
   print i
   print "Additive persistence: " & persistence
   print "Digital root: " & x
.
*
* Disarium numbers
*
@ https://rosettacode.org/wiki/Disarium_numbers@Task
*
func disarium x .
   h = x
   while h > 0
      d[] &= h mod 10
      h = h div 10
   .
   for i = 1 to len d[]
      h += pow d[i] (len d[] - i + 1)
   .
   return if h = x
.
while count < 19
   if disarium n = 1
      count += 1
      print n
   .
   n += 1
.
*
* Dot product
*
@ https://rosettacode.org/wiki/Dot_product@Task
*
func dotprod a[] b[] .
   for i to len a[]
      r += a[i] * b[i]
   .
   return r
.
print dotprod [ 1 3 -5 ] [ 4 -2 -1 ]
*
* Dragon curve
*
@ https://rosettacode.org/wiki/Dragon_curve@Task
*
color 050
linewidth 0.5
x = 25
y = 60
move x y
angle = 0
# 
proc dragon size lev d . .
   if lev = 0
      x -= cos angle * size
      y += sin angle * size
      line x y
   else
      dragon size / sqrt 2 lev - 1 1
      angle -= d * 90
      dragon size / sqrt 2 lev - 1 -1
   .
.
dragon 60 12 1
*
* Draw a clock
*
@ https://rosettacode.org/wiki/Draw_a_clock@Task
*
proc draw hour min sec . .
   # dial
   color 333
   move 50 50
   circle 45
   color 797
   circle 44
   color 333
   for i range0 60
      a = i * 6
      move 50 + sin a * 40 50 + cos a * 40
      circle 0.25
   .
   for i range0 12
      a = i * 30
      move 50 + sin a * 40 50 + cos a * 40
      circle 1
   .
   # hour
   linewidth 2
   color 000
   a = (hour * 60 + min) / 2
   move 50 50
   line 50 + sin a * 32 50 + cos a * 32
   # min
   linewidth 1.5
   a = (sec + min * 60) / 10
   move 50 50
   line 50 + sin a * 40 50 + cos a * 40
   # sec  
   linewidth 1
   color 700
   a = sec * 6
   move 50 50
   line 50 + sin a * 40 50 + cos a * 40
.
on timer
   if t <> floor systime
      t = floor systime
      h$ = timestr t
      sec = number substr h$ 18 2
      min = number substr h$ 15 2
      hour = number substr h$ 12 2
      if hour > 12
         hour -= 12
      .
      draw hour min sec
   .
   timer 0.1
.
timer 0
*
* Draw a pixel
*
@ https://rosettacode.org/wiki/Draw_a_pixel@Task
*
color 900
move 50 50
rect 0.5 0.5
*
* Draw a rotating cube
*
@ https://rosettacode.org/wiki/Draw_a_rotating_cube@Task
*
node[][] = [ [ -1 -1 -1 ] [ -1 -1 1 ] [ -1 1 -1 ] [ -1 1 1 ] [ 1 -1 -1 ] [ 1 -1 1 ] [ 1 1 -1 ] [ 1 1 1 ] ]
edge[][] = [ [ 1 2 ] [ 2 4 ] [ 4 3 ] [ 3 1 ] [ 5 6 ] [ 6 8 ] [ 8 7 ] [ 7 5 ] [ 1 5 ] [ 2 6 ] [ 3 7 ] [ 4 8 ] ]
# 
proc scale f . .
   for i = 1 to len node[][]
      for d = 1 to 3
         node[i][d] *= f
      .
   .
.
proc rotate angx angy . .
   sinx = sin angx
   cosx = cos angx
   siny = sin angy
   cosy = cos angy
   for i = 1 to len node[][]
      x = node[i][1]
      z = node[i][3]
      node[i][1] = x * cosx - z * sinx
      y = node[i][2]
      z = z * cosx + x * sinx
      node[i][2] = y * cosy - z * siny
      node[i][3] = z * cosy + y * siny
   .
.
len nd[] 3
proc draw . .
   clear
   m = 999
   mi = -1
   for i = 1 to len node[][]
      if node[i][3] < m
         m = node[i][3]
         mi = i
      .
   .
   ix = 1
   for i = 1 to len edge[][]
      if edge[i][1] = mi
         nd[ix] = edge[i][2]
         ix += 1
      elif edge[i][2] = mi
         nd[ix] = edge[i][1]
         ix += 1
      .
   .
   for ni = 1 to len nd[]
      for i = 1 to len edge[][]
         if edge[i][1] = nd[ni] or edge[i][2] = nd[ni]
            x1 = node[edge[i][1]][1]
            y1 = node[edge[i][1]][2]
            x2 = node[edge[i][2]][1]
            y2 = node[edge[i][2]][2]
            move x1 + 50 y1 + 50
            line x2 + 50 y2 + 50
         .
      .
   .
.
scale 25
rotate 45 atan sqrt 2
draw
on animate
   rotate 1 0
   draw
.
*
* Eban numbers
*
@ https://rosettacode.org/wiki/Eban_numbers@Task
*
func x n .
   if n = 0 or n = 2 or n = 4 or n = 6
      return 1
   .
.
proc go start stop printable . .
   write start & " - " & stop & ":"
   for i = start step 2 to stop
      b = i div 1000000000
      r = i mod 1000000000
      m = r div 1000000
      r = i mod 1000000
      t = r div 1000
      r = r mod 1000
      if m >= 30 and m <= 66
         m = m mod 10
      .
      if t >= 30 and t <= 66
         t = t mod 10
      .
      if r >= 30 and r <= 66
         r = r mod 10
      .
      if x b = 1 and x m = 1 and x t = 1 and x r = 1
         count += 1
         if printable = 1
            write " " & i
         .
      .
   .
   print " (count=" & count & ")"
.
go 2 1000 1
go 1000 4000 1
go 2 10000 0
go 2 100000 0
go 2 1000000 0
go 2 10000000 0
go 2 100000000 0
*
* Elementary cellular automaton
*
@ https://rosettacode.org/wiki/Elementary_cellular_automaton@Task
*
global celln[] cell[] .
len map[] 8
# 
proc evolve . .
   for i = 1 to len cell[]
      ind = 0
      for j = i + 1 downto i - 1
         ind = ind * 2 + cell[j mod1 len cell[]]
      .
      celln[i] = map[ind + 1]
   .
   swap celln[] cell[]
.
proc show . .
   c$[] = [ "." "#" ]
   for v in cell[]
      write c$[v + 1]
   .
   print ""
.
proc run map count inp[] . .
   for i to 8
      map[i] = map mod 2
      map = map div 2
   .
   swap cell[] inp[]
   len celln[] len cell[]
   show
   for i to count
      evolve
      show
   .
   print ""
.
run 104 9 [ 0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0 ]
run 90 9 [ 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ]
run 122 15 [ 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 ]
*
* Empty string
*
@ https://rosettacode.org/wiki/Empty_string@Task
*
a$ = ""
if a$ = ""
  print "empty"
.
if a$ <> ""
  print "no empty"
.
*
* Entropy
*
@ https://rosettacode.org/wiki/Entropy@Task
*
func entropy s$ .
   len d[] 255
   for c$ in strchars s$
      d[strcode c$] += 1
   .
   for cnt in d[]
      if cnt > 0
         prop = cnt / len s$
         entr -= (prop * log10 prop / log10 2)
      .
   .
   return entr
.
print entropy "1223334444"
*
* Ethiopian multiplication
*
@ https://rosettacode.org/wiki/Ethiopian_multiplication@Task
*
x = 17
y = 34
tot = 0
while x >= 1
  write x & "\t"
  if (x + 1) mod 2 = 0
    tot += y
    print y
  else
    print ""
  .
  x = x div 2
  y = 2 * y
.
print "=\t" & tot
*
* Euler's sum of powers conjecture
*
@ https://rosettacode.org/wiki/Euler's_sum_of_powers_conjecture@Task
*
n = 250
len p5[] n
len h5[] 65537
for i = 0 to n - 1
   p5[i + 1] = i * i * i * i * i
   h5[p5[i + 1] mod 65537 + 1] = 1
.
func search a s .
   y = -1
   b = n
   while a + 1 < b
      i = (a + b) div 2
      if p5[i + 1] > s
         b = i
      elif p5[i + 1] < s
         a = i
      else
         a = b
         y = i
      .
   .
   return y
.
for x0 = 0 to n - 1
   for x1 = 0 to x0
      sum1 = p5[x0 + 1] + p5[x1 + 1]
      for x2 = 0 to x1
         sum2 = p5[x2 + 1] + sum1
         for x3 = 0 to x2
            sum = p5[x3 + 1] + sum2
            if h5[sum mod 65537 + 1] = 1
               y = search x0 sum
               if y >= 0
                  print x0 & " " & x1 & " " & x2 & " " & x3 & " " & y
                  break 4
               .
            .
         .
      .
   .
.
*
* Even or odd
*
@ https://rosettacode.org/wiki/Even_or_odd@Task
*
a = 13
if a mod 2 = 0
   print a & " is even"
else
   print a & " is odd"
.
*
* Exponentiation operator
*
@ https://rosettacode.org/wiki/Exponentiation_operator@Task
*
func mypow n exp .
   r = 1
   if exp < 0
      exp = -exp
      n = 1 / n
   .
   for i to exp
      r *= n
   .
   return r
.
print mypow pi 2
print mypow 2 -2
*
* Extreme floating point values
*
@ https://rosettacode.org/wiki/Extreme_floating_point_values@Task
*
inf = 1 / 0
minus_inf = -1 / 0
minus_zero = -1 / inf
nan = 0.0 / 0.0
# 
# in Easylang there is -0, but when
# converting it to a string it becomes "0"
# 
print "positive  infinity: " & inf
print "negative infinity: " & minus_inf
print "negative zero: " & minus_zero
print "not a number: " & nan
# 
# some arithmetic 
print "+inf + 2 = " & inf + 2
print "+inf - 10.1 = " & inf - 10.1
print "+inf + -inf = " & inf + minus_inf
print "0 * +inf = " & 0 * inf
print "1/-0 = " & 1 / minus_zero
print "NaN + 1 = " & nan + 1
print "NaN + NaN = " & nan + nan
# 
# some comparisons
print "NaN == NaN = " & if nan = nan
print "0 = -0 = " & if 0 = minus_zero
*
* Factorial
*
@ https://rosettacode.org/wiki/Factorial@Task
*
func factorial n .
   r = 1
   for i = 2 to n
      r *= i
   .
   return r
.
print factorial 7
*
* Factors of an integer
*
@ https://rosettacode.org/wiki/Factors_of_an_integer@Task
*
n = 720
for i = 1 to n
  if n mod i = 0
    factors[] &= i
  .
.
print factors[]
*
* Fairshare between two and more
*
@ https://rosettacode.org/wiki/Fairshare_between_two_and_more@Task
*
func fairshare ind base .
   while ind > 0
      r += ind mod base
      ind = ind div base
   .
   r = r mod base
   return r
.
proc sequence n base . .
   write base & ": "
   for ind range0 n
      write (fairshare ind base) & " "
   .
   print ""
.
sequence 25 2
sequence 25 3
sequence 25 5
sequence 25 11
*
* Farey sequence
*
@ https://rosettacode.org/wiki/Farey_sequence@Task
*
proc farey n . .
   b = 1 ; c = 1 ; d = n
   write n & ": "
   repeat
      if n <= 11
         write " " & a & "/" & b
      .
      until c > n
      k = (n + b) div d
      aa = c ; bb = d ; cc = k * c - a ; dd = k * d - b
      a = aa ; b = bb ; c = cc ; d = dd
      items += 1
   .
   if n > 11
      print items & " items"
   else
      print ""
   .
.
for i = 1 to 11
   farey i
.
for i = 100 step 100 to 1000
   farey i
.
*
* Fibonacci sequence
*
@ https://rosettacode.org/wiki/Fibonacci_sequence@Task
*
func fib n .
   if n < 2
      return n
   .
   prev = 0
   val = 1
   for i = 2 to n
      h = prev + val
      prev = val
      val = h
   .
   return val
.
print fib 36
*
* Filter
*
@ https://rosettacode.org/wiki/Filter@Task
*
a[] = [ 1 2 3 4 5 6 7 8 9 ]
for i = 1 to len a[]
  if a[i] mod 2 = 0
    b[] &= a[i]
  .
.
print b[]
*
* Find common directory path
*
@ https://rosettacode.org/wiki/Find_common_directory_path@Task
*
func$ comdir path$[] .
   for i = 1 to len path$[1]
      c$ = substr path$[1] i 1
      for j = 2 to len path$[]
         if c$ <> substr path$[j] i 1
            break 2
         .
      .
      if c$ = "/"
         f = i - 1
      .
   .
   return substr path$[1] 1 f
.
a$[] &= "/home/user1/tmp/coverage/test"
a$[] &= "/home/user1/tmp/covert/operator"
a$[] &= "/home/user1/tmp/coven/members"
print comdir a$[]
*
* Find limit of recursion
*
@ https://rosettacode.org/wiki/Find_limit_of_recursion@Task
*
proc recurse i . .
   if i mod 10 = 0
      print i
   .
   recurse i + 1
.
recurse 1
*
* Find square difference
*
@ https://rosettacode.org/wiki/Find_square_difference@Task
*
repeat
   i += 1
   a = i * i
   b = (i - 1) * (i - 1)
   until a - b > 1000
.
print i
*
* Find the intersection of a line with a plane
*
@ https://rosettacode.org/wiki/Find_the_intersection_of_a_line_with_a_plane@Task
*
proc minus . l[] r[] res[] .
   len res[] 3
   for i to 3
      res[i] = l[i] - r[i]
   .
.
func dot l[] r[] .
   for i to 3
      res += l[i] * r[i]
   .
   return res
.
proc scale f . l[] .
   for i to 3
      l[i] = l[i] * f
   .
.
proc inter_point rv[] rp[] pn[] pp[] . res[] .
   minus rp[] pp[] dif[]
   prd1 = dot dif[] pn[]
   prd2 = dot rv[] pn[]
   scale (prd1 / prd2) rv[]
   minus rp[] rv[] res[]
.
rv[] = [ 0.0 -1.0 -1.0 ]
rp[] = [ 0.0 0.0 10.0 ]
pn[] = [ 0.0 0.0 1.0 ]
pp[] = [ 0.0 0.0 5.0 ]
inter_point rv[] rp[] pn[] pp[] res[]
print res[]
*
* FizzBuzz
*
@ https://rosettacode.org/wiki/FizzBuzz@Task
*
for i = 1 to 100
  if i mod 15 = 0
    print "FizzBuzz"
  elif i mod 5 = 0
    print "Buzz"
  elif i mod 3 = 0
    print "Fizz"
  else
    print i
  .
.
*
* Forest fire
*
@ https://rosettacode.org/wiki/Forest_fire@Task
*
p_fire = 0.00002
p_tree = 0.002
# 
len f[] 102 * 102
len p[] len f[]
background 100
clear
for r = 0 to 99
   for c = 0 to 99
      i = r * 102 + c + 104
      if randomf < 0.5
         f[i] = 1
      .
   .
.
timer 0
# 
subr show
   for r = 0 to 99
      for c = 0 to 99
         i = r * 102 + c + 104
         h = f[i]
         if h <> p[i]
            move c + 0.5 r + 0.5
            if h = 0
               color 100
               circle 0.6
            elif h = 1
               color 151
               circle 0.5
            else
               color 9 * 100 + (18 - 2 * h) * 10
               circle 0.5
            .
         .
      .
   .
.
subr update
   swap f[] p[]
   for r = 0 to 99
      for c = 0 to 99
         i = r * 102 + c + 104
         if p[i] = 0
            f[i] = 0
            if randomf < p_tree
               f[i] = 1
            .
         elif p[i] = 1
            f[i] = 1
            s = p[i - 103] + p[i - 102] + p[i - 101]
            s += p[i - 1] + p[i + 1]
            s += p[i + 101] + p[i + 102] + p[i + 103]
            if s >= 9 or randomf < p_fire
               f[i] = 9
            .
         elif p[i] = 4
            f[i] = 0
         else
            f[i] = p[i] - 1
         .
      .
   .
.
on timer
   show
   update
   timer 0.2
.
*
* Four bit adder
*
@ https://rosettacode.org/wiki/Four_bit_adder@Task
*
proc xor a b . r .
   na = bitand bitnot a 1
   nb = bitand bitnot b 1
   r = bitor bitand a nb bitand b na
.
proc half_add a b . s c .
   xor a b s
   c = bitand a b
.
proc full_add a b c . s g .
   half_add a c x y
   half_add x b s z
   g = bitor y z
.
proc bit4add a4 a3 a2 a1 b4 b3 b2 b1 . s4 s3 s2 s1 c .
   full_add a1 b1 0 s1 c
   full_add a2 b2 c s2 c
   full_add a3 b3 c s3 c
   full_add a4 b4 c s4 c
.
write "1101 + 1011 = "
bit4add 1 1 0 1 1 0 1 1 s4 s3 s2 s1 c
print c & s4 & s3 & s2 & s1
*
* Fractal tree
*
@ https://rosettacode.org/wiki/Fractal_tree@Task
*
# Fractal tree
# 
color 555
proc tree x y deg n . .
   if n > 0
      linewidth n * 0.4
      move x y
      x += cos deg * n * 1.3 * (randomf + 0.5)
      y += sin deg * n * 1.3 * (randomf + 0.5)
      line x y
      tree x y deg - 20 n - 1
      tree x y deg + 20 n - 1
   .
.
timer 0
on timer
   clear
   tree 50 10 90 10
   timer 2
.
*
* Function definition
*
@ https://rosettacode.org/wiki/Function_definition@Task
*
func multiply a b .
   return a * b
.
print multiply 7 5
*
* Generate lower case ASCII alphabet
*
@ https://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet@Task
*
# Generated on an array
for i = 97 to 122
   alphabet$[] &= strchar i
.
print alphabet$[]
# Generated on a string
for i = 97 to 122
   alphabet$ &= strchar i
.
print alphabet$
*
* Giuga numbers
*
@ https://rosettacode.org/wiki/Giuga_numbers@Task
*
func giuga m .
   n = m
   for f = 2 to sqrt n
      while n mod f = 0
         if (m div f - 1) mod f <> 0
            return 0
         .
         n = n div f
         if f > n
            return 1
         .
      .
   .
.
n = 3
while cnt < 4
   if giuga n = 1
      cnt += 1
      print n
   .
   n += 1
.
*
* Goldbach's comet
*
@ https://rosettacode.org/wiki/Goldbach's_comet@Task
*
func isprim n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func goldbach n .
   for i = 2 to n div 2
      if isprim i = 1
         cnt += isprim (n - i)
      .
   .
   return cnt
.
numfmt 0 3
for n = 4 step 2 to 202
   write goldbach n
   if n mod 20 = 2
      print ""
   .
.
print goldbach 1000000
*
* Golden ratio/Convergence
*
@ https://rosettacode.org/wiki/Golden_ratio/Convergence@Task
*
phi0 = 1
repeat
   phi = 1 + 1 / phi0
   until abs (phi - phi0) < 1e-5
   phi0 = phi
   iter += 1
.
numfmt 10 0
print "Iterations: " & iter
print "Result: " & phi
print "Error: " & phi - (1 + sqrt 5) / 2
*
* Greatest common divisor
*
@ https://rosettacode.org/wiki/Greatest_common_divisor@Task
*
func gcd a b .
   while b <> 0
      h = b
      b = a mod b
      a = h
   .
   return a
.
print gcd 120 35
*
* Greatest element of a list
*
@ https://rosettacode.org/wiki/Greatest_element_of_a_list@Task
*
a[] = [ 2 9 4 3 8 5 ]
for e in a[]
  max = higher e max
.
print max
*
* Greyscale bars/Display
*
@ https://rosettacode.org/wiki/Greyscale_bars/Display@Task
*
n = 8
for row = 0 to 3
   sz = 100 / n
   for i = 0 to n - 1
      c = i / (n - 1)
      if row mod 2 = 1
         c = 1 - c
      .
      color3 c c c
      move sz * i 75 - row * 25
      rect sz + 1 25
      sleep 0.02
   .
   n *= 2
.
*
* Guess the number
*
@ https://rosettacode.org/wiki/Guess_the_number@Task
*
n = random 10
write "Guess a number between 1 and 10: "
repeat
  g = number input
  write g
  until g = n
  print " is wrong"
  write "try again: "
.
print " is correct. Well guessed!"
*
* Guess the number/With feedback
*
@ https://rosettacode.org/wiki/Guess_the_number/With_feedback@Task
*
print "Guess a number between 1 and 100!"
n = random 100
repeat
   g = number input
   write g
   if error = 1
      print "You must enter a number!"
   elif g > n
      print " is too high"
   elif g < n
      print " is too low"
   .
   until g = n
.
print " is correct"
*
* Hailstone sequence
*
@ https://rosettacode.org/wiki/Hailstone_sequence@Task
*
proc hailstone n . list[] .
   list[] = [ ]
   while n <> 1
      list[] &= n
      if n mod 2 = 0
         n = n / 2
      else
         n = 3 * n + 1
      .
   .
   list[] &= 1
.
hailstone 27 l[]
write "27 has length " & len l[] & " with "
for i to 4
   write l[i] & " "
.
write "... "
for i = len l[] - 3 to len l[]
   write l[i] & " "
.
print ""
for i = 1 to 100000
   hailstone i l[]
   if len l[] >= max_iter
      max_i = i
      max_iter = len l[]
   end
end
print max_i & " has length " & max_iter
*
* Hello world/Graphical
*
@ https://rosettacode.org/wiki/Hello_world/Graphical@Task
*
move 10 20
text "Goodbye, World!"
*
* Hello world/Newline omission
*
@ https://rosettacode.org/wiki/Hello_world/Newline_omission@Task
*
write "Goodbye, World!"
*
* Hello world/Text
*
@ https://rosettacode.org/wiki/Hello_world/Text@Task
*
print "Hello world!"
*
* Hilbert curve
*
@ https://rosettacode.org/wiki/Hilbert_curve@Task
*
order = 64
linewidth 32 / order
scale = 100 / order - 100 / (order * order)
proc hilbert x y lg i1 i2 . .
   if lg = 1
      line (order - x) * scale (order - y) * scale
      return
   .
   lg = lg div 2
   hilbert x + i1 * lg y + i1 * lg lg i1 1 - i2
   hilbert x + i2 * lg y + (1 - i2) * lg lg i1 i2
   hilbert x + (1 - i1) * lg y + (1 - i1) * lg lg i1 i2
   hilbert x + (1 - i2) * lg y + i2 * lg lg 1 - i1 i2
.
hilbert 0 0 order 0 0
*
* Horizontal sundial calculations
*
@ https://rosettacode.org/wiki/Horizontal_sundial_calculations@Task
*
func getn s$ .
   write s$
   v = number input
   print v
   return v
.
lat = getn "Enter latitude: "
lng = getn "Enter longitude: "
merid = getn "Enter legal meridian: "
slat = sin lat
diff = lng - merid
print ""
print "    sine of latitude: " & slat
print "    diff longitude: " & diff
print ""
print "Hour\tSun hour angle\tDial hour line angle"
for h = -6 to 6
   hra = 15 * h - diff
   hla = atan2 (slat * sin hra) cos hra
   print h + 12 & "\t" & hra & "\t\t" & hla
.
*
* Identity matrix
*
@ https://rosettacode.org/wiki/Identity_matrix@Task
*
proc idmat lng . mat[][] .
   len mat[][] lng
   for i to lng
      len mat[i][] lng
      mat[i][i] = 1
   .
.
idmat 4 m[][]
print m[][]
*
* Idiomatically determine all the lowercase and uppercase letters
*
@ https://rosettacode.org/wiki/Idiomatically_determine_all_the_lowercase_and_uppercase_letters@Task
*
for i = strcode "a" to strcode "z"
   write strchar i
.
print ""
for i = strcode "A" to strcode "Z"
   write strchar i
.
*
* Idoneal numbers
*
@ https://rosettacode.org/wiki/Idoneal_numbers@Task
*
maxCount = 65
while count < maxCount
   n += 1
   idoneal = 1
   a = 1
   while a + 2 < n and idoneal = 1
      b = a + 1
      repeat
         ab = a * b
         sum = 0
         if ab < n
            c = (n - ab) div (a + b)
            sum = ab + c * (b + a)
            if c > b and sum = n
               idoneal = 0
            .
            b += 1
         .
         until sum > n or idoneal = 0 or ab >= n
      .
      a += 1
   .
   if idoneal = 1
      count += 1
      write " " & n
   .
.
*
* Implicit type conversion
*
@ https://rosettacode.org/wiki/Implicit_type_conversion@Task
*
string$ = 32
print string$
*
* Inconsummate numbers in base 10
*
@ https://rosettacode.org/wiki/Inconsummate_numbers_in_base_10@Task
*
limit = 10000
maxn = 10000 * 9 * 4
# 
len consummate[] limit
# 
func digsum i .
   res = 0
   while i > 0
      res += i mod 10
      i = i div 10
   .
   return res
.
for d = 1 to maxn
   ds = digsum d
   if d mod ds = 0
      q = d / ds
      if q <= limit
         consummate[q] = 1
      .
   .
.
d = 1
repeat
   if d > len consummate[]
      print "error - increase limit"
      break 1
   .
   if consummate[d] = 0
      cnt += 1
      if cnt <= 50
         write d & " "
      .
   .
   until cnt = 1000
   d += 1
.
print ""
print ""
print d
*
* Increment a numerical string
*
@ https://rosettacode.org/wiki/Increment_a_numerical_string@Task
*
a$ = "12"
a$ = number a$ + 1
print a$
*
* Infinity
*
@ https://rosettacode.org/wiki/Infinity@Task
*
print number "inf"
*
* Input loop
*
@ https://rosettacode.org/wiki/Input_loop@Task
*
repeat
  l$ = input
  until error = 1
  print l$
.
*
* Integer comparison
*
@ https://rosettacode.org/wiki/Integer_comparison@Task
*
a = number input
b = number input
if a < b
  print "less"
.
if a = b
  print "equal"
.
if a > b
  print "greater"
.
*
* Integer sequence
*
@ https://rosettacode.org/wiki/Integer_sequence@Task
*
max = pow 2 53
repeat
   print i
   if i = 10
      print "."
      print "."
      i = max - 10
   .
   until i = max
   i += 1
.
*
* ISBN13 check digit
*
@ https://rosettacode.org/wiki/ISBN13_check_digit@Task
*
func ISBN13check isbn$ .
   for c$ in strchars isbn$
      if c$ <> "-"
         ndigs += 1
      .
      dig = number c$
      if ndigs mod 2 = 0
         dig *= 3
      .
      sum += dig
   .
   if sum mod 10 <> 0
      return 0
   .
   return 1
.
codes$[] = [ "978-0596528126" "978-0596528120" "978-1788399081" "978-1788399083" ]
for code$ in codes$[]
   if ISBN13check code$ = 1
      print code$ & " is a valid ISBN"
   else
      print code$ & " is not a valid ISBN"
   .
.
*
* Isqrt (integer square root) of X
*
@ https://rosettacode.org/wiki/Isqrt_(integer_square_root)_of_X@Task
*
func isqrt x .
   q = 1
   while q <= x
      q *= 4
   .
   while q > 1
      q = q div 4
      t = x - r - q
      r = r div 2
      if t >= 0
         x = t
         r = r + q
      .
   .
   return r
.
print "Integer square roots from 0 to 65:"
for n = 0 to 65
   write isqrt n & " "
.
print ""
print ""
print "Integer square roots of 7^n"
p = 7
n = 1
while n <= 21
   print n & " " & isqrt p
   n = n + 2
   p = p * 49
.
*
* Jewels and stones
*
@ https://rosettacode.org/wiki/Jewels_and_stones@Task
*
func count stones$ jewels$ .
   len d[] 65536
   for c$ in strchars jewels$
      d[strcode c$] = 1
   .
   for c$ in strchars stones$
      if d[strcode c$] = 1
         cnt += 1
      .
   .
   return cnt
.
print count "aAAbbbb" "aA"
print count "ZZ" "z"
*
* Jordan-Pólya numbers
*
@ https://rosettacode.org/wiki/Jordan-Pólya_numbers@Task
*
fastfunc jpnum m .
   n = m
   limite = 7
   while 1 = 1
      fac = 1
      i = 1
      while i < limite
         i += 1
         fac *= i
      .
      repeat
         q = n div fac
         if n mod fac = 0
            if q = 1
               return 1
            .
            n = q
         else
            fac = fac / i
            i -= 1
         .
         until i = 1
      .
      limite -= 1
      if limite = 0
         return 0
      .
      n = m
   .
.
numfmt 0 5
write 1
c = 1
n = 2
repeat
   if jpnum n = 1
      c += 1
      if c <= 50
         write n
         if c mod 10 = 0
            print ""
         .
      .
      sn = n
   .
   n += 2
   until n >= 1e8
.
print ""
print "The largest Jordan-Polya number before 100 million: " & sn
*
* Josephus problem
*
@ https://rosettacode.org/wiki/Josephus_problem@Task
*
n = 41
k = 3
print "prisoners: " & n
print "step size: " & k
for i = 1 to n
   lm = (lm + k) mod i
.
print "final survivor: " & lm
*
* Julia set
*
@ https://rosettacode.org/wiki/Julia_set@Task
*
cx = -0.7
cy = 0.27015
for y = 0 to 299
  for x = 0 to 299
    zx = (x - 150) / 100
    zy = (y - 150) / 150
    color3 0 0 0
    for iter = 0 to 127
      if zx * zx + zy * zy > 4
        color3 iter / 16 0 0
        break 1
      .
      h = zx * zx - zy * zy + cx
      zy = 2 * zx * zy + cy
      zx = h
    .
    move x / 3 y / 3
    rect 0.4 0.4
  .
.
*
* Klarner-Rado sequence
*
@ https://rosettacode.org/wiki/Klarner-Rado_sequence@Task
*
m2 = 1
m3 = 1
for o = 1 to 1000000
   if m2 < m3
      m = m2
   else
      m = m3
   .
   klarner_rado[] &= m
   if m2 = m
      i2 += 1
      m2 = klarner_rado[i2] * 2 + 1
   .
   if m3 = m
      i3 += 1
      m3 = klarner_rado[i3] * 3 + 1
   .
.
for i = 1 to 100
   write klarner_rado[i] & " "
.
print ""
print ""
i = 1000
while i < o
   write klarner_rado[i] & " "
   i *= 10
.
*
* Knapsack problem/0-1
*
@ https://rosettacode.org/wiki/Knapsack_problem/0-1@Task
*
name$[] = [ "map" "compass" "water" "sandwich" "glucose" "tin" "banana" "apple" "cheese" "beer" "suntan cream" "camera" "t-shirt" "trousers" "umbrella" "waterproof trousers" "waterproof overclothes" "note-case" "sunglasses" "towel" "socks" "book" ]
weight[] = [ 9 13 153 50 15 68 27 39 23 52 11 32 24 48 73 42 43 22 7 18 4 30 ]
value[] = [ 150 35 200 160 60 45 60 40 30 10 70 30 15 10 40 70 75 80 20 12 50 10 ]
max_w = 400
# 
proc solve i maxw . items[] wres vres .
   if i <= 0
      wres = 0
      vres = 0
      items[] = [ ]
   elif weight[i] > maxw
      solve i - 1 maxw items[] wres vres
   else
      solve i - 1 maxw items[] wres vres
      solve i - 1 maxw - weight[i] items1[] w1 v1
      v1 += value[i]
      if v1 > vres
         swap items[] items1[]
         items[] &= i
         wres = w1 + weight[i]
         vres = v1
      .
   .
.
solve len weight[] max_w items[] w v
print "weight: " & w
print "value: " & v
print "items:"
for item in items[]
   print "  " & name$[item]
.
*
* Knuth shuffle
*
@ https://rosettacode.org/wiki/Knuth_shuffle@Task
*
proc shuffle . a[] .
   for i = len a[] downto 2
      r = random i
      swap a[r] a[i]
   .
.
arr[] = [ 1 2 3 ]
shuffle arr[]
print arr[]
*
* Koch curve
*
@ https://rosettacode.org/wiki/Koch_curve@Task
*
proc koch x1 y1 x2 y2 iter . .
   x3 = (x1 * 2 + x2) / 3
   y3 = (y1 * 2 + y2) / 3
   x4 = (x1 + x2 * 2) / 3
   y4 = (y1 + y2 * 2) / 3
   x5 = x3 + (x4 - x3) * cos 60 + (y4 - y3) * sin 60
   y5 = y3 - (x4 - x3) * sin 60 + (y4 - y3) * cos 60
   if iter > 0
      iter -= 1
      koch x1 y1 x3 y3 iter
      koch x3 y3 x5 y5 iter
      koch x5 y5 x4 y4 iter
      koch x4 y4 x2 y2 iter
   else
      line x1 y1
      line x3 y3
      line x5 y5
      line x4 y4
      line x2 y2
   .
.
linewidth 0.3
x1 = 15
y1 = 30
move x1 y1
for ang = 0 step 120 to 240
   x2 = x1 + 70 * cos ang
   y2 = y1 + 70 * sin ang
   koch x1 y1 x2 y2 4
   x1 = x2
   y1 = y2
.
*
* Lah numbers
*
@ https://rosettacode.org/wiki/Lah_numbers@Task
*
func fac n .
   r = 1
   for i = 2 to n
      r *= i
   .
   return r
.
print 0
print "0 1"
for n = 2 to 12
   write 0 & " " & fac n & " "
   for k = 2 to n - 1
      write fac n * fac (n - 1) / (fac k * fac (k - 1)) / fac (n - k) & " "
   .
   print 1 & " "
.
*
* Langton's ant
*
@ https://rosettacode.org/wiki/Langton's_ant@Task
*
len f[] 100 * 100
proc show . .
   for y = 0 to 99
      for x = 0 to 99
         if f[y * 100 + x + 1] = 1
            move x y
            rect 1 1
         .
      .
   .
.
proc run x y dir . .
   dx[] = [ 0 1 0 -1 ]
   dy[] = [ -1 0 1 0 ]
   while x >= 0 and x < 100 and y >= 0 and y < 100
      v = f[y * 100 + x + 1]
      f[y * 100 + x + 1] = 1 - v
      dir = (dir + 2 * v) mod 4 + 1
      x += dx[dir]
      y += dy[dir]
   .
.
run 70 40 0
show
*
* Largest number divisible by its digits
*
@ https://rosettacode.org/wiki/Largest_number_divisible_by_its_digits@Task
*
global found dig[] .
proc test . .
   for i to len dig[]
      n = n * 10 + dig[i]
   .
   for i to len dig[]
      if n mod dig[i] <> 0
         return
      .
   .
   found = 1
   print n
.
len use[] 9
proc perm pos . .
   if found = 1
      return
   .
   for i = 9 downto 1
      dig[pos] = i
      if use[i] = 0
         use[i] = 1
         if pos = len dig[]
            test
         else
            perm pos + 1
         .
         use[i] = 0
      .
   .
.
for ndig = 9 downto 1
   len dig[] ndig
   perm 1
.
*
* Largest proper divisor of n
*
@ https://rosettacode.org/wiki/Largest_proper_divisor_of_n@Task
*
func lpdiv v .
   r = 1
   for i = 2 to v div 2
      if v mod i = 0
         r = i
      .
   .
   return r
.
numfmt 0 3
for i = 1 to 100
   write lpdiv i
   if i mod 10 = 0
      print ""
   .
.
*
* Leonardo numbers
*
@ https://rosettacode.org/wiki/Leonardo_numbers@Task
*
proc leonardo L0 L1 add . .
   print "L0:" & L0 & " L1:" & L1 & " add:" & add
   write L0 & " "
   write L1 & " "
   for i = 2 to 24
      tmp = L0
      L0 = L1
      L1 = tmp + L1 + add
      write L1 & " "
   .
   print ""
.
leonardo 1 1 1
leonardo 0 1 0
*
* Letter frequency
*
@ https://rosettacode.org/wiki/Letter_frequency@Task
*
len d[] 26
repeat
   s$ = input
   until s$ = ""
   for c$ in strchars s$
      c = strcode c$
      if c >= 97 and c <= 122
         c -= 32
      .
      if c >= 65 and c <= 91
         d[c - 64] += 1
      .
   .
.
for i to 26
   write strchar (96 + i) & ": "
   print d[i]
.
input_data
Open a text file and count the occurrences of each letter.
Some of these programs count all characters (including
punctuation), but some only count letters A to Z.
Other tasks related to string operations:
*
* Levenshtein distance
*
@ https://rosettacode.org/wiki/Levenshtein_distance@Task
*
func dist s1$ s2$ .
   if len s1$ = 0
      return len s2$
   .
   if len s2$ = 0
      return len s1$
   .
   c1$ = substr s1$ 1 1
   c2$ = substr s2$ 1 1
   s1rest$ = substr s1$ 2 len s1$
   s2rest$ = substr s2$ 2 len s2$
   # 
   if c1$ = c2$
      return dist s1rest$ s2rest$
   .
   min = lower dist s1rest$ s2rest$ dist s1$ s2rest$
   min = lower min dist s1rest$ s2rest$
   return min + 1
.
print dist "kitten" "sitting"
print dist "rosettacode" "raisethysword"
*
* Literals/Floating point
*
@ https://rosettacode.org/wiki/Literals/Floating_point@Task
*
decimal = 57.1
decimalWithE = 5710E-2
hexadecimal = 0x39.1999999999
print decimal
print decimalWithE
print hexadecimal
*
* Literals/Integer
*
@ https://rosettacode.org/wiki/Literals/Integer@Task
*
decimal = 57
hexadecimal = 0x39
print decimal
print hexadecimal
*
* Literals/String
*
@ https://rosettacode.org/wiki/Literals/String@Task
*
print "EasyLang"
print "简"
*
* Logical operations
*
@ https://rosettacode.org/wiki/Logical_operations@Task
*
proc logic a b . .
   if a = 1 and b = 1
      r1 = 1
   .
   if a = 1 or b = 1
      r2 = 1
   .
   if a = 0
      r3 = 1
   .
   print r1 & " " & r2 & " " & r3
.
logic 0 0
logic 0 1
logic 1 0
logic 1 1
*
* Long multiplication
*
@ https://rosettacode.org/wiki/Long_multiplication@Task
*
func$ mult a$ b$ .
   a[] = number strchars a$
   b[] = number strchars b$
   len r[] len a[] + len b[]
   for ib = len b[] downto 1
      h = 0
      for ia = len a[] downto 1
         h += r[ia + ib] + b[ib] * a[ia]
         r[ia + ib] = h mod 10
         h = h div 10
      .
      r[ib] += h
   .
   r$ = ""
   for i = 1 to len r[]
      if r$ <> "" or r[i] <> 0 or i = len r[]
         r$ &= r[i]
      .
   .
   return r$
.
print mult "18446744073709551616" "18446744073709551616"
*
* Longest common substring
*
@ https://rosettacode.org/wiki/Longest_common_substring@Task
*
func$ lcs a$ b$ .
   if a$ = "" or b$ = ""
      return ""
   .
   while b$ <> ""
      for j = len b$ downto 1
         l$ = substr b$ 1 j
         for k = 1 to len a$ - j + 1
            if substr a$ k j = l$
               if len l$ > len max$
                  max$ = l$
               .
               break 2
            .
         .
      .
      b$ = substr b$ 2 -1
   .
   return max$
.
print lcs "thisisatest" "testing123testing"
print lcs "thisisatest" "stesting123testing"
print lcs "thisisatestxestinoo" "xxtesting123testing"
*
* Loops/Break
*
@ https://rosettacode.org/wiki/Loops/Break@Task
*
repeat
  a = random 20
  print a
  until a = 10
  print random 20
.
*
* Loops/Do-while
*
@ https://rosettacode.org/wiki/Loops/Do-while@Task
*
value = 0
repeat
   value += 1
   print value
   until value mod 6 = 0
.
*
* Loops/Downward for
*
@ https://rosettacode.org/wiki/Loops/Downward_for@Task
*
for i = 10 downto 0
  print i
.
*
* Loops/For
*
@ https://rosettacode.org/wiki/Loops/For@Task
*
for i = 1 to 5
  for j = 1 to i
    write "*"
  .
  print ""
.
*
* Loops/For with a specified step
*
@ https://rosettacode.org/wiki/Loops/For_with_a_specified_step@Task
*
# Prints even numbers from 0 to 100
for i = 0 step 2 to 100
   print i
.
*
* Loops/Foreach
*
@ https://rosettacode.org/wiki/Loops/Foreach@Task
*
for i in [ 5 1 19 25 12 1 14 7 ]
   print i
.
*
* Loops/Increment loop index within loop body
*
@ https://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body@Task
*
fastfunc isprim num .
   if num mod 2 = 0 and num > 2
      return 0
   .
   i = 3
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
counter = 0
maxnum = pow 2 53
for i = 42 to maxnum
   if isprim i = 1
      counter += 1
      print "n=" & counter & " " & i
      if counter >= 42
         break 1
      .
      i += i - 1
   .
.
*
* Loops/Infinite
*
@ https://rosettacode.org/wiki/Loops/Infinite@Task
*
while 1 = 1
   print "SPAM"
.
*
* Loops/N plus one half
*
@ https://rosettacode.org/wiki/Loops/N_plus_one_half@Task
*
for i = 1 to 10
   write i
   if i < 10
      write ", "
   .
.
*
* Loops/Nested
*
@ https://rosettacode.org/wiki/Loops/Nested@Task
*
arr[][] = [ [ 2 12 10 4 ] [ 18 11 20 2 ] ]
for i to len arr[][]
   for j to len arr[i][]
      if arr[i][j] = 20
         print "20 at " & i & "," & j
         break 2
      .
   .
.
*
* Loops/While
*
@ https://rosettacode.org/wiki/Loops/While@Task
*
i = 1024
while i > 0
  print i
  i = i div 2
.
*
* Mandelbrot set
*
@ https://rosettacode.org/wiki/Mandelbrot_set@Task
*
# Mandelbrot
#  
res = 4
maxiter = 200
# 
# better but slower:
# res = 8
# maxiter = 300
# 
#  
mid = res * 50
center_x = 3 * mid / 2
center_y = mid
scale = mid
# 
background 000
textsize 2
# 
fastfunc iter cx cy maxiter .
   while xx + yy < 4 and it < maxiter
      y = 2 * x * y + cy
      x = xx - yy + cx
      xx = x * x
      yy = y * y
      it += 1
   .
   return it
.
proc draw . .
   clear
   for scr_y = 0 to 2 * mid - 1
      cy = (scr_y - center_y) / scale
      for scr_x = 0 to 2 * mid - 1
         cx = (scr_x - center_x) / scale
         it = iter cx cy maxiter
         if it < maxiter
            color3 it / 20 it / 100 it / 150
            move scr_x / res scr_y / res
            rect 1 / res 1 / res
         .
      .
   .
   color 990
   move 1 1
   text "Short press to zoom in, long to zoom out"
.
on mouse_down
   time0 = systime
.
on mouse_up
   center_x += mid - mouse_x * res
   center_y += mid - mouse_y * res
   if systime - time0 < 0.3
      center_x -= mid - center_x
      center_y -= mid - center_y
      scale *= 2
   else
      center_x += (mid - center_x) * 3 / 4
      center_y += (mid - center_y) * 3 / 4
      scale /= 4
   .
   draw
.
draw
*
* Mastermind
*
@ https://rosettacode.org/wiki/Mastermind@Task
*
# Mastermind:w90
# 
col[] = [ 802 990 171 229 950 808 ]
len code[] 4
len guess[] 4
# 
subr init_vars
   row = 0
.
proc draw_rate r black white . .
   for j range0 2
      for c range0 2
         move c * 3.5 + 71.5 r * 11.5 + 9.4 - j * 3.5
         if black > 0
            color 000
            circle 1.4
            black -= 1
         elif white > 0
            color 999
            circle 1.4
            white -= 1
         else
            color 310
            circle 0.7
         .
      .
   .
.
proc show_code . .
   color 531
   move 22 92
   rect 46 8
   for i to 4
      move i * 8 + 20 97
      color col[code[i]]
      circle 2
   .
.
proc draw_guess . .
   for c to 4
      move c * 12 + 8 row * 11.5 + 7.5
      color col[guess[c]]
      circle 3.8
   .
.
proc next_row . .
   color 420
   linewidth 11
   move 17 row * 11.5 + 7.5
   line 60 row * 11.5 + 7.5
   draw_guess
   move 73.5 row * 11.5 + 7.5
   color 310
   circle 5.0
   color 753
   move 71.5 row * 11.5 + 5
   textsize 7
   text "✓"
.
proc rate . .
   move 73.5 row * 11.5 + 7.5
   color 531
   circle 5.2
   c[] = code[]
   g[] = guess[]
   for i to 4
      if c[i] = g[i]
         black += 1
         c[i] = -1
         g[i] = -2
      .
   .
   for i to 4
      for j to 4
         if c[i] = g[j]
            white += 1
            c[i] = -1
            g[j] = -2
         .
      .
   .
   draw_rate row black white
   color 531
   linewidth 12
   move 17 row * 11.5 + 7.5
   line 60 row * 11.5 + 7.5
   draw_guess
   row += 1
   if black = 4
      row = 8
   .
   if row = 8
      show_code
      timer 2
   else
      next_row
   .
.
on timer
   row = -2
.
proc new . .
   init_vars
   for i to 4
      code[i] = random 6
   .
   color 531
   move 10 10
   rect 70 80
   linewidth 10
   move 5 95
   line 5 5
   line 85 5
   line 85 95
   line 5 95
   color 310
   linewidth 7
   move 28 96.5
   line 58 96.5
   move 30 95
   color 864
   textsize 4
   text "Mastermind"
   color 310
   linewidth 0.5
   move 10 90
   line 10 4
   move 67 90
   line 67 4
   move 80 90
   line 80 4
   for r range0 8
      for c range0 4
         move c * 12 + 20 r * 11.5 + 7.5
         circle 2
      .
      draw_rate r 0 0
   .
   guess[1] = 1
   guess[2] = 1
   guess[3] = 2
   guess[4] = 2
   next_row
.
proc do_move . .
   c = (mouse_x - 15) div 12
   guess[c + 1] = guess[c + 1] mod 6 + 1
   draw_guess
.
on mouse_down
   if row = -2
      new
   elif mouse_y > row * 11.5 + 0.5 and mouse_y < row * 11.5 + 10.5 and row < 8
      if mouse_x > 15 and mouse_x < 61
         do_move
      elif mouse_x > 67 and mouse_x < 80
         rate
      .
   .
.
new
*
* Matrix transposition
*
@ https://rosettacode.org/wiki/Matrix_transposition@Task
*
proc transpose . m[][] .
   len n[][] len m[1][]
   for i to len n[][]
      for j to len m[][]
         n[i][] &= m[j][i]
      .
   .
   swap n[][] m[][]
.
m[][] = [ [ 1 2 3 4 ] [ 5 6 7 8 ] [ 9 10 11 12 ] ]
print m[][]
print ""
transpose m[][]
print m[][]
*
* Maximum triangle path sum
*
@ https://rosettacode.org/wiki/Maximum_triangle_path_sum@Task
*
a[] = [ 0 0 ]
repeat
   s$ = input
   until s$ = ""
   i = 1
   while substr s$ i 1 = " "
      i += 1
   .
   s$ = "0 " & substr s$ i -1 & " 0"
   b[] = number strsplit s$ " "
   for i = 2 to len b[] - 1
      b[i] = higher (b[i] + a[i - 1]) (b[i] + a[i])
   .
   swap a[] b[]
.
for v in a[]
   max = higher max v
.
print max
# 
input_data
                          55
                        94 48
                       95 30 96
                     77 71 26 67
                    97 13 76 38 45
                  07 36 79 16 37 68
                 48 07 09 18 70 26 06
               18 72 79 46 59 79 29 90
              20 76 87 11 32 07 07 49 18
            27 83 58 35 71 11 25 57 29 85
           14 64 36 96 27 11 58 56 92 18 55
         02 90 03 60 48 49 41 46 33 36 47 23
        92 50 48 02 36 59 42 79 72 20 82 77 42
      56 78 38 80 39 75 02 71 66 66 01 03 55 72
     44 25 67 84 71 67 11 61 40 57 58 89 40 56 36
   85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52
  06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15
27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93
*
* Maze generation
*
@ https://rosettacode.org/wiki/Maze_generation@Task
*
size = 15
n = 2 * size + 1
f = 100 / (n - 0.5)
len m[] n * n
# 
background 000
proc show_maze . .
   clear
   for i = 1 to len m[]
      if m[i] = 0
         x = (i - 1) mod n
         y = (i - 1) div n
         color 999
         move x * f - f / 2 y * f - f / 2
         rect f * 1.5 f * 1.5
      .
   .
   sleep 0.01
.
offs[] = [ 1 n -1 (-n) ]
# 
proc m_maze pos . .
   m[pos] = 0
   show_maze
   d[] = [ 1 2 3 4 ]
   for i = 4 downto 1
      d = random i
      dir = offs[d[d]]
      d[d] = d[i]
      if m[pos + dir] = 1 and m[pos + 2 * dir] = 1
         m[pos + dir] = 0
         m_maze pos + 2 * dir
      .
   .
.
endpos = n * n - 1
proc make_maze . .
   for i = 1 to len m[]
      m[i] = 1
   .
   for i = 1 to n
      m[i] = 2
      m[n * i] = 2
      m[n * i - n + 1] = 2
      m[n * n - n + i] = 2
   .
   h = 2 * random 15 - n + n * 2 * random 15
   m_maze h
   m[endpos] = 0
   endpos += n
.
make_maze
show_maze
*
* Maze solving
*
@ https://rosettacode.org/wiki/Maze_solving@Task
*
size = 15
n = 2 * size + 1
f = 100 / (n - 0.5)
len m[] n * n
# 
background 000
proc show_maze . .
   clear
   for i = 1 to len m[]
      if m[i] = 0
         x = (i - 1) mod n
         y = (i - 1) div n
         color 999
         move x * f - f / 2 y * f - f / 2
         rect f * 1.5 f * 1.5
      .
   .
   sleep 0.01
.
offs[] = [ 1 n -1 (-n) ]
proc m_maze pos . .
   m[pos] = 0
   show_maze
   d[] = [ 1 2 3 4 ]
   for i = 4 downto 1
      d = random i
      dir = offs[d[d]]
      d[d] = d[i]
      if m[pos + dir] = 1 and m[pos + 2 * dir] = 1
         m[pos + dir] = 0
         m_maze pos + 2 * dir
      .
   .
.
endpos = n * n - 1
proc make_maze . .
   for i = 1 to len m[]
      m[i] = 1
   .
   for i = 1 to n
      m[i] = 2
      m[n * i] = 2
      m[n * i - n + 1] = 2
      m[n * n - n + i] = 2
   .
   h = 2 * random 15 - n + n * 2 * random 15
   m_maze h
   m[endpos] = 0
.
make_maze
show_maze
# 
proc mark pos col . .
   x = (pos - 1) mod n
   y = (pos - 1) div n
   color col
   move x * f + f / 4 y * f + f / 4
   circle f / 3.5
.
global found .
proc solve dir0 pos . .
   if found = 1
      return
   .
   mark pos 900
   sleep 0.05
   if pos = endpos
      found = 1
      return
   .
   of = random 4 - 1
   for h = 1 to 4
      dir = (h + of) mod1 4
      posn = pos + offs[dir]
      if dir <> dir0 and m[posn] = 0
         solve (dir + 1) mod 4 + 1 posn
         if found = 0
            mark posn 888
            sleep 0.08
         .
      .
   .
.
sleep 1
solve 0 n + 2
*
* MD5/Implementation
*
@ https://rosettacode.org/wiki/MD5/Implementation@Task
*
len md5k[] 64
proc md5init . .
   for i = 1 to 64
      md5k[i] = floor (0x100000000 * abs sin (i * 180 / pi))
   .
.
md5init
# 
proc md5 inp$ . s$ .
   subr addinp
      if inp4 = 1
         inp[] &= 0
      .
      inp[len inp[]] += b * inp4
      inp4 *= 0x100
      if inp4 = 0x100000000
         inp4 = 1
      .
   .
   s[] = [ 7 12 17 22 7 12 17 22 7 12 17 22 7 12 17 22 5 9 14 20 5 9 14 20 5 9 14 20 5 9 14 20 4 11 16 23 4 11 16 23 4 11 16 23 4 11 16 23 6 10 15 21 6 10 15 21 6 10 15 21 6 10 15 21 ]
   inp[] = [ ]
   inp4 = 1
   for i = 1 to len inp$
      b = strcode substr inp$ i 1
      addinp
   .
   b = 0x80
   addinp
   while len inp[] mod 16 <> 14 or inp4 <> 1
      b = 0
      addinp
   .
   h = len inp$ * 8
   for i = 1 to 4
      b = h mod 0x100
      addinp
      h = h div 0x100
   .
   inp[] &= 0
   # 
   a0 = 0x67452301
   b0 = 0xefcdab89
   c0 = 0x98badcfe
   d0 = 0x10325476
   for chunk = 1 step 16 to len inp[] - 15
      a = a0 ; b = b0 ; c = c0 ; d = d0
      for i = 1 to 64
         if i <= 16
            h1 = bitand b c
            h2 = bitand bitnot b d
            f = bitor h1 h2
            g = i - 1
         elif i <= 32
            h1 = bitand d b
            h2 = bitand bitnot d c
            f = bitor h1 h2
            g = (5 * i - 4) mod 16
         elif i <= 48
            h1 = bitxor b c
            f = bitxor h1 d
            g = (3 * i + 2) mod 16
         else
            h1 = bitor b bitnot d
            f = bitxor c h1
            g = (7 * i - 7) mod 16
         .
         f = (f + a + md5k[i] + inp[chunk + g])
         a = d
         d = c
         c = b
         h1 = bitshift f s[i]
         h2 = bitshift f (s[i] - 32)
         b = (b + h1 + h2)
      .
      a0 += a ; b0 += b ; c0 += c ; d0 += d
   .
   s$ = ""
   for a in [ a0 b0 c0 d0 ]
      for i = 1 to 4
         b = a mod 256
         a = a div 256
         for h in [ b div 16 b mod 16 ]
            h += 48
            if h > 57
               h += 39
            .
            s$ &= strchar h
         .
      .
   .
.
repeat
   s$ = input
   until error = 1
   md5 s$ h$
   print h$
.
input_data
a
abc
message digest
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
12345678901234567890123456789012345678901234567890123456789012345678901234567890
*
* Middle three digits
*
@ https://rosettacode.org/wiki/Middle_three_digits@Task
*
func$ midThreeDigits num .
   trueNumber$ = abs num
   if (len trueNumber$ < 3) or (len trueNumber$ mod 2 = 0)
      r$ = "error"
   else
      r$ = substr trueNumber$ ((len trueNumber$ - 3) / 2 + 1) 3
   .
   return r$
.
numbers[] = [ 123 12345 1234567 987654321 10001 -10001 -123 -100 100 -12345 1 2 -1 -10 2002 -2002 0 ]
for i in numbers[]
   print midThreeDigits i
.
*
* Minesweeper game
*
@ https://rosettacode.org/wiki/Minesweeper_game@Task
*
len cell[] 56
len cnt[] 56
len flag[] 56
# 
subr initvars
   state = 0
   ticks = 0
   indx = -1
   no_time = 0
.
func getind r c .
   ind = -1
   if r >= 0 and r <= 6 and c >= 0 and c <= 7
      ind = r * 8 + c + 1
   .
   return ind
.
proc draw_cell ind h . .
   ind -= 1
   r = ind div 8
   c = ind mod 8
   x = c * 12 + 2.5
   y = r * 12 + 2.5
   move x y
   rect 11 11
   if h > 0
      # count
      move x + 3 y + 3
      color 000
      text h
   elif h = -3
      # flag
      x += 4
      color 000
      linewidth 0.8
      move x y + 3
      line x y + 8
      color 600
      linewidth 2
      move x + 0.5 y + 7
      line x + 2 y + 7
   elif h <> 0
      # mine
      color 333
      if h = -2
         color 800
      .
      move x + 5 y + 5
      circle 3
      line x + 8 y + 9
   .
.
proc open ind . .
   if ind <> -1 and cell[ind] = 0
      cell[ind] = 2
      flag[ind] = 0
      color 686
      draw_cell ind cnt[ind]
      if cnt[ind] = 0
         ind -= 1
         r0 = ind div 8
         c0 = ind mod 8
         for r = r0 - 1 to r0 + 1
            for c = c0 - 1 to c0 + 1
               if r <> r0 or c <> c0
                  open getind r c
               .
            .
         .
      .
   .
.
proc show_mines m . .
   for ind to 56
      if cell[ind] = 1
         color 686
         if m = -1
            color 353
         .
         draw_cell ind m
      .
   .
.
proc outp col s$ . .
   move 2.5 87
   color col
   rect 59 11
   color 000
   move 5 90
   text s$
.
proc upd_info . .
   for i to 56
      nm += flag[i]
      if cell[i] < 2
         nc += 1
      .
   .
   if nc = 8
      outp 484 "Well done"
      show_mines -1
      state = 1
   else
      outp 464 8 - nm & " mines left"
   .
.
proc test ind . .
   if cell[ind] < 2 and flag[ind] = 0
      if cell[ind] = 1
         show_mines -1
         color 686
         draw_cell ind -2
         outp 844 "B O O M !"
         state = 1
      else
         open ind
         upd_info
      .
   .
.
background 676
proc start . .
   clear
   color 353
   for ind to 56
      cnt[ind] = 0
      cell[ind] = 0
      flag[ind] = 0
      draw_cell ind 0
   .
   n = 8
   while n > 0
      c = random 8 - 1
      r = random 7 - 1
      ind = r * 8 + c + 1
      if cell[ind] = 0
         n -= 1
         cell[ind] = 1
         for rx = r - 1 to r + 1
            for cx = c - 1 to c + 1
               ind = getind rx cx
               if ind > -1
                  cnt[ind] += 1
               .
            .
         .
      .
   .
   initvars
   outp 464 ""
   textsize 4
   move 5 93
   text "Minesweeper - 8 mines"
   move 5 88.2
   text "Long-press for flagging"
   textsize 6
   timer 0
.
on mouse_down
   if state = 0
      if mouse_y > 86 and mouse_x > 60
         no_time = 1
         move 64.5 87
         color 464
         rect 33 11
      .
      indx = getind ((mouse_y - 2) div 12) ((mouse_x - 2) div 12)
      ticks0 = ticks
   elif state = 3
      start
   .
.
on mouse_up
   if state = 0 and indx <> -1
      test indx
   .
   indx = -1
.
on timer
   if state = 1
      state = 2
      timer 1
   elif state = 2
      state = 3
   elif no_time = 0 and ticks > 3000
      outp 844 "B O O M !"
      show_mines -2
      state = 2
      timer 1
   else
      if indx > 0 and ticks = ticks0 + 2
         if cell[indx] < 2
            color 353
            flag[indx] = 1 - flag[indx]
            opt = 0
            if flag[indx] = 1
               opt = -3
            .
            draw_cell indx opt
            upd_info
         .
         indx = -1
      .
      if no_time = 0 and ticks mod 10 = 0
         move 64.5 87
         color 464
         if ticks >= 2500
            color 844
         .
         rect 33 11
         color 000
         move 66 90
         text "Time:" & 300 - ticks / 10
      .
      ticks += 1
      timer 0.1
   .
.
start
*
* Modular inverse
*
@ https://rosettacode.org/wiki/Modular_inverse@Task
*
func mod_inv a b .
   b0 = b
   x1 = 1
   if b = 1
      return 1
   .
   while a > 1
      q = a div b
      t = b
      b = a mod b
      a = t
      t = x0
      x0 = x1 - q * x0
      x1 = t
   .
   if x1 < 0
      x1 += b0
   .
   return x1
.
print mod_inv 42 2017
*
* Monte Carlo methods
*
@ https://rosettacode.org/wiki/Monte_Carlo_methods@Task
*
func mc n .
   for i = 1 to n
      x = randomf
      y = randomf
      if x * x + y * y < 1
         hit += 1
      .
   .
   return 4.0 * hit / n
.
numfmt 4 0
print mc 10000
print mc 100000
print mc 1000000
print mc 10000000
*
* Monty Hall problem
*
@ https://rosettacode.org/wiki/Monty_Hall_problem@Task
*
max = 1000000
for i = 1 to max
   car_door = random 3
   chosen_door = random 3
   if car_door <> chosen_door
      montys_door = 6 - car_door - chosen_door
   else
      repeat
         montys_door = random 3
         until montys_door <> car_door
      .
   .
   if car_door = chosen_door
      stay += 1
   .
   if car_door = 6 - montys_door - chosen_door
      switch += 1
   .
.
print "If you stick to your choice, you have a " & stay / max * 100 & " percent chance to win"
print "If you switched, you have a " & switch / max * 100 & " percent chance to win"
*
* Morse code
*
@ https://rosettacode.org/wiki/Morse_code@Task
*
txt$ = "sos sos"
# 
chars$[] = strchars "abcdefghijklmnopqrstuvwxyz "
code$[] = [ ".-" "-..." "-.-." "-.." "." "..-." "--." "...." ".." ".---" "-.-" ".-.." "--" "-." "---" ".--." "--.-" ".-." "..." "-" "..-" "...-" ".--" "-..-" "-.--" "--.." " " ]
# 
proc morse ch$ . .
   ind = 1
   while ind <= len chars$[] and chars$[ind] <> ch$
      ind += 1
   .
   if ind <= len chars$[]
      write ch$ & " "
      sleep 0.4
      for c$ in strchars code$[ind]
         write c$
         if c$ = "."
            sound [ 440 0.2 ]
            sleep 0.4
         elif c$ = "-"
            sound [ 440 0.6 ]
            sleep 0.8
         elif c$ = " "
            sleep 0.8
         .
      .
      print ""
   .
.
for ch$ in strchars txt$
   morse ch$
.
*
* Motzkin numbers
*
@ https://rosettacode.org/wiki/Motzkin_numbers@Task
*
fastfunc isprim num .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
m[] = [ 1 1 ]
print 1 ; print 1
len m[] 39
arrbase m[] 0
for n = 2 to 38
   m[n] = m[n - 1]
   for i = 0 to n - 2
      m[n] += m[i] * m[n - 2 - i]
   .
   if isprim m[n] = 1
      print m[n] & " is a prime"
   else
      print m[n]
   .
.
*
* Mouse position
*
@ https://rosettacode.org/wiki/Mouse_position@Task
*
on mouse_move
  clear
  text mouse_x & " " & mouse_y
.
*
* Multifactorial
*
@ https://rosettacode.org/wiki/Multifactorial@Task
*
func mfact n k .
   r = 1
   while n > 1
      r *= n
      n -= k
   .
   return r
.
for k = 1 to 5
   write "degree " & k & ":"
   for n = 1 to 10
      write " " & mfact n k
   .
   print ""
.
*
* Multiplication tables
*
@ https://rosettacode.org/wiki/Multiplication_tables@Task
*
n = 12
numfmt 0 4
write "     "
for i = 1 to n
   write i
.
print ""
write "     "
for i = 1 to n
   write "----"
.
print ""
for i = 1 to n
   write i
   write "|"
   for j = 1 to n
      if j < i
         write "    "
      else
         write i * j
      .
   .
   print ""
.
*
* Munching squares
*
@ https://rosettacode.org/wiki/Munching_squares@Task
*
sc = 100 / 64
for x range0 64
   for y range0 64
      h = bitand bitxor x y 63
      c = h / 63
      color3 c c c
      move x * sc y * sc
      rect sc + 0.1 sc + 0.1
   .
.
*
* Musical scale
*
@ https://rosettacode.org/wiki/Musical_scale@Task
*
n[] = [ 262 294 330 349 392 440 494 523 ]
for t in n[]
  sound [ t 0.5 ]
  sleep 0.6
.
*
* Möbius function
*
@ https://rosettacode.org/wiki/Möbius_function@Task
*
mu_max = 100000
sqroot = floor sqrt mu_max
# 
for i to mu_max
   mu[] &= 1
.
for i = 2 to sqroot
   if mu[i] = 1
      for j = i step i to mu_max
         mu[j] *= -i
      .
      for j = i * i step i * i to mu_max
         mu[j] = 0
      .
   .
.
for i = 2 to mu_max
   if mu[i] = i
      mu[i] = 1
   elif mu[i] = -i
      mu[i] = -1
   elif mu[i] < 0
      mu[i] = 1
   elif mu[i] > 0
      mu[i] = -1
   .
.
numfmt 0 3
for i = 1 to 100
   write mu[i]
   if i mod 10 = 0
      print ""
   .
.
*
* N'th
*
@ https://rosettacode.org/wiki/N'th@Task
*
func$ nth num .
   last2 = num mod 100
   last = num mod 10
   if last2 >= 11 and last2 <= 13
      return num & "th"
   elif last = 1
      return num & "st"
   elif last = 2
      return num & "nd"
   elif last = 3
      return num & "rd"
   else
      return num & "th"
   .
.
print "0 to 25:"
for i = 0 to 25
   write nth i & " "
.
print ""
print "250 to 265:"
for i = 250 to 265
   write nth i & " "
.
print ""
print "1000 to 1025:"
for i = 1000 to 1025
   write nth i & " "
.
*
* N-queens problem
*
@ https://rosettacode.org/wiki/N-queens_problem@Task
*
subr show_sol
   print "Solution " & n_sol
   print ""
   for i = 1 to n
      write "  "
      for j = 1 to n
         if j = x[i]
            write "Q "
         else
            write ". "
         .
      .
      print ""
   .
   print ""
.
subr test
   ok = 1
   for i = 1 to y - 1
      if x[y] = x[i] or abs (x[i] - x[y]) = abs (y - i)
         ok = 0
      .
   .
.
n = 8
len x[] n
y = 1
x[1] = 1
while y >= 1
   test
   if ok = 1 and y + 1 <= n
      y += 1
      x[y] = 1
   else
      if ok = 1
         n_sol += 1
         if n_sol <= 1
            show_sol
         .
      .
      while y >= 1 and x[y] = n
         y -= 1
      .
      if y >= 1
         x[y] += 1
      .
   .
.
print n_sol & " solutions"
*
* Narcissistic decimal number
*
@ https://rosettacode.org/wiki/Narcissistic_decimal_number@Task
*
while cnt < 25
   s$ = n
   ln = len s$
   s = 0
   for i to ln
      s += pow number substr s$ i 1 ln
   .
   if s = n
      print s
      cnt += 1
   .
   n += 1
.
*
* Nim game
*
@ https://rosettacode.org/wiki/Nim_game@Task
*
token = 12
while token > 0
   repeat
      print "There are " & token & " tokens remaining."
      write "How many would you like to take? (1,2 or 3) "
      h = number input
      print h
      until h >= 1 and h <= 3
   .
   sleep 1
   print "On my turn I will take " & 4 - h & " token(s)."
   print ""
   token -= 4
.
print "I got the last token. I win! Better luck next time."
*
* Nth root
*
@ https://rosettacode.org/wiki/Nth_root@Task
*
func power x n .
   r = 1
   for i = 1 to n
      r *= x
   .
   return r
.
func nth_root x n .
   r = 2
   repeat
      p = power r (n - 1)
      d = (x / p - r) / n
      r += d
      until abs d < 0.0001
   .
   return r
.
numfmt 4 0
x = power 3.1416 10
print nth_root x 10
*
* Numbers which are not the sum of distinct squares
*
@ https://rosettacode.org/wiki/Numbers_which_are_not_the_sum_of_distinct_squares@Task
*
maxNumber = 324
len isSum[] maxNumber
maxSquare = floor sqrt maxNumber
# 
proc flagSum currSum sqPos . .
   nextSum = currSum + sqPos * sqPos
   if nextSum <= maxNumber
      isSum[nextSum] = 1
      for i = sqPos + 1 to maxSquare
         flagSum nextSum i
      .
   .
.
for i = 1 to maxSquare
   flagSum 0 i
.
for i = 1 to maxNumber
   if isSum[i] = 0
      write i & " "
   .
.
*
* Numbers which are the cube roots of the product of their proper divisors
*
@ https://rosettacode.org/wiki/Numbers_which_are_the_cube_roots_of_the_product_of_their_proper_divisors@Task
*
func has8divs n .
   if n = 1
      return 1
   .
   cnt = 2
   sqr = sqrt n
   for d = 2 to sqr
      if n mod d = 0
         cnt += 1
         if d <> sqr
            cnt += 1
         .
         if cnt > 8
            return 0
         .
      .
   .
   if cnt = 8
      return 1
   .
   return 0
.
while count < 50
   x += 1
   if has8divs x = 1
      write x & " "
      count += 1
   .
.
while count < 50000
   x += 1
   if has8divs x = 1
      count += 1
      if count = 500 or count = 5000 or count = 50000
         print count & "th: " & x
      .
   .
.
*
* Numbers with equal rises and falls
*
@ https://rosettacode.org/wiki/Numbers_with_equal_rises_and_falls@Task
*
fastfunc risefall n .
   if n < 10
      return 1
   .
   prev = -1
   while n > 0
      d = n mod 10
      if prev >= 0
         if d < prev
            rises += 1
         elif d > prev
            falls += 1
         .
      .
      prev = d
      n = n div 10
   .
   if rises = falls
      return 1
   .
   return 0
.
numfmt 0 4
n = 1
repeat
   if risefall n = 1
      cnt += 1
      if cnt <= 200
         write n
         if cnt mod 20 = 0
            print ""
         .
      .
   .
   until cnt = 1e7
   n += 1
.
print ""
print n
*
* One-dimensional cellular automata
*
@ https://rosettacode.org/wiki/One-dimensional_cellular_automata@Task
*
map[] = [ 0 0 0 1 0 1 1 0 ]
cell[] = [ 0 1 1 1 0 1 1 0 1 0 1 0 1 0 1 0 0 1 0 0 ]
len celln[] len cell[]
proc evolve . .
   for i = 2 to len cell[] - 1
      ind = cell[i - 1] + 2 * cell[i] + 4 * cell[i + 1] + 1
      celln[i] = map[ind]
   .
   swap celln[] cell[]
.
proc show . .
   for v in cell[]
      if v = 1
         write "#"
      else
         write "."
      .
   .
   print ""
.
show
for i to 9
   evolve
   show
.
*
* Own digits power sum
*
@ https://rosettacode.org/wiki/Own_digits_power_sum@Task
*
fastfunc next curr n limit .
   repeat
      curr += 1
      if curr = limit
         return -1
      .
      sum = 0
      tmp = curr
      repeat
         dig = tmp mod 10
         tmp = tmp div 10
         h = n
         r = 1
         while h > 0
            r *= dig
            h -= 1
         .
         sum += r
         until tmp = 0
      .
      until sum = curr
   .
   return curr
.
for n = 3 to 8
   curr = pow 10 (n - 1)
   repeat
      curr = next curr n pow 10 n
      until curr = -1
      print curr
   .
.
*
* Palindrome detection
*
@ https://rosettacode.org/wiki/Palindrome_detection@Task
*
func$ reverse s$ .
   a$[] = strchars s$
   for i = 1 to len a$[] div 2
      swap a$[i] a$[len a$[] - i + 1]
   .
   return strjoin a$[]
.
func palin s$ .
   if s$ = reverse s$
      return 1
   .
   return 0
.
for s$ in [ "rotor" "rosetta" "step on no pets" "été" "🦊😀🦊" ]
   if palin s$ = 1
      print s$ & " is a palindrome"
   else
      print s$ & " is not a palindrome"
   .
.
*
* Pangram checker
*
@ https://rosettacode.org/wiki/Pangram_checker@Task
*
func pangr s$ .
   len d[] 26
   for c$ in strchars s$
      c = strcode c$
      if c >= 97 and c <= 122
         c -= 32
      .
      if c >= 65 and c <= 91
         d[c - 64] = 1
      .
   .
   for h in d[]
      s += h
   .
   return s
.
repeat
   s$ = input
   until s$ = ""
   print s$
   if pangr s$ = 26
      print "  --> pangram"
   .
   print ""
.
input_data
This is a test.
The quick brown fox jumps over the lazy dog.
The quick brown fox jumped over the lazy dog.
QwErTyUiOpAsDfGhJkLzXcVbNm
*
* Pentagram
*
@ https://rosettacode.org/wiki/Pentagram@Task
*
xp = 10
yp = 60
linewidth 2
move xp yp
while angle < 720
   x = xp + cos angle * 80
   y = yp + sin -angle * 80
   line x y
   f[] &= x
   f[] &= y
   xp = x
   yp = y
   angle += 144
.
color 900
polygon f[]
*
* Percolation/Mean run density
*
@ https://rosettacode.org/wiki/Percolation/Mean_run_density@Task
*
numfmt 3 6
for p in [ 0.1 0.3 0.5 0.7 0.9 ]
   theory = p * (1 - p)
   print "p:" & p & " theory:" & theory
   print "    n    sim"
   for n in [ 1e2 1e3 1e4 ]
      sum = 0
      for t to 100
         run = 0
         for j to n
            h = if randomf < p
            if h = 1 and run = 0
               sum += 1
            .
            run = h
         .
      .
      print n & "  " & sum / n / t
   .
   print ""
.
*
* Perfect numbers
*
@ https://rosettacode.org/wiki/Perfect_numbers@Task
*
func perf n .
   for i = 1 to n - 1
      if n mod i = 0
         sum += i
      .
   .
   return if sum = n
.
for i = 2 to 10000
   if perf i = 1
      print i
   .
.
*
* Perlin noise
*
@ https://rosettacode.org/wiki/Perlin_noise@Task
*
p[] = [ 151 160 137 91 90 15 131 13 201 95 96 53 194 233 7 225 140 36 103 30 69 142 8 99 37 240 21 10 23 190 6 148 247 120 234 75 0 26 197 62 94 252 219 203 117 35 11 32 57 177 33 88 237 149 56 87 174 20 125 136 171 168 68 175 74 165 71 134 139 48 27 166 77 146 158 231 83 111 229 122 60 211 133 230 220 105 92 41 55 46 245 40 244 102 143 54 65 25 63 161 1 216 80 73 209 76 132 187 208 89 18 169 200 196 135 130 116 188 159 86 164 100 109 198 173 186 3 64 52 217 226 250 124 123 5 202 38 147 118 126 255 82 85 212 207 206 59 227 47 16 58 17 182 189 28 42 223 183 170 213 119 248 152 2 44 154 163 70 221 153 101 155 167 43 172 9 129 22 39 253 19 98 108 110 79 113 224 232 178 185 112 104 218 246 97 228 251 34 242 193 238 210 144 12 191 179 162 241 81 51 145 235 249 14 239 107 49 192 214 31 181 199 106 157 184 84 204 176 115 121 50 45 127 4 150 254 138 236 205 93 222 114 67 29 24 72 243 141 128 195 78 66 215 61 156 180 ]
for i to 256
   p[] &= p[i]
. 
func fade t .
   return t * t * t * (t * (t * 6 - 15) + 10)
.
func lerp t a b .
   return a + t * (b - a)
.
func grad hash x y z .
   h = hash mod 16
   if h = 0 or h = 12
      return x + y
   elif h = 1 or h = 14
      return y - x
   elif h = 2
      return x - y
   elif h = 3
      return -x - y
   elif h = 4
      return x + z
   elif h = 5
      return z - x
   elif h = 6
      return x - z
   elif h = 7
      return -x - z
   elif h = 8
      return y + z
   elif h = 9 or h = 13
      return z - y
   elif h = 10
      return y - z
   .
   return -y - z
.
func noise x y z .
   a = floor x mod1 256
   b = floor y mod1 256
   c = floor z mod1 256
   xx = x mod 1
   yy = y mod 1
   zz = z mod 1
   u = fade xx
   v = fade yy
   w = fade zz
   a0 = p[a + 1] + b
   a1 = p[a0 + 1]
   a2 = p[a0 + 2] + c
   b0 = p[a + 2] + b
   b1 = p[b0 + 1] + c
   b2 = p[b0 + 2] + c
   k1 = grad p[a1 + 1] xx yy zz
   k2 = grad p[b1 + 1] (xx - 1) yy zz
   k3 = grad p[a2 + 1] xx (yy - 1) zz
   k4 = grad p[b2 + 1] (xx - 1) (yy - 1) zz
   k5 = grad p[a1 + 2] xx yy (zz - 1)
   k6 = grad p[b1 + 2] (xx - 1) yy (zz - 1)
   k7 = grad p[a2 + 2] xx (yy - 1) (zz - 1)
   k8 = grad p[b2 + 2] (xx - 1) (yy - 1) (zz - 1)
   return lerp w (lerp v (lerp u k1 k2) (lerp u k3 k4)) (lerp v (lerp u k5 k6) (lerp u k7 k8))
.
numfmt 6 0
print noise 3.14 42 7
*
* Permutations
*
@ https://rosettacode.org/wiki/Permutations@Task
*
proc permlist k . list[] .
   if k = len list[]
      print list[]
      return
   .
   for i = k to len list[]
      swap list[i] list[k]
      permlist k + 1 list[]
      swap list[k] list[i]
   .
.
l[] = [ 1 2 3 ]
permlist 1 l[]
*
* Permutations/Derangements
*
@ https://rosettacode.org/wiki/Permutations/Derangements@Task
*
global list[] rlist[][] .
proc permlist k . .
   if k >= len list[]
      for i to len list[]
         if i = list[i]
            return
         .
      .
      rlist[][] &= list[]
      return
   .
   for i = k to len list[]
      swap list[i] list[k]
      permlist k + 1
      swap list[k] list[i]
   .
.
# 
proc derang n . r[][] .
   rlist[][] = [ ]
   list[] = [ ]
   for i to n
      list[] &= i
   .
   permlist 1
   r[][] = rlist[][]
.
r[][] = [ ]
derang 4 r[][]
print r[][]
# 
func subfac n .
   if n < 2
      return 1 - n
   .
   return (subfac (n - 1) + subfac (n - 2)) * (n - 1)
.
# 
print "counted / calculated"
for n = 0 to 9
   derang n r[][]
   print n & ": " & len r[][] & " " & subfac n
.
*
* Pick random element
*
@ https://rosettacode.org/wiki/Pick_random_element@Task
*
ar$[] = [ "spring" "summer" "autumn" "winter" ]
print ar$[random len ar$[]]
*
* Plot coordinate pairs
*
@ https://rosettacode.org/wiki/Plot_coordinate_pairs@Task
*
x[] = [ 0 1 2 3 4 5 6 7 8 9 ]
y[] = [ 2.7 2.8 31.4 38.1 58.0 76.2 100.5 130.0 149.3 180.0 ]
# 
clear
linewidth 0.5
move 10 97
line 10 5
line 95 5
textsize 3
n = len x[]
m = 0
for i = 1 to n
   if y[i] > m
      m = y[i]
   .
.
linewidth 0.1
sty = m div 9
for i range0 10
   move 2 4 + i * 10
   text i * sty
   move 10 5 + i * 10
   line 95 5 + i * 10
.
stx = x[n] div 9
for i range0 10
   move i * 9 + 10 1
   text i * stx
   move i * 9 + 10 5
   line i * 9 + 10 97
.
color 900
linewidth 0.5
for i = 1 to n
   x = x[i] * 9 / stx + 10
   y = y[i] / sty * 10 + 5
   line x y
.
*
* Polynomial regression
*
@ https://rosettacode.org/wiki/Polynomial_regression@Task
*
func eval a b c x .
   return a + (b + c * x) * x
.
proc regression xa[] ya[] . .
   n = len xa[]
   for i = 1 to n
      xm = xm + xa[i]
      ym = ym + ya[i]
      x2m = x2m + xa[i] * xa[i]
      x3m = x3m + xa[i] * xa[i] * xa[i]
      x4m = x4m + xa[i] * xa[i] * xa[i] * xa[i]
      xym = xym + xa[i] * ya[i]
      x2ym = x2ym + xa[i] * xa[i] * ya[i]
   .
   xm = xm / n
   ym = ym / n
   x2m = x2m / n
   x3m = x3m / n
   x4m = x4m / n
   xym = xym / n
   x2ym = x2ym / n
   # 
   sxx = x2m - xm * xm
   sxy = xym - xm * ym
   sxx2 = x3m - xm * x2m
   sx2x2 = x4m - x2m * x2m
   sx2y = x2ym - x2m * ym
   # 
   b = (sxy * sx2x2 - sx2y * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
   c = (sx2y * sxx - sxy * sxx2) / (sxx * sx2x2 - sxx2 * sxx2)
   a = ym - b * xm - c * x2m
   print "y = " & a & " + " & b & "x + " & c & "x^2"
   numfmt 0 3
   for i = 1 to n
      print xa[i] & "  " & ya[i] & " " & eval a b c xa[i]
   .
.
xa[] = [ 0 1 2 3 4 5 6 7 8 9 10 ]
ya[] = [ 1 6 17 34 57 86 121 162 209 262 321 ]
regression xa[] ya[]
*
* Polyspiral
*
@ https://rosettacode.org/wiki/Polyspiral@Task
*
color 944
linewidth 0.3
on animate
   clear
   incr = (incr + 0.05) mod 360
   x1 = 50
   y1 = 50
   length = 1
   angle = incr
   move x1 y1
   for i = 1 to 150
      x2 = x1 + cos angle * length
      y2 = y1 + sin angle * length
      line x2 y2
      x1 = x2
      y1 = y2
      length += 1
      angle = (angle + incr) mod 360
   .
.
*
* Price fraction
*
@ https://rosettacode.org/wiki/Price_fraction@Task
*
n[] = [ 10 18 26 32 38 44 50 54 58 62 66 70 74 78 82 86 90 94 98 100 ]
func conv p .
   cat = (p - 1) div 5 + 1
   return n[cat]
.
for in = 5 step 5 to 100
   if in = 100
      in$ = "1.00"
   elif in < 10
      in$ = "0.0" & in
   else
      in$ = "0." & in
   .
   out = conv in
   if out = 100
      out$ = "1.00"
   else
      out$ = "0." & out
   .
   print in$ & " -> " & out$
.
*
* Primality by trial division
*
@ https://rosettacode.org/wiki/Primality_by_trial_division@Task
*
func isprim n .
   if n < 2
      return 0
   .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   sq = sqrt n
   while i <= sq
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
print isprim 1995937
*
* Prime decomposition
*
@ https://rosettacode.org/wiki/Prime_decomposition@Task
*
proc decompose num . primes[] .
   primes[] = [ ]
   t = 2
   while t * t <= num
      if num mod t = 0
         primes[] &= t
         num = num / t
      else
         t += 1
      .
   .
   primes[] &= num
.
decompose 9007199254740991 r[]
print r[]
*
* Primes: n*2^m+1
*
@ https://rosettacode.org/wiki/Primes:_n*2^m+1@Task
*
func isprim num .
   i = 2
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 1
   .
   return 1
.
for n = 1 to 45
   m = 0
   repeat
      p = n * (pow 2 m) + 1
      until isprim p = 1
      m += 1
   .
   print n & " " & m & " " & p
.
*
* Pseudo-random numbers/Middle-square method
*
@ https://rosettacode.org/wiki/Pseudo-random_numbers/Middle-square_method@Task
*
global seed .
seed = 675248
func rand .
   strSeed$ = seed
   s$ = seed * seed
   while not len s$ = len strSeed$ * 2
      s$ = "0" & s$
   .
   seed = number substr s$ (len strSeed$ / 2 + 1) len strSeed$
   randNum = seed
   return randNum
.
for i = 1 to 5
   print rand
.
*
* Pythagoras tree
*
@ https://rosettacode.org/wiki/Pythagoras_tree@Task
*
proc tree x1 y1 x2 y2 depth . .
   if depth < 8
      dx = x2 - x1
      dy = y1 - y2
      x3 = x2 + dy
      y3 = y2 + dx
      x4 = x1 + dy
      y4 = y1 + dx
      x5 = x4 + 0.5 * (dx + dy)
      y5 = y4 + 0.5 * (dx - dy)
      color3 0.3 0.2 + depth / 18 0.1
      polygon [ x1 y1 x2 y2 x3 y3 x4 y4 ]
      polygon [ x3 y3 x4 y4 x5 y5 ]
      tree x4 y4 x5 y5 depth + 1
      tree x5 y5 x3 y3 depth + 1
   .
.
tree 41 10 59 10 0
*
* Quickselect algorithm
*
@ https://rosettacode.org/wiki/Quickselect_algorithm@Task
*
proc qselect k . list[] res .
   # 
   subr partition
      mid = left
      for i = left + 1 to right
         if list[i] < list[left]
            mid += 1
            swap list[i] list[mid]
         .
      .
      swap list[left] list[mid]
   .
   left = 1
   right = len list[]
   while left < right
      partition
      if mid < k
         left = mid + 1
      elif mid > k
         right = mid - 1
      else
         left = right
      .
   .
   res = list[k]
.
d[] = [ 9 8 7 6 5 0 1 2 3 4 ]
for i = 1 to len d[]
   qselect i d[] r
   print r
.
*
* Quine
*
@ https://rosettacode.org/wiki/Quine@Task
*
S$ = "print strchar 83 & strchar 36 & strchar 32 & strchar 61 & strchar 32 & strchar 34 & S$ & strchar 34 & strchar 10 & S$"
print strchar 83 & strchar 36 & strchar 32 & strchar 61 & strchar 32 & strchar 34 & S$ & strchar 34 & strchar 10 & S$
*
* Random numbers
*
@ https://rosettacode.org/wiki/Random_numbers@Task
*
numfmt 5 0
e = 2.7182818284590452354
for i = 1 to 1000
   a[] &= 1 + 0.5 * sqrt (-2 * log10 randomf / log10 e) * cos (360 * randomf)
.
for v in a[]
   avg += v / len a[]
.
print "Average: " & avg
for v in a[]
   s += pow (v - avg) 2
.
s = sqrt (s / len a[])
print "Std deviation: " & s
*
* Rare numbers
*
@ https://rosettacode.org/wiki/Rare_numbers@Task
*
fastfunc next n .
   while 1 = 1
      n += 1
      h = n
      nrev = 0
      while h > 0
         nrev = nrev * 10 + h mod 10
         h = h div 10
      .
      if sqrt (n + nrev) mod 1 = 0
         if n - nrev >= 1 and sqrt (n - nrev) mod 1 = 0
            return n
         .
      .
   .
.
for cnt to 5
   n = next n
   print n
.
*
* Real constants and functions
*
@ https://rosettacode.org/wiki/Real_constants_and_functions@Task
*
# e is not available
# pi
print pi
# square root
print sqrt 2
# logarithm base 10
print log10 1000
# exponential is not available
# absolute value
print abs -20
# floor
print floor 1.5
# ceiling is not available
# power
print pow 2 10
*
* Recaman's sequence
*
@ https://rosettacode.org/wiki/Recaman's_sequence@Task
*
arrbase a[] 0
arrbase seen[] 0
len seen[] 100
# 
a[] &= 0
seen[0] = 1
i = 1
repeat
   h = a[i - 1] - i
   if h <= 0 or seen[h] = 1
      h = a[i - 1] + i
   .
   until seen[h] = 1
   seen[h] = 1
   a[] &= h
   if i = 14
      print a[]
   .
   i += 1
.
print h
*
* Remove duplicate elements
*
@ https://rosettacode.org/wiki/Remove_duplicate_elements@Task
*
a[] = [ 1 2 1 4 5 2 15 1 3 4 ]
for a in a[]
   found = 0
   for b in b[]
      if a = b
         found = 1
         break 1
      .
   .
   if found = 0
      b[] &= a
   .
.
print b[]
*
* Remove vowels from a string
*
@ https://rosettacode.org/wiki/Remove_vowels_from_a_string@Task
*
func$ rmv s$ .
   for c$ in strchars s$
      for v$ in strchars "AEIOUaeiou"
         if c$ = v$
            c$ = ""
         .
      .
      r$ &= c$
   .
   return r$
.
print rmv "The Quick Brown Fox Jumped Over the Lazy Dog's Back"
*
* Repeat a string
*
@ https://rosettacode.org/wiki/Repeat_a_string@Task
*
func$ rep s$ n .
   for i to n
      r$ &= s$
   .
   return r$
.
print rep "ha" 5
*
* Return multiple values
*
@ https://rosettacode.org/wiki/Return_multiple_values@Task
*
proc addSubtract a b . sum diff .
   sum = a + b
   diff = a - b
.
addSubtract 7 5 sum diff
print "Sum: " & sum
print "Difference: " & diff
*
* Reverse a string
*
@ https://rosettacode.org/wiki/Reverse_a_string@Task
*
func$ reverse s$ .
   a$[] = strchars s$
   for i = 1 to len a$[] div 2
      swap a$[i] a$[len a$[] - i + 1]
   .
   return strjoin a$[]
.
print reverse "hello"
*
* Roman numerals/Decode
*
@ https://rosettacode.org/wiki/Roman_numerals/Decode@Task
*
func rom2dec rom$ .
   symbols$[] = [ "M" "D" "C" "L" "X" "V" "I" ]
   values[] = [ 1000 500 100 50 10 5 1 ]
   val = 0
   for dig$ in strchars rom$
      for i = 1 to len symbols$[]
         if symbols$[i] = dig$
            v = values[i]
         .
      .
      val += v
      if oldv < v
         val -= 2 * oldv
      .
      oldv = v
   .
   return val
.
print rom2dec "MCMXC"
print rom2dec "MMVIII"
print rom2dec "MDCLXVI"
*
* Roman numerals/Encode
*
@ https://rosettacode.org/wiki/Roman_numerals/Encode@Task
*
func$ dec2rom dec .
   values[] = [ 1000 900 500 400 100 90 50 40 10 9 5 4 1 ]
   symbol$[] = [ "M" "CM" "D" "CD" "C" "XC" "L" "XL" "X" "IX" "V" "IV" "I" ]
   for i = 1 to len values[]
      while dec >= values[i]
         rom$ &= symbol$[i]
         dec -= values[i]
      .
   .
   return rom$
.
print dec2rom 1990
print dec2rom 2008
print dec2rom 1666
*
* Rot-13
*
@ https://rosettacode.org/wiki/Rot-13@Task
*
func$ rot13 str$ .
   for c$ in strchars str$
      code = strcode c$
      if code >= 65 and code <= 90
         encCode = code + 13
         if encCode > 90
            encCode = 64 + encCode - 90
         .
      elif code >= 97 and code <= 122
         encCode = code + 13
         if encCode > 122
            encCode = 96 + encCode - 122
         .
      else
         encCode = code
      .
      encStr$ &= strchar encCode
   .
   return encStr$
.
print rot13 "Rosetta Code"
*
* Run-length encoding
*
@ https://rosettacode.org/wiki/Run-length_encoding@Task
*
func$ rlenc in$ .
   for c$ in strchars in$
      if c$ = c0$
         cnt += 1
      else
         if cnt > 0
            out$ &= cnt & c0$ & " "
         .
         c0$ = c$
         cnt = 1
      .
   .
   out$ &= cnt & c0$
   return out$
.
func$ rldec in$ .
   for h$ in strsplit in$ " "
      c$ = substr h$ len h$ 1
      for i to number h$
         out$ &= c$
      .
   .
   return out$
.
s$ = input
print s$
s$ = rlenc s$
print s$
s$ = rldec s$
print s$
# 
input_data
WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
*
* Sattolo cycle
*
@ https://rosettacode.org/wiki/Sattolo_cycle@Task
*
proc sattolo_cycle . a[] .
   for i = len a[] downto 2
      r = random (i - 1)
      swap a[r] a[i]
   .
.
arr[] = [ 1 2 3 ]
sattolo_cycle arr[]
print arr[]
*
* Search a list
*
@ https://rosettacode.org/wiki/Search_a_list@Task
*
haystack$[] = [ "Zig" "Zag" "Wally" "Ronald" "Bush" "Krusty" "Charlie" "Bush" "Boz" "Zag" ]
# 
func getind needle$ .
   for i to len haystack$[]
      if haystack$[i] = needle$
         return i
      .
   .
   return 0
.
# arrays are 1 based
for n$ in [ "Bush" "Washington" ]
   h = getind n$
   if h = 0
      print n$ & " not found"
   else
      print n$ & " found at " & h
   .
.
*
* Self-describing numbers
*
@ https://rosettacode.org/wiki/Self-describing_numbers@Task
*
proc test d[] . .
   cnt[] = [ 0 0 0 0 0 0 0 0 0 0 ]
   for d in d[]
      cnt[d + 1] += 1
   .
   for i to len d[]
      if cnt[i] <> d[i]
         return
      .
   .
   # found
   for d in d[]
      write d
   .
   print ""
.
proc backtr ind max . d[] .
   if ind > len d[]
      test d[]
      return
   .
   for d = 0 to max
      if d < 10
         d[ind] = d
         backtr ind + 1 max - d d[]
      .
   .
.
for i = 1 to 10
   len d[] i
   backtr 1 len d[] d[]
.
*
* Semiprime
*
@ https://rosettacode.org/wiki/Semiprime@Task
*
func semiprime n .
   a = 2
   while c < 3 and n > 1
      if n mod a = 0
         n /= a
         c += 1
      else
         a += 1
      .
   .
   if c = 2
      return 1
   .
   return 0
.
for i = 1 to 100
   if semiprime i = 1
      write i & " "
   .
.
*
* Sequence of non-squares
*
@ https://rosettacode.org/wiki/Sequence_of_non-squares@Task
*
func nonSqu n .
   return n + floor (0.5 + sqrt n)
.
for i = 1 to 22
   print nonSqu i
.
for i = 1 to 1e6
   j = sqrt nonSqu i
   if j = floor j
      found = 1
   .
.
if found = 0
   print "No squares found"
.
*
* Sequence of primes by trial division
*
@ https://rosettacode.org/wiki/Sequence_of_primes_by_trial_division@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   while i <= sqrt n
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
proc primeSequ first last . sequ[] .
   for i = first to last
      if prime i = 1
         sequ[] &= i
      .
   .
.
primeSequ 2 100 seq[]
print seq[]
*
* Sequence: smallest number with exactly n divisors
*
@ https://rosettacode.org/wiki/Sequence:_smallest_number_with_exactly_n_divisors@Task
*
func cntdiv n .
   i = 1
   while i <= sqrt n
      if n mod i = 0
         cnt += 1
         if i <> sqrt n
            cnt += 1
         .
      .
      i += 1
   .
   return cnt
.
len seq[] 15
i = 1
while n < 15
   k = cntdiv i
   if k <= 15 and seq[k] = 0
      seq[k] = i
      n += 1
   .
   i += 1
.
for v in seq[]
   print v
.
*
* Set puzzle
*
@ https://rosettacode.org/wiki/Set_puzzle@Task
*
attr$[][] &= [ "one  " "two  " "three" ]
attr$[][] &= [ "solid  " "striped" "open   " ]
attr$[][] &= [ "red   " "green " "purple" ]
attr$[][] &= [ "diamond" "oval" "squiggle" ]
# 
subr init
   for card = 0 to 80
      pack[] &= card
   .
.
proc card2attr card . attr[] .
   attr[] = [ ]
   for i to 4
      attr[] &= card mod 3 + 1
      card = card div 3
   .
.
proc printcards cards[] . .
   for card in cards[]
      card2attr card attr[]
      for i to 4
         write attr$[i][attr[i]] & " "
      .
      print ""
   .
   print ""
.
proc getsets . cards[] set[] .
   set[] = [ ]
   for i to len cards[]
      card2attr cards[i] a[]
      for j = i + 1 to len cards[]
         card2attr cards[j] b[]
         for k = j + 1 to len cards[]
            card2attr cards[k] c[]
            ok = 1
            for at to 4
               s = a[at] + b[at] + c[at]
               if s <> 3 and s <> 6 and s <> 9
                  ok = 0
               .
            .
            if ok = 1
               set[] &= cards[i]
               set[] &= cards[j]
               set[] &= cards[k]
            .
         .
      .
   .
.
proc run ncards nsets . .
   # 
   repeat
      call init
      cards[] = [ ]
      for i to ncards
         ind = random len pack[]
         cards[] &= pack[ind]
         pack[ind] = pack[len pack[]]
         len pack[] -1
      .
      getsets cards[] set[]
      until len set[] = 3 * nsets
   .
   print "Cards:"
   printcards cards[]
   print "Sets:"
   for i = 1 step 3 to 3 * nsets - 2
      printcards [ set[i] set[i + 1] set[i + 2] ]
   .
.
run 9 4
print " --------------------------"
run 12 6
*
* Set, the card game
*
@ https://rosettacode.org/wiki/Set,_the_card_game@Task
*
attr$[][] &= [ "one  " "two  " "three" ]
attr$[][] &= [ "solid  " "striped" "open   " ]
attr$[][] &= [ "red   " "green " "purple" ]
attr$[][] &= [ "diamond " "oval    " "squiggle" ]
# 
for card = 0 to 80
   pack[] &= card
.
proc card2attr card . attr[] .
   attr[] = [ ]
   for i to 4
      attr[] &= card mod 3 + 1
      card = card div 3
   .
.
proc prcards cards[] . .
   for card in cards[]
      card2attr card attr[]
      for i to 4
         write attr$[i][attr[i]] & " "
      .
      print ""
   .
   print ""
.
ncards = random 5 + 7
print "Take " & ncards & " cards:"
for i to ncards
   ind = random len pack[]
   cards[] &= pack[ind]
   pack[ind] = pack[len pack[]]
   len pack[] -1
.
prcards cards[]
# 
for i to len cards[]
   card2attr cards[i] a[]
   for j = i + 1 to len cards[]
      card2attr cards[j] b[]
      for k = j + 1 to len cards[]
         card2attr cards[k] c[]
         ok = 1
         for at to 4
            s = a[at] + b[at] + c[at]
            if s <> 3 and s <> 6 and s <> 9
               # 1,1,1 2,2,2 3,3,3 1,2,3
               ok = 0
            .
         .
         if ok = 1
            print "Set:"
            prcards [ cards[i] cards[j] cards[k] ]
         .
      .
   .
.
*
* Seven-sided dice from five-sided dice
*
@ https://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice@Task
*
func dice5 .
   return random 5
.
func dice25 .
   return (dice5 - 1) * 5 + dice5
.
func dice7a .
   return dice25 mod1 7
.
func dice7b .
   repeat
      h = dice25
      until h <= 21
   .
   return h mod1 7
.
numfmt 3 0
n = 1000000
len dist[] 7
# 
proc checkdist . .
   for i to len dist[]
      h = dist[i] / n * 7
      if abs (h - 1) > 0.01
         bad = 1
      .
      dist[i] = 0
      print h
   .
   if bad = 1
      print "-> not uniform"
   else
      print "-> uniform"
   .
.
# 
for i to n
   dist[dice7a] += 1
.
checkdist
# 
print ""
for i to n
   dist[dice7b] += 1
.
checkdist
*
* Shoelace formula for polygonal area
*
@ https://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area@Task
*
proc shoelace . p[][] res .
   sum = 0
   for i = 1 to len p[][] - 1
      sum += p[i][1] * p[i + 1][2]
      sum -= p[i + 1][1] * p[i][2]
   .
   sum += p[i][1] * p[1][2]
   sum -= p[1][1] * p[i][2]
   res = abs sum / 2
.
data[][] = [ [ 3 4 ] [ 5 11 ] [ 12 8 ] [ 9 5 ] [ 5 6 ] ]
shoelace data[][] res
print res
*
* Short-circuit evaluation
*
@ https://rosettacode.org/wiki/Short-circuit_evaluation@Task
*
func a x .
   print "->a: " & x
   return x
.
func b x .
   print "->b: " & x
   return x
.
print "1 and 1"
if a 1 = 1 and b 1 = 1
   print "-> true"
.
print ""
print "1 or 1"
if a 1 = 1 or b 1 = 1
   print "-> true"
.
print ""
print "0 and 1"
if a 0 = 1 and b 1 = 1
   print "-> true"
.
print ""
print "0 or 1"
if a 0 = 1 or b 1 = 1
   print "-> true"
.
*
* Show ASCII table
*
@ https://rosettacode.org/wiki/Show_ASCII_table@Task
*
numfmt 0 3
for i range0 16
   for j = 32 + i step 16 to 127
      if j = 32
         x$ = "Spc"
      elif j = 127
         x$ = "Del"
      else
         x$ = strchar j & "  "
      .
      write j & ": " & x$
   .
   print ""
.
*
* Sierpinski arrowhead curve
*
@ https://rosettacode.org/wiki/Sierpinski_arrowhead_curve@Task
*
x = 5
y = 10
ang = 60
linewidth 0.5
# 
proc curv o l a . .
   if o = 0
      x += cos ang * l
      y += sin ang * l
      line x y
   else
      o -= 1
      l /= 2
      curv o l (-a)
      ang += a
      curv o l a
      ang += a
      curv o l (-a)
   .
.
move x y
curv 7 90 -60
*
* Sierpinski carpet
*
@ https://rosettacode.org/wiki/Sierpinski_carpet@Task
*
proc carp x y sz . .
   move x - sz / 2 y - sz / 2
   rect sz sz
   if sz > 0.5
      h = sz / 3
      carp x - sz y - sz h
      carp x - sz y h
      carp x - sz y + sz h
      carp x + sz y - sz h
      carp x + sz y h
      carp x + sz y + sz h
      carp x y - sz h
      carp x y + sz h
   .
.
background 000
clear
color 633
carp 50 50 100 / 3
*
* Sierpinski pentagon
*
@ https://rosettacode.org/wiki/Sierpinski_pentagon@Task
*
order = 5
# 
clear
linewidth 0.2
scale = 1 / (2 + cos 72 * 2)
# 
proc pentagon x y side depth . .
   if depth = 0
      move x y
      for angle = 0 step 72 to 288
         x += cos angle * side
         y += sin angle * side
         line x y
      .
   else
      side *= scale
      dist = side + side * cos 72 * 2
      for angle = 0 step 72 to 288
         x += cos angle * dist
         y += sin angle * dist
         pentagon x y side depth - 1
      .
   .
.
pentagon 25 15 50 order - 1
*
* Sierpinski triangle/Graphical
*
@ https://rosettacode.org/wiki/Sierpinski_triangle/Graphical@Task
*
proc triang lev x y size . .
   if lev = 0
      move x y
      circle 0.15
   else
      lev -= 1
      size /= 2
      triang lev x + size y size
      triang lev x + size / 2 y + size size
      triang lev x y size
   .
.
triang 8 5 5 90
*
* Sieve of Eratosthenes
*
@ https://rosettacode.org/wiki/Sieve_of_Eratosthenes@Task
*
len is_divisible[] 100
max = sqrt len is_divisible[]
for d = 2 to max
   if is_divisible[d] = 0
      for i = d * d step d to len is_divisible[]
         is_divisible[i] = 1
      .
   .
.
for i = 2 to len is_divisible[]
   if is_divisible[i] = 0
      print i
   .
.
*
* Simple turtle graphics
*
@ https://rosettacode.org/wiki/Simple_turtle_graphics@Task
*
subr home
   deg = 0
   x = 50
   y = 50
   down = 0
   move x y
.
home
# 
proc forward n . .
   x += cos deg * n
   y += sin deg * n
   if down = 1
      line x y
   else
      move x y
   .
   sleep 0.1
.
proc turn a . .
   deg -= a
.
# 
proc house . .
   turn 180
   forward 45
   turn 180
   down = 1
   # 
   forward 30
   turn 90
   forward 30
   turn 90
   forward 30
   turn 90
   forward 30
   # 
   turn 30
   forward 30
   turn 120
   forward 30
   home
.
house
# 
proc bar a[] . .
   turn 90
   forward 30
   turn -90
   down = 1
   for i to len a[]
      max = higher max a[i]
   .
   for i to len a[]
      h = a[i] / max * 50
      w = 45 / len a[]
      turn -90
      forward h
      turn 90
      forward w
      turn 90
      forward h
      turn -90
   .
   turn 180
   forward 45
   home
.
bar [ 50 33 200 130 50 ]
*
* Sisyphus sequence
*
@ https://rosettacode.org/wiki/Sisyphus_sequence@Task
*
func isprim num .
   if num mod 2 = 0 and num > 2
      return 0
   .
   i = 3
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
prim = 1
proc nextprim . .
   repeat
      prim += 1
      until isprim prim = 1
   .
.
numfmt 0 4
n = 1
write n
for i = 2 to 100
   if n mod 2 <> 0
      nextprim
      n += prim
   else
      n /= 2
   .
   write n
   if i mod 10 = 0
      print ""
   .
.
*
* Sleep
*
@ https://rosettacode.org/wiki/Sleep@Task
*
print "How many seconds should I sleep? "
sec = number input
print "Sleeping ..."
sleep sec
print "Awake!"
*
* Snake
*
@ https://rosettacode.org/wiki/Snake@Task
*
subr fruit
   rx = (random 20 - 1) * 5 + 2.5
   ry = (random 20 - 1) * 5 + 2.5
.
subr start
   fruit
   game = 1
   sx[] = [ 52.5 0 0 0 0 ]
   sy[] = [ 52.5 0 0 0 0 ]
   dir = random 4
   timer 0
.
background 242
move 30 70
clear
color 997
text "SNAKE"
textsize 5
move 6 40
text "Keys or mouse for controlling"
move 6 30
text "Space or click to to start"
# 
on key
   if game = 0 and keybkey = " "
      start
      return
   .
   if dir mod 2 = 1
      if keybkey = "ArrowRight"
         dir = 2
      elif keybkey = "ArrowLeft"
         dir = 4
      .
   else
      if keybkey = "ArrowUp"
         dir = 1
      elif keybkey = "ArrowDown"
         dir = 3
      .
   .
.
on mouse_down
   if game = 0
      start
      return
   .
   if dir mod 2 = 1
      if mouse_x < sx
         dir = 4
      else
         dir = 2
      .
   else
      if mouse_y < sy
         dir = 3
      else
         dir = 1
      .
   .
.
on timer
   clear
   color 997
   move 2 95
   text "Score: " & 10 * len sx[] - 50
   color 966
   move rx ry
   circle 1.5
   # 
   sx = sx[1] ; sy = sy[1]
   if dir = 1
      sy += 5
   elif dir = 2
      sx += 5
   elif dir = 3
      sy -= 5
   elif dir = 4
      sx -= 5
   .
   if sx < 0 or sx > 100 or sy < 0 or sy > 100
      game = 0
   .
   color 494
   for i = len sx[] downto 2
      if sx = sx[i] and sy = sy[i]
         game = 0
      .
      sx[i] = sx[i - 1]
      sy[i] = sy[i - 1]
      if sx[i] > 0
         move sx[i] sy[i]
         circle 2.5
      .
   .
   move sx sy
   circle 2.5
   color 000
   if dir = 2 or dir = 4
      move sx sy + 1
      circle 0.5
      move sx sy - 1
      circle 0.5
   else
      move sx + 1 sy
      circle 0.5
      move sx - 1 sy
      circle 0.5
   .
   if sx = rx and sy = ry
      len sx[] len sx[] + 3
      len sy[] len sy[] + 3
      fruit
   .
   sx[1] = sx ; sy[1] = sy
   if game = 1
      timer 0.15
   else
      color 997
      move 10 10
      text "Space or click new game"
   .
.
*
* Solve triangle solitare puzzle
*
@ https://rosettacode.org/wiki/Solve_triangle_solitare_puzzle@Task
*
brd$[] = strchars "
┏━━━━━━━━━┓
┃    ·    ┃
┃   ● ●   ┃
┃  ● ● ●  ┃
┃ ● ● ● ● ┃
┃● ● ● ● ●┃
┗━━━━━━━━━┛"
proc solve . solution$ .
   solution$ = ""
   for pos = 1 to len brd$[]
      if brd$[pos] = "●"
         npegs += 1
         for dir in [ -13 -11 2 13 11 -2 ]
            if brd$[pos + dir] = "●" and brd$[pos + 2 * dir] = "·"
               brd$[pos] = "·"
               brd$[pos + dir] = "·"
               brd$[pos + 2 * dir] = "●"
               solve solution$
               brd$[pos] = "●"
               brd$[pos + dir] = "●"
               brd$[pos + 2 * dir] = "·"
               if solution$ <> ""
                  solution$ = strjoin brd$[] & solution$
                  return
               .
            .
         .
      .
   .
   if npegs = 1
      solution$ = strjoin brd$[]
   .
.
solve solution$
print solution$
*
* Sort three variables
*
@ https://rosettacode.org/wiki/Sort_three_variables@Task
*
proc sort3 . a b c .
   if a > c
      swap a c
   .
   if b > c
      swap b c
   .
   if a > b
      swap a b
   .
.
x = 77444
y = -12
z = 0
sort3 x y z
print x & " " & y & " " & z
# 
proc sort3str . a$ b$ c$ .
   if strcmp a$ c$ > 0
      swap a$ c$
   .
   if strcmp b$ c$ > 0
      swap b$ c$
   .
   if strcmp a$ b$ > 0
      swap a$ b$
   .
.
x$ = "lions, tigers, and"
y$ = "bears, oh my!"
z$ = "(from the \"Wizard of OZ\")"
sort3str x$ y$ z$
print x$
print y$
print z$
*
* Sorting algorithms/Bubble sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort@Task
*
proc bubbleSort . a[] .
   repeat
      changed = 0
      for i = 1 to len a[] - 1
         if a[i] > a[i + 1]
            swap a[i] a[i + 1]
            changed = 1
         .
      .
      until changed = 0
   .
.
array[] = [ 5 1 19 25 12 1 14 7 ]
bubbleSort array[]
print array[]
*
* Sorting algorithms/Counting sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Counting_sort@Task
*
proc countsort min max . d[] .
   len count[] max - min + 1
   for n in d[]
      count[n - min + 1] += 1
   .
   z = 1
   for i = min to max
      while count[i - min + 1] > 0
         d[z] = i
         z += 1
         count[i - min + 1] -= 1
      .
   .
.
for i = 1 to 100
   d[] &= random 1000
.
countsort 1 1000 d[]
print d[]
*
* Sorting algorithms/Gnome sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort@Task
*
proc sort . d[] .
   i = 2
   j = 3
   while i <= len d[]
      if d[i - 1] <= d[i]
         i = j
         j += 1
      else
         swap d[i - 1] d[i]
         i -= 1
         if i = 1
            i = j
            j += 1
         .
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Heapsort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Heapsort@Task
*
proc sort . d[] .
   n = len d[]
   # make heap
   for i = 2 to n
      if d[i] > d[(i + 1) div 2]
         j = i
         repeat
            h = (j + 1) div 2
            until d[j] <= d[h]
            swap d[j] d[h]
            j = h
         .
      .
   .
   for i = n downto 2
      swap d[1] d[i]
      j = 1
      ind = 2
      while ind < i
         if ind + 1 < i and d[ind + 1] > d[ind]
            ind += 1
         .
         if d[j] < d[ind]
            swap d[j] d[ind]
         .
         j = ind
         ind = 2 * j
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Insertion sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort@Task
*
proc sort . d[] .
   for i = 2 to len d[]
      h = d[i]
      j = i - 1
      while j >= 1 and h < d[j]
         d[j + 1] = d[j]
         j -= 1
      .
      d[j + 1] = h
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Merge sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Merge_sort@Task
*
proc sort . d[] .
   len tmp[] len d[]
   sz = 1
   while sz < len d[]
      swap tmp[] d[]
      left = 1
      while left < len d[]
         # merge
         mid = left + sz - 1
         if mid > len d[]
            mid = len d[]
         .
         right = mid + sz
         if right > len d[]
            right = len d[]
         .
         l = left
         r = mid + 1
         for i = left to right
            if r > right or l <= mid and tmp[l] < tmp[r]
               d[i] = tmp[l]
               l += 1
            else
               d[i] = tmp[r]
               r += 1
            .
         .
         left += 2 * sz
      .
      sz *= 2
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Quicksort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Quicksort@Task
*
proc qsort left right . d[] .
   while left < right
      # partition 
      piv = d[left]
      mid = left
      for i = left + 1 to right
         if d[i] < piv
            mid += 1
            swap d[i] d[mid]
         .
      .
      swap d[left] d[mid]
      # 
      if mid < (right + left) / 2
         qsort left mid - 1 d[]
         left = mid + 1
      else
         qsort mid + 1 right d[]
         right = mid - 1
      .
   .
.
proc sort . d[] .
   qsort 1 len d[] d[]
.
d[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort d[]
print d[]
*
* Sorting algorithms/Radix sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Radix_sort@Task
*
proc sort . d[] .
   # radix = 10
   radix = 256
   max = 0
   for di = 1 to len d[]
      if d[di] > max
         max = d[di]
      .
   .
   len buck[][] radix
   pos = 1
   while pos <= max
      for i = 1 to radix
         len buck[i][] 0
      .
      for di = 1 to len d[]
         h = d[di] div pos mod radix + 1
         buck[h][] &= d[di]
      .
      di = 1
      for i = 1 to radix
         for j = 1 to len buck[i][]
            d[di] = buck[i][j]
            di += 1
         .
      .
      pos *= radix
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Selection sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Selection_sort@Task
*
proc sort . d[] .
   for i = 1 to len d[] - 1
      for j = i + 1 to len d[]
         if d[j] < d[i]
            swap d[j] d[i]
         .
      .
   .
.
data[] = [ 29 4 72 44 55 26 27 77 92 5 ]
sort data[]
print data[]
*
* Sorting algorithms/Stooge sort
*
@ https://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort@Task
*
proc stsort left right . d[] .
   if d[left] > d[right]
      swap d[left] d[right]
   .
   if right - left + 1 > 2
      t = (right - left + 1) div 3
      stsort left right - t d[]
      stsort left + t right d[]
      stsort left right - t d[]
   .
.
for i = 1 to 100
   d[] &= random 1000
.
stsort 1 len d[] d[]
print d[]
*
* Split a character string based on change of character
*
@ https://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character@Task
*
a$ = "gHHH5YY++///\\"
a$[] = strchars a$
cp$ = a$[1]
for c$ in a$[]
   if c$ <> cp$
      s$ &= ", "
      cp$ = c$
   .
   s$ &= c$
.
print s$
*
* Square form factorization
*
@ https://rosettacode.org/wiki/Square_form_factorization@Task
*
multiplier[] = [ 1 3 5 7 11 3 * 5 3 * 7 3 * 11 5 * 7 5 * 11 7 * 11 3 * 5 * 7 3 * 5 * 11 3 * 7 * 11 5 * 7 * 11 3 * 5 * 7 * 11 ]
func gcd a b .
   while b <> 0
      a = a mod b
      swap a b
   .
   return a
.
func squfof N .
   s = floor (sqrt N + 0.5)
   if s * s = N
      return s
   .
   for multiplier in multiplier[]
      if N > 9007199254740992 / multiplier
         print "Number " & N & " is too big"
         break 1
      .
      D = multiplier * N
      P = floor sqrt D
      Po = P
      Pprev = P
      Qprev = 1
      Q = D - Po * Po
      L = 2 * floor sqrt (2 * s)
      B = 3 * L
      for i = 2 to B - 1
         b = (Po + P) div Q
         P = b * Q - P
         q = Q
         Q = Qprev + b * (Pprev - P)
         r = floor (sqrt Q + 0.5)
         if i mod 2 = 0 and r * r = Q
            break 1
         .
         Qprev = q
         Pprev = P
      .
      if i < B
         b = (Po - P) div r
         P = b * r + P
         Pprev = P
         Qprev = r
         Q = (D - Pprev * Pprev) / Qprev
         i = 0
         repeat
            b = (Po + P) div Q
            Pprev = P
            P = b * Q - P
            q = Q
            Q = Qprev + b * (Pprev - P)
            Qprev = q
            i += 1
            until P = Pprev
         .
         r = gcd N Qprev
         if r <> 1 and r <> N
            return r
         .
      .
   .
   return 0
.
data[] = [ 2501 12851 13289 75301 120787 967009 997417 7091569 13290059 42854447 223553581 2027651281 11111111111 100895598169 1002742628021 60012462237239 287129523414791 9007199254740931 ]
for example in data[]
   factor = squfof example
   if factor = 0
      print example & " was not factored."
   else
      quotient = example / factor
      print example & " has factors " & factor & " " & quotient
   .
.
*
* Statistics/Basic
*
@ https://rosettacode.org/wiki/Statistics/Basic@Task
*
global list[] .
proc mklist n . .
   list[] = [ ]
   for i = 1 to n
      list[] &= randomf
   .
.
func mean .
   for v in list[]
      sum += v
   .
   return sum / len list[]
.
func stddev .
   avg = mean
   for v in list[]
      squares += (avg - v) * (avg - v)
   .
   return sqrt (squares / len list[])
.
proc histo . .
   len hist[] 10
   for v in list[]
      ind = floor (v * 10) + 1
      hist[ind] += 1
   .
   for v in hist[]
      h = floor (v / len list[] * 200 + 0.5)
      s$ = substr "========================================" 1 h
      print v & " " & s$
   .
.
numfmt 4 5
proc stats size . .
   mklist size
   print "Size:   " & size
   print "Mean:   " & mean
   print "Stddev: " & stddev
   histo
   print ""
.
stats 100
stats 1000
stats 10000
stats 100000
*
* Steffensen's method
*
@ https://rosettacode.org/wiki/Steffensen's_method@Task
*
func deCasteljau c0 c1 c2 t .
   s = 1 - t
   c01 = s * c0 + t * c1
   c12 = s * c1 + t * c2
   return s * c01 + t * c12
.
func xConvexLeftPar t .
   return deCasteljau 2 (-8) 2 t
.
func yConvexRightPar t .
   return deCasteljau 1 2 3 t
.
func implicitEq x y .
   return 5 * x * x + y - 5
.
func f t r .
   x = xConvexLeftPar t
   y = yConvexRightPar t
   r = implicitEq x y
   return r + t
.
func aitken p0 .
   p1 = f p0 p1
   p2 = f p1 p2
   p1m0 = p1 - p0
   return p0 - p1m0 * p1m0 / (p2 - 2 * p1 + p0)
.
func steffAitken p0 tol maxiter .
   for i to maxiter
      p = aitken p0
      if abs (p - p0) < tol
         return p
      .
      p0 = p
   .
   return number "nan"
.
for i to 11
   numfmt 1 0
   write "t0 = " & t0 & " : "
   t = steffAitken t0 0.00000001 1000
   numfmt 3 0
   if t <> t
      # nan
      print "no answer"
   else
      x = xConvexLeftPar t
      y = yConvexRightPar t
      r = implicitEq x y
      if abs r <= 0.000001
         print "intersection at (" & x & " " & y & ")"
      else
         print "spurious solution"
      .
   .
   t0 += 0.1
.
*
* Stirling numbers of the first kind
*
@ https://rosettacode.org/wiki/Stirling_numbers_of_the_first_kind@Task
*
print "Unsigned Stirling numbers of the first kind:"
len a[] 13 ; arrbase a[] 0
len b[] 13 ; arrbase b[] 0
a[0] = 1
print 1
for n = 1 to 12
   b[0] = 0
   write 0 & " "
   for k = 1 to n
      b[k] = a[k - 1] + (n - 1) * a[k]
      write b[k] & " "
   .
   print ""
   swap a[] b[]
.
*
* Stirling numbers of the second kind
*
@ https://rosettacode.org/wiki/Stirling_numbers_of_the_second_kind@Task
*
print "Unsigned Stirling numbers of the second kind:"
len a[] 13 ; arrbase a[] 0
len b[] 13 ; arrbase b[] 0
a[0] = 1
print 1
for n = 1 to 12
   b[0] = 0
   write 0 & " "
   for k = 1 to n - 1
      b[k] = k * a[k] + a[k - 1]
      write b[k] & " "
   .
   b[n] = 1
   write 1 & " "
   print ""
   swap a[] b[]
.
*
* String append
*
@ https://rosettacode.org/wiki/String_append@Task
*
a$ = "hello"
a$ &= " world"
print a$
*
* String case
*
@ https://rosettacode.org/wiki/String_case@Task
*
func$ toUpper s$ .
   for c$ in strchars s$
      code = strcode c$
      if code >= 97 and code <= 122
         code -= 32
      .
      res$ &= strchar code
   .
   return res$
.
func$ toLower s$ .
   for c$ in strchars s$
      code = strcode c$
      if code >= 65 and code <= 90
         code += 32
      .
      res$ &= strchar code
   .
   return res$
.
string$ = "alphaBETA"
print string$
print toUpper string$
print toLower string$
*
* String comparison
*
@ https://rosettacode.org/wiki/String_comparison@Task
*
a$ = "hello"
if a$ = "hello"
   print "equal"
.
if a$ <> "hello2"
   print "not equal"
.
if strcmp a$ "hello" = 0
   print "equal"
.
if strcmp a$ "world" < 0
   print "lexically before"
.
if number "10" > number "2"
   print "numerically after"
.
*
* String concatenation
*
@ https://rosettacode.org/wiki/String_concatenation@Task
*
a$ = "hello"
b$ = a$ & " world"
print b$
*
* String length
*
@ https://rosettacode.org/wiki/String_length@Task
*
# 5
print len "møøse"
# 7
print len "𝔘𝔫𝔦𝔠𝔬𝔡𝔢"
# 8
print len "J̲o̲s̲é̲"
# 1
print len "😀"
*
* String matching
*
@ https://rosettacode.org/wiki/String_matching@Task
*
func starts s$ t$ .
   if substr s$ 1 len t$ = t$
      return 1
   .
   return 0
.
func ends s$ t$ .
   if substr s$ (len s$ - len t$ + 1) len t$ = t$
      return 1
   .
   return 0
.
func contains s$ t$ .
   for i to len s$ - len t$ + 1
      if substr s$ i len t$ = t$
         return 1
      .
   .
   return 0
.
print starts "hello world" "he"
print ends "hello world" "rld"
print contains "hello world" "wo"
*
* String prepend
*
@ https://rosettacode.org/wiki/String_prepend@Task
*
string$ = "Lang"
string$ = "Easy" & string$
print string$
*
* Strip a set of characters from a string
*
@ https://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string@Task
*
func$ strip s$ del$ .
   del$[] = strchars del$
   i = 1
   repeat
      c$ = substr s$ i 1
      until c$ = ""
      for d$ in del$[]
         if c$ = d$
            c$ = ""
         .
      .
      r$ &= c$
      i += 1
   .
   return r$
.
print strip "She was a soul stripper. She took my heart!" "aei"
*
* Strip block comments
*
@ https://rosettacode.org/wiki/Strip_block_comments@Task
*
subr process
   i = 1
   while i <= len s$
      if inc = 0 and substr s$ i 2 = "/*"
         inc = 1
         i += 1
      elif inc = 1 and substr s$ i 2 = "*/"
         inc = 0
         i += 1
      elif inc = 0
         write substr s$ i 1
      .
      i += 1
   .
   if inc = 0
      print ""
   .
.
repeat
   s$ = input
   until error = 1
   process
.
input_data
/**
 * Some comments
 * longer comments here that we can parse.
 *
 * Rahoo 
 */
 function subroutine() {
  a = /* inline comment */ b + c ;
 }
 /*/ <-- tricky comments */

 /**
  * Another comment.
  */
  function something() {
  }
*
* Strip comments from a string
*
@ https://rosettacode.org/wiki/Strip_comments_from_a_string@Task
*
func$ strip s$ .
   i = 1
   repeat
      c$ = substr s$ i 1
      until c$ = "#" or c$ = ";" or c$ = ""
      if c$ = " " and sp = 0
         sp = i
      elif c$ <> " "
         sp = 0
      .
      i += 1
   .
   if sp = 0
      sp = i
   .
   return substr s$ 1 (sp - 1)
.
print strip "Regular string" & "."
print strip "With a hash# a comment" & "."
print strip "With a hash    # a comment" & "."
print strip "With a semicolon   ;  a comment" & "."
print strip "No comment   " & "."
*
* Strip control codes and extended characters from a string
*
@ https://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string@Task
*
func$ strip s$ .
   for c$ in strchars s$
      if strcode c$ >= 32 and strcode c$ <= 126
         r$ &= c$
      .
   .
   return r$
.
print strip "\tHellö world"
*
* Strip whitespace from a string/Top and tail
*
@ https://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail@Task
*
func iswhite c$ .
   if c$ = " " or c$ = "\t" or c$ = "\n"
      return 1
   .
.
func$ strip s$ top tail .
   a = 1
   if top = 1
      repeat
         c$ = substr s$ a 1
         until iswhite c$ = 0
         a += 1
      .
   .
   b = len s$
   if tail = 1
      repeat
         c$ = substr s$ b 1
         until iswhite c$ = 0
         b -= 1
      .
   .
   return substr s$ a (b - a + 1)
.
print strip "    Hello world   " 1 1 & "."
print strip "    Hello world   " 0 1 & "."
print strip "    Hello world   " 1 1 & "."
*
* Sub-unit squares
*
@ https://rosettacode.org/wiki/Sub-unit_squares@Task
*
func has9 v .
   while v > 0
      if v mod 10 = 9
         return 1
      .
      v = v div 10
   .
   return 0
.
ones = 1
pow10 = 10
while count < 5
   while n * n > pow10
      pow10 *= 10
      ones = ones * 10 + 1
   .
   if has9 (n * n) = 0
      sq = n * n + ones
      if sqrt sq mod 1 = 0
         write " " & sq
         count += 1
      .
   .
   n += 1
.
*
* Substring
*
@ https://rosettacode.org/wiki/Substring@Task
*
a$ = "2019-05-22 22:54:22"
print substr a$ 12 5
print substr a$ 12 -1
*
* Substring/Top and tail
*
@ https://rosettacode.org/wiki/Substring/Top_and_tail@Task
*
string$ = "EasyLang"
print substr string$ 1 len string$ - 1 # Without the last character
print substr string$ 2 len string$ - 1 # Without the first character
print substr string$ 2 len string$ - 2 # Without the first and last characters
*
* Sudoku
*
@ https://rosettacode.org/wiki/Sudoku@Task
*
len row[] 90
len col[] 90
len box[] 90
len grid[] 82
# 
proc init . .
   for pos = 1 to 81
      if pos mod 9 = 1
         s$ = input
         if s$ = ""
            s$ = input
         .
         len inp[] 0
         for i = 1 to len s$
            if substr s$ i 1 <> " "
               inp[] &= number substr s$ i 1
            .
         .
      .
      dig = number inp[(pos - 1) mod 9 + 1]
      if dig > 0
         grid[pos] = dig
         r = (pos - 1) div 9
         c = (pos - 1) mod 9
         b = r div 3 * 3 + c div 3
         row[r * 10 + dig] = 1
         col[c * 10 + dig] = 1
         box[b * 10 + dig] = 1
      .
   .
.
init
# 
proc display . .
   for i = 1 to 81
      write grid[i] & " "
      if i mod 3 = 0
         write " "
      .
      if i mod 9 = 0
         print ""
      .
      if i mod 27 = 0
         print ""
      .
   .
.
# 
proc solve pos . .
   while grid[pos] <> 0
      pos += 1
   .
   if pos > 81
      # solved
      display
      return
   .
   r = (pos - 1) div 9
   c = (pos - 1) mod 9
   b = r div 3 * 3 + c div 3
   r *= 10
   c *= 10
   b *= 10
   for d = 1 to 9
      if row[r + d] = 0 and col[c + d] = 0 and box[b + d] = 0
         grid[pos] = d
         row[r + d] = 1
         col[c + d] = 1
         box[b + d] = 1
         solve pos + 1
         row[r + d] = 0
         col[c + d] = 0
         box[b + d] = 0
      .
   .
   grid[pos] = 0
.
solve 1
# 
input_data
5 3 0  0 2 4  7 0 0
0 0 2  0 0 0  8 0 0
1 0 0  7 0 3  9 0 2

0 0 8  0 7 2  0 4 9
0 2 0  9 8 0  0 7 0
7 9 0  0 0 0  0 8 0

0 0 0  0 3 0  5 0 6
9 6 0  0 1 0  3 0 0
0 5 0  6 9 0  0 1 0
*
* Sum and product of an array
*
@ https://rosettacode.org/wiki/Sum_and_product_of_an_array@Task
*
array[] = [ 5 1 19 25 12 1 14 7 ]
product = 1
for item in array[]
   sum += item
   product *= item
.
print "Sum: " & sum
print "Product: " & product
*
* Sum digits of an integer
*
@ https://rosettacode.org/wiki/Sum_digits_of_an_integer@Task
*
func sumdig s$ .
   for c$ in strchars s$
      h = strcode c$ - 48
      if h >= 10
         h -= 39
      .
      r += h
   .
   return r
.
print sumdig "1"
print sumdig "1234"
print sumdig "fe"
print sumdig "f0e"
*
* Sum of a series
*
@ https://rosettacode.org/wiki/Sum_of_a_series@Task
*
numfmt 8 0
for i = 1 to 1000
   s += 1 / (i * i)
.
print s
*
* Sum of squares
*
@ https://rosettacode.org/wiki/Sum_of_squares@Task
*
nums[] = [ 1 2 3 4 5 ]
for v in nums[]
   sum += v * v
.
print sum
*
* Summarize primes
*
@ https://rosettacode.org/wiki/Summarize_primes@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   while i <= sqrt n
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
for i = 2 to 999
   if prime i = 1
      ind += 1
      sum += i
      if prime sum = 1
         print ind & ": " & sum
      .
   .
.
*
* Sylvester's sequence
*
@ https://rosettacode.org/wiki/Sylvester's_sequence@Task
*
numfmt 8 0
for i = 1 to 10
   if i = 1
      sylv = 2
   else
      sylv = sylv * sylv - sylv + 1
   .
   print sylv
   sum += 1 / sylv
.
print ""
print sum
*
* Symmetric difference
*
@ https://rosettacode.org/wiki/Symmetric_difference@Task
*
a$[] = [ "John" "Bob" "Mary" "Serena" ]
b$[] = [ "Jim" "Mary" "John" "Bob" ]
for i to 2
   for a$ in a$[]
      for b$ in b$[]
         if a$ = b$
            break 1
         .
      .
      if a$ <> b$
         for c$ in c$[]
            if c$ = a$
               break 1
            .
         .
         if c$ <> a$
            c$[] &= a$
         .
      .
   .
   swap a$[] b$[]
.
print c$[]
*
* System time
*
@ https://rosettacode.org/wiki/System_time@Task
*
print timestr systime
*
* Temperature conversion
*
@ https://rosettacode.org/wiki/Temperature_conversion@Task
*
k = number input
print k & " °K"
print k - 273.15 & " °C"
print k * 1.8 - 459.67 & " °F"
print k * 1.8 & " °R"
*
* The Name Game
*
@ https://rosettacode.org/wiki/The_Name_Game@Task
*
proc toLowercase string$ . result$ .
   for i = 1 to len string$
      code = strcode substr string$ i 1
      if code >= 65 and code <= 90
         code += 32
      .
      result$ &= strchar code
   .
.
proc findInStrArray array$[] item$ . index .
   for i = 1 to len array$[]
      if array$[i] = item$
         index = i
         return
      .
   .
   index = 0
.
# This version actually handles consonant clusters
name$ = input
toLowercase name$ lowerName$
vowels$[] = [ "a" "e" "i" "o" "u" ]
for i = 1 to len lowerName$
   letter$ = substr lowerName$ i 1
   findInStrArray vowels$[] letter$ index
   if index <> 0
      truncName1$ = substr lowerName$ i len lowerName$
      break 1
   .
   truncName1$ = ""
.
firstLetter$ = substr lowerName$ 1 1
if firstLetter$ <> "b"
   b$ = "b"
.
if firstLetter$ <> "f"
   f$ = "f"
.
if firstLetter$ <> "m"
   m$ = "m"
.
if b$ = "" or f$ = "" or m$ = ""
   truncName2$ = substr lowerName$ 2 len lowerName$
.
# Determine the appropriate name for each line
if b$ = ""
   bName$ = truncName2$
else
   bName$ = truncName1$
.
if f$ = ""
   fName$ = truncName2$
else
   fName$ = truncName1$
.
if m$ = ""
   mName$ = truncName2$
else
   mName$ = truncName1$
.
# Print the song
print name$ & ", " & name$ & ", " & "bo-" & b$ & bName$
print "Banana-fana fo-" & f$ & fName$
print "Fee-fi-mo-" & m$ & mName$
print name$ & "!"
*
* The Twelve Days of Christmas
*
@ https://rosettacode.org/wiki/The_Twelve_Days_of_Christmas@Task
*
days$[] = [ "first" "second" "third" "forth" "fifth" "sixth" "seventh" "eighth" "ninth" "tenth" "eleventh" "twelfth" ]
gifts$[] &= "Twelve drummers drumming"
gifts$[] &= "Eleven pipers piping"
gifts$[] &= "Ten lords a-leaping"
gifts$[] &= "Nine ladies dancing"
gifts$[] &= "Eight maids a-milking"
gifts$[] &= "Seven swans a-swimming"
gifts$[] &= "Six geese a-laying"
gifts$[] &= "Five golden rings"
gifts$[] &= "Four calling birds"
gifts$[] &= "Three french hens"
gifts$[] &= "Two turtle doves and"
gifts$[] &= "A partridge in a pear tree."
for i = 1 to 12
   print "On the " & days$[i] & " day of Christmas,"
   print "My true love gave to me:"
   for j = 13 - i to 12
      print gifts$[j]
   .
   print ""
.
*
* Tic-tac-toe
*
@ https://rosettacode.org/wiki/Tic-tac-toe@Task
*
len f[] 9
state = 0
textsize 14
# 
proc init . .
   linewidth 2
   clear
   color 666
   move 34 96
   line 34 20
   move 62 96
   line 62 20
   move 10 72
   line 86 72
   move 10 44
   line 86 44
   linewidth 2.5
   for i = 1 to 9
      f[i] = 0
   .
   if state = 1
      timer 0.2
   .
.
proc draw ind . .
   c = (ind - 1) mod 3
   r = (ind - 1) div 3
   x = c * 28 + 20
   y = r * 28 + 30
   if f[ind] = 4
      color 900
      move x - 7 y - 7
      line x + 7 y + 7
      move x + 7 y - 7
      line x - 7 y + 7
   elif f[ind] = 1
      color 009
      move x y
      circle 10
      color -2
      circle 7.5
   .
.
proc sum3 a d . st .
   for i = 1 to 3
      s += f[a]
      a += d
   .
   if s = 3
      st = -1
   elif s = 12
      st = 1
   .
.
proc rate . res done .
   res = 0
   for i = 1 step 3 to 7
      sum3 i 1 res
   .
   for i = 1 to 3
      sum3 i 3 res
   .
   sum3 1 4 res
   sum3 3 2 res
   cnt = 1
   for i = 1 to 9
      if f[i] = 0
         cnt += 1
      .
   .
   res *= cnt
   done = 1
   if res = 0 and cnt > 1
      done = 0
   .
.
proc minmax player alpha beta . rval rmov .
   rate rval done
   if done = 1
      if player = 1
         rval = -rval
      .
   else
      rval = alpha
      start = random 9
      mov = start
      repeat
         if f[mov] = 0
            f[mov] = player
            minmax (5 - player) (-beta) (-rval) val h
            val = -val
            f[mov] = 0
            if val > rval
               rval = val
               rmov = mov
            .
         .
         mov = mov mod 9 + 1
         until mov = start or rval >= beta
      .
   .
.
proc show_result val . .
   color 555
   move 16 4
   if val < 0
      # this never happens
      text "You won"
   elif val > 0
      text "You lost"
   else
      text "Tie"
   .
   state += 2
.
proc computer . .
   minmax 4 -11 11 val mov
   f[mov] = 4
   draw mov
   rate val done
   state = 0
   if done = 1
      show_result val
   .
.
proc human . .
   mov = floor ((mouse_x - 6) / 28) + 3 * floor ((mouse_y - 16) / 28) + 1
   if f[mov] = 0
      f[mov] = 1
      draw mov
      state = 1
      timer 0.5
   .
.
on timer
   rate val done
   if done = 1
      show_result val
   else
      computer
   .
.
on mouse_down
   if state = 0
      if mouse_x > 6 and mouse_x < 90 and mouse_y > 16
         human
      .
   elif state >= 2
      state -= 2
      init
   .
.
init
*
* Time a function
*
@ https://rosettacode.org/wiki/Time_a_function@Task
*
func fua lim .
   # this is interpreted
   i = 1
   while i <= lim
      sum += i
      i += 1
   .
   return sum
.
start = systime
print fua 1e8
print systime - start
# 
fastfunc fub lim .
   # this is compiled to wasm
   i = 1
   while i <= lim
      sum += i
      i += 1
   .
   return sum
.
start = systime
print fub 1e8
print systime - start
*
* Tokenize a string
*
@ https://rosettacode.org/wiki/Tokenize_a_string@Task
*
s$ = "Hello,How,Are,You,Today"
a$[] = strsplit s$ ","
print a$[]
*
* Total circles area
*
@ https://rosettacode.org/wiki/Total_circles_area@Task
*
# with Montecarlo sampling
repeat
   s$ = input
   until s$ = ""
   c[][] &= number strsplit s$ " "
.
# mark inner circles
for i to len c[][]
   for j to len c[][]
      if i <> j
         dx = abs (c[i][1] - c[j][1])
         dy = abs (c[i][2] - c[j][2])
         d = sqrt (dx * dx + dy * dy)
         if d + c[j][3] < c[i][3]
            c[j][3] = 0
         .
      .
   .
.
# find bounding box and remove marked circles
i = len c[][]
while i >= 1
   if 0 = 1 and c[i][3] = 0
      swap c[i][] c[len c[][]][]
      len c[][] -1
   else
      maxx = higher (c[i][1] + c[i][3]) maxx
      minx = lower (c[i][1] - c[i][3]) minx
      maxy = higher (c[i][2] + c[i][3]) maxy
      miny = lower (c[i][2] - c[i][3]) miny
      c[i][3] = c[i][3] * c[i][3]
   .
   i -= 1
.
ntry = 10000000
print ntry & " samples ..."
for try to ntry
   px = (maxx - minx) * randomf + minx
   py = (maxy - miny) * randomf + miny
   for i to len c[][]
      dx = px - c[i][1]
      dy = py - c[i][2]
      if dx * dx + dy * dy <= c[i][3]
         inside += 1
         break 1
      .
   .
.
numfmt 4 0
print inside / ntry * (maxx - minx) * (maxy - miny)
# 
input_data
1.6417233788 1.6121789534 0.0848270516
-1.4944608174 1.2077959613 1.1039549836
0.6110294452 -0.6907087527 0.9089162485
0.3844862411 0.2923344616 0.2375743054
-0.2495892950 -0.3832854473 1.0845181219
1.7813504266 1.6178237031 0.8162655711
-0.1985249206 -0.8343333301 0.0538864941
-1.7011985145 -0.1263820964 0.4776976918
-0.4319462812 1.4104420482 0.7886291537
0.2178372997 -0.9499557344 0.0357871187
-0.6294854565 -1.3078893852 0.7653357688
1.7952608455 0.6281269104 0.2727652452
1.4168575317 1.0683357171 1.1016025378
1.4637371396 0.9463877418 1.1846214562
-0.5263668798 1.7315156631 1.4428514068
-1.2197352481 0.9144146579 1.0727263474
-0.1389358881 0.1092805780 0.7350208828
1.5293954595 0.0030278255 1.2472867347
-0.5258728625 1.3782633069 1.3495508831
-0.1403562064 0.2437382535 1.3804956588
0.8055826339 -0.0482092025 0.3327165165
-0.6311979224 0.7184578971 0.2491045282
1.4685857879 -0.8347049536 1.3670667538
-0.6855727502 1.6465021616 1.0593087096
0.0152957411 0.0638919221 0.9771215985
*
* Totient function
*
@ https://rosettacode.org/wiki/Totient_function@Task
*
func totient n .
   tot = n
   i = 2
   while i <= sqrt n
      if n mod i = 0
         while n mod i = 0
            n = n div i
         .
         tot -= tot div i
      .
      if i = 2
         i = 1
      .
      i += 2
   .
   if n > 1
      tot -= tot div n
   .
   return tot
.
numfmt 0 3
print "  N Prim Phi"
for n = 1 to 25
   tot = totient n
   x$ = "    "
   if n - 1 = tot
      x$ = " x  "
   .
   print n & x$ & tot
.
print ""
for n = 1 to 100000
   tot = totient n
   if n - 1 = tot
      cnt += 1
   .
   if n = 100 or n = 1000 or n = 10000 or n = 100000
      print n & " - " & cnt & " primes"
   .
.
*
* Towers of Hanoi
*
@ https://rosettacode.org/wiki/Towers_of_Hanoi@Task
*
proc hanoi n src dst aux . .
   if n >= 1
      hanoi n - 1 src aux dst
      print "Move " & src & " to " & dst
      hanoi n - 1 aux dst src
   .
.
hanoi 5 1 2 3
*
* Tree traversal
*
@ https://rosettacode.org/wiki/Tree_traversal@Task
*
tree[] = [ 1 2 3 4 5 6 -1 7 -1 -1 -1 8 9 ]
# 
proc preorder ind . .
   if ind > len tree[] or tree[ind] = -1
      return
   .
   write " " & tree[ind]
   preorder ind * 2
   preorder ind * 2 + 1
.
write "preorder:"
preorder 1
print ""
# 
proc inorder ind . .
   if ind > len tree[] or tree[ind] = -1
      return
   .
   inorder ind * 2
   write " " & tree[ind]
   inorder ind * 2 + 1
.
write "inorder:"
inorder 1
print ""
# 
proc postorder ind . .
   if ind > len tree[] or tree[ind] = -1
      return
   .
   postorder ind * 2
   postorder ind * 2 + 1
   write " " & tree[ind]
.
write "postorder:"
postorder 1
print ""
# 
global tail head queue[] .
proc initqu n . .
   len queue[] n
   tail = 1
   head = 1
.
proc enqu v . .
   queue[tail] = v
   tail = (tail + 1) mod1 len queue[]
.
func dequ .
   if head = tail
      return -1
   .
   h = head
   head = (head + 1) mod1 len queue[]
   return queue[h]
.
initqu len tree[]
proc levelorder n . .
   enqu n
   repeat
      ind = dequ
      until ind = -1
      if ind < len tree[] and tree[ind] <> -1
         write " " & tree[ind]
         enqu ind * 2
         enqu ind * 2 + 1
      .
   .
.
write "level-order:"
levelorder 1
print ""
*
* Twelve statements
*
@ https://rosettacode.org/wiki/Twelve_statements@Task
*
len t[] 12
func f n .
   if n = 1
      return if 12 = 12
   elif n = 2
      for i = 7 to 12
         s += t[i]
      .
      return if s = 3
   elif n = 3
      for i = 2 step 2 to 12
         s += t[i]
      .
      return if s = 2
   elif n = 4
      if t[5] = 1
         return if t[6] + t[7] = 2
      .
      return 1
   elif n = 5
      for i = 2 to 4
         s += t[i]
      .
      return if s = 0
   elif n = 6
      for i = 1 step 2 to 11
         s += t[i]
      .
      return if s = 4
   elif n = 7
      return if t[2] + t[3] = 1
   elif n = 8
      if t[7] = 1
         return if t[5] + t[6] = 2
      .
      return 1
   elif n = 9
      for i = 1 to 6
         s += t[i]
      .
      return if s = 3
   elif n = 10
      return if t[11] + t[12] = 2
   elif n = 11
      for i = 7 to 9
         s += t[i]
      .
      return if s = 1
   elif n = 12
      for i = 1 to 11
         s += t[i]
      .
      return if s = 4
   .
.
for tst = 0 to 4095
   h = tst
   for i to 12
      t[i] = h mod 2
      h = h div 2
   .
   s = 0
   for i to 12
      s += if f i = t[i]
   .
   if s = 12
      print t[]
   .
.
*
* Twin primes
*
@ https://rosettacode.org/wiki/Twin_primes@Task
*
fastfunc isprim num .
   if num mod 2 = 0 and num > 2
      return 0
   .
   i = 3
   while i <= sqrt num
      if num mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
func count limit .
   p2 = 1
   p3 = 1
   for i = 5 to limit
      p3 = p2
      p2 = p1
      p1 = isprim i
      if p3 = 1 and p1 = 1
         cnt += 1
      .
   .
   return cnt
.
n = 1
for i = 1 to 6
   n *= 10
   print "twin prime pairs < " & n & " : " & count n
.
*
* Two bullet roulette
*
@ https://rosettacode.org/wiki/Two_bullet_roulette@Task
*
len cyl[] 6
proc rshift . .
   h = cyl[6]
   for i = 6 downto 2
      cyl[i] = cyl[i - 1]
   .
   cyl[1] = h
.
proc unload . .
   for i = 1 to 6
      cyl[i] = 0
   .
.
proc load . .
   while cyl[1] = 1
      rshift
   .
   cyl[1] = 1
   rshift
.
proc spin . .
   lim = random 6
   for i = 1 to lim - 1
      rshift
   .
.
func fire .
   shot = cyl[1]
   rshift
   return shot
.
func method m[] .
   unload
   for m in m[]
      if m = 1
         load
      elif m = 2
         spin
      elif m = 3
         if fire = 1
            return 1
         .
      .
   .
   return 0
.
method$[] = [ "load" "spin" "fire" ]
proc test m[] . .
   n = 100000
   for i = 1 to n
      sum += method m[]
   .
   for i = 1 to len m[]
      write method$[m[i]] & " "
   .
   print "-> " & 100 * sum / n & "% death"
.
test [ 1 2 1 2 3 2 3 ]
test [ 1 2 1 2 3 3 ]
test [ 1 1 2 3 2 3 ]
test [ 1 1 2 3 3 ]
*
* Two sum
*
@ https://rosettacode.org/wiki/Two_sum@Task
*
proc twoSum sum . array[] pair[] .
   i = 1
   j = len array[]
   pair[] = [ ]
   repeat
      if array[i] + array[j] = sum
         pair[] = [ i j ]
         return
      elif array[i] + array[j] > sum
         j -= 1
      elif array[i] + array[j] < sum
         i += 1
      .
      until i = j
   .
.
numbers[] = [ 0 2 11 19 90 ]
twoSum 21 numbers[] pair[]
print pair[]
*
* User input/Text
*
@ https://rosettacode.org/wiki/User_input/Text@Task
*
write "Enter a string: "
a$ = input
print ""
repeat
  write "Enter the number 75000: "
  h = number input
  print ""
  until h = 75000
.
print a$ & " " & h
*
* Van der Corput sequence
*
@ https://rosettacode.org/wiki/Van_der_Corput_sequence@Task
*
func vdc b n .
   s = 1
   while n > 0
      s *= b
      m = n mod b
      v += m / s
      n = n div b
   .
   return v
.
for b = 2 to 5
   write "base " & b & ":"
   for n range0 10
      write " " & vdc b n
   .
   print ""
.
*
* Van Eck sequence
*
@ https://rosettacode.org/wiki/Van_Eck_sequence@Task
*
len arr[] 1000
for n to 1000 - 1
   for m = n - 1 downto 1
      if arr[m] = arr[n]
         arr[n + 1] = n - m
         break 1
      .
   .
.
for i to 10
   write arr[i] & " "
.
print ""
for i = 991 to 1000
   write arr[i] & " "
.
*
* Variables
*
@ https://rosettacode.org/wiki/Variables@Task
*
# it is statically typed
# 
# global number variable
n = 99
print n
# global array of numbers
a[] = [ 2.1 3.14 3 ]
# 
proc foo . .
   # i is local, because it is first used in the function  
   for i = 1 to len a[]
      print a[i]
   .
.
foo
# 
# string
domain$ = "easylang.dev"
print domain$
# 
# array of strings
fruits$[] = [ "apple" "banana" "orange" ]
print fruits$[]
*
* Vibrating rectangles
*
@ https://rosettacode.org/wiki/Vibrating_rectangles@Task
*
on timer
  sz -= 2
  if sz < 0
    sz = 49
    color random 1000 - 1
  .
  move 50 - sz 50 - sz
  line 50 + sz 50 - sz
  line 50 + sz 50 + sz
  line 50 - sz 50 + sz
  line 50 - sz 50 - sz
  timer 0.2
.
timer 0.2
*
* Vigenère cipher
*
@ https://rosettacode.org/wiki/Vigenère_cipher@Task
*
func$ encr txt$ pw$ d .
   txt$[] = strchars txt$
   for c$ in strchars pw$
      pw[] &= strcode c$ - 65
   .
   for c$ in txt$[]
      c = strcode c$
      if c >= 97
         c -= 32
      .
      if c >= 65 and c <= 97
         pwi = (pwi + 1) mod1 len pw[]
         c = (c - 65 + d * pw[pwi]) mod 26 + 65
         r$ &= strchar c
      .
   .
   return r$
.
s$ = "Beware the Jabberwock, my son! The jaws that bite, the claws that catch!"
pw$ = "VIGENERECIPHER"
r$ = encr s$ pw$ 1
print r$
print encr r$ pw$ -1
*
* Wagstaff primes
*
@ https://rosettacode.org/wiki/Wagstaff_primes@Task
*
func prime n .
   if n mod 2 = 0 and n > 2
      return 0
   .
   i = 3
   while i <= sqrt n
      if n mod i = 0
         return 0
      .
      i += 2
   .
   return 1
.
pri = 1
while nwag <> 10
   pri += 2
   if prime pri = 1
      wag = (pow 2 pri + 1) / 3
      if prime wag = 1
         nwag += 1
         print pri & " => " & wag
      .
   .
.
*
* Water collected between towers
*
@ https://rosettacode.org/wiki/Water_collected_between_towers@Task
*
proc water h[] . .
   n = len h[]
   len left[] n
   len right[] n
   for i = 1 to n
      max = higher max h[i]
      left[i] = max
   .
   max = 0
   for i = n downto 1
      max = higher max h[i]
      right[i] = max
   .
   for i = 1 to n
      sum += (lower left[i] right[i]) - h[i]
   .
   print sum
.
repeat
   s$ = input
   until s$ = ""
   water number strsplit s$ " "
.
# 
input_data
1 5 3 7 2
5 3 7 2 6 4 5 9 1 2
2 6 3 5 2 8 1 4 2 2 5 3 5 7 4 1
5 5 5 5
5 6 7 8
8 7 7 6
6 7 10 7 6
*
* Word wrap
*
@ https://rosettacode.org/wiki/Word_wrap@Task
*
linew = 40
# 
ind = 1
repeat
   if ind > len words$[]
      inp$ = input
      words$[] = strsplit inp$ " "
      ind = 1
   .
   until inp$ = ""
   w$ = words$[ind]
   ind += 1
   if len out$ + len w$ + 1 <= linew
      if out$ <> ""
         out$ &= " "
      .
      out$ &= w$
   else
      print out$
      out$ = w$
   .
.
print out$
# 
input_data
In olden times when wishing still helped one, there lived a king
whose daughters were all beautiful, but the youngest was so beautiful
that the sun itself, which has seen so much, was astonished whenever
it shone in her face. Close by the king's castle lay a great dark
forest, and under an old lime-tree in the forest was a well, and when
the day was very warm, the king's child went out into the forest and
sat down by the side of the cool fountain, and when she was bored she
took a golden ball, and threw it up on high and caught it, and this
ball was her favorite plaything.’
*
* Zero to the zero power
*
@ https://rosettacode.org/wiki/Zero_to_the_zero_power@Task
*
print pow 0 0
`
function hook() {
	var dom = window.location.host
	tut.insertAdjacentHTML("beforeend", `
<p><hr><p>
The examples were created with <a href=..>${dom}<a>
<p><small>christof.kaser@gmail.com</small>
`)
}
</script>
