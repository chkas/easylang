# maze generation and solving
# 
size = 20
n = 2 * size + 1
endpos = n * n - 1
startpos = n + 2
# 
f = 100 / (n - 0.5)
len m[] n * n
# 
background 000
func show_maze . .
  clear
  for i = 1 to len m[]
    if m[i] = 0
      x = (i - 1) mod n
      y = (i - 1) div n
      color 777
      move x * f - f / 2 y * f - f / 2
      rect f * 1.5 f * 1.5
    .
  .
  sleep 0.001
.
offs[] = [ 1 n -1 (-n) ]
brdc[] = [ n - 2 -1 1 -1 ]
brdr[] = [ -1 n - 2 -1 1 ]
# 
func m_maze pos . .
  m[pos] = 0
  call show_maze
  d[] = [ 1 2 3 4 ]
  for i = 4 downto 1
    d = random i
    dir = d[d]
    d[d] = d[i]
    r = (pos - 1) div n
    c = (pos - 1) mod n
    posn = pos + 2 * offs[dir]
    if c <> brdc[dir] and r <> brdr[dir] and m[posn] <> 0
      posn = pos + 2 * offs[dir]
      m[pos + offs[dir]] = 0
      call m_maze posn
    .
  .
.
func make_maze . .
  for i = 1 to len m[]
    m[i] = 1
  .
  call m_maze startpos
  m[endpos] = 0
.
call make_maze
call show_maze
# 
func mark pos col . .
  x = (pos - 1) mod n
  y = (pos - 1) div n
  color col
  move x * f + f / 4 y * f + f / 4
  circle f / 4
.
func solve dir0 pos . found .
  call mark pos 900
  sleep 0.05
  if pos = endpos
    found = 1
  else
    for dir = 1 to 4
      posn = pos + offs[dir]
      if dir <> dir0 and m[posn] = 0 and found = 0
        call solve (dir + 1) mod 4 + 1 posn found
        if found = 0
          call mark posn 777
          sleep 0.05
        .
      .
    .
  .
.
sleep 2
call solve 0 startpos found

